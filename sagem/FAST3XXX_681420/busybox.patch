diff -pruwN busybox-1.01/00-README-FT.txt busybox-1.01-livebox/00-README-FT.txt
--- busybox-1.01/00-README-FT.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/00-README-FT.txt	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,7 @@
+
+The configuration is stored in the .config file.
+
+To build busybox:
+make CROSS="/path/to/mips-linux-uclibc/bin/mips-linux-uclibc-"
+
+The result is a stripped busybox.
diff -pruwN busybox-1.01/.config busybox-1.01-livebox/.config
--- busybox-1.01/.config	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/.config	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,392 @@
+#
+# Automatically generated make config: don't edit
+#
+HAVE_DOT_CONFIG=y
+
+#
+# General Configuration
+#
+CONFIG_FEATURE_BUFFERS_USE_MALLOC=y
+# CONFIG_FEATURE_BUFFERS_GO_ON_STACK is not set
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+# CONFIG_FEATURE_VERBOSE_USAGE is not set
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_FEATURE_DEVFS is not set
+# CONFIG_FEATURE_DEVPTS is not set
+CONFIG_FEATURE_CLEAN_UP=y
+# CONFIG_FEATURE_SUID is not set
+# CONFIG_SELINUX is not set
+
+#
+# Build Options
+#
+# CONFIG_STATIC is not set
+# CONFIG_LFS is not set
+# USING_CROSS_COMPILER is not set
+EXTRA_CFLAGS_OPTIONS="-D__TARGET__                            -D_LIBC_REENTRANT                       --no-strict-aliasing                    -g                                      -Os                                     -meb                                    -msoft-float                            -mabi=32                                -march=lx4189                           -Wa,-32                                 -Wa,-march=lx4189                       -Wa,-mips1                              -Werror                                "
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+PREFIX="./_install"
+
+#
+# Archival Utilities
+#
+# CONFIG_AR is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+# CONFIG_TAR is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNZIP is not set
+
+#
+# Coreutils
+#
+CONFIG_BASENAME=y
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+CONFIG_CHGRP=y
+CONFIG_CHMOD=y
+CONFIG_CHOWN=y
+# CONFIG_CHROOT is not set
+# CONFIG_CMP is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+# CONFIG_FEATURE_DATE_ISOFMT is not set
+# CONFIG_DD is not set
+CONFIG_DF=y
+# CONFIG_DIRNAME is not set
+# CONFIG_DOS2UNIX is not set
+# CONFIG_DU is not set
+CONFIG_ECHO=y
+# CONFIG_FEATURE_FANCY_ECHO is not set
+# CONFIG_ENV is not set
+CONFIG_EXPR=y
+# CONFIG_FALSE is not set
+# CONFIG_FOLD is not set
+CONFIG_HEAD=y
+# CONFIG_FEATURE_FANCY_HEAD is not set
+# CONFIG_HOSTID is not set
+# CONFIG_ID is not set
+# CONFIG_INSTALL is not set
+# CONFIG_LENGTH is not set
+CONFIG_LN=y
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+# CONFIG_FEATURE_LS_COLOR is not set
+# CONFIG_MD5SUM is not set
+CONFIG_MKDIR=y
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MV=y
+# CONFIG_OD is not set
+# CONFIG_PRINTF is not set
+# CONFIG_PWD is not set
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+CONFIG_RMDIR=y
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+CONFIG_SORT=y
+CONFIG_STTY=y
+CONFIG_SYNC=y
+CONFIG_TAIL=y
+# CONFIG_FEATURE_FANCY_TAIL is not set
+# CONFIG_TEE is not set
+CONFIG_TEST=y
+
+#
+# test (forced enabled for use with shell)
+#
+# CONFIG_FEATURE_TEST_64 is not set
+# CONFIG_TOUCH is not set
+CONFIG_TR=y
+# CONFIG_TRUE is not set
+# CONFIG_TTY is not set
+# CONFIG_UNAME is not set
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WATCH is not set
+# CONFIG_WC is not set
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+# CONFIG_FEATURE_PRESERVE_HARDLINKS is not set
+
+#
+# Common options for ls and more
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_SETKEYCODES is not set
+
+#
+# Debian Utilities
+#
+# CONFIG_MKTEMP is not set
+# CONFIG_PIPE_PROGRESS is not set
+CONFIG_READLINK=y
+# CONFIG_RUN_PARTS is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_WHICH is not set
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_PATCH is not set
+CONFIG_SED=y
+# CONFIG_VI is not set
+
+#
+# Finding Utilities
+#
+# CONFIG_FIND is not set
+CONFIG_GREP=y
+# CONFIG_FEATURE_GREP_EGREP_ALIAS is not set
+# CONFIG_FEATURE_GREP_FGREP_ALIAS is not set
+# CONFIG_FEATURE_GREP_CONTEXT is not set
+# CONFIG_XARGS is not set
+
+#
+# Init Utilities
+#
+# CONFIG_INIT is not set
+# CONFIG_HALT is not set
+# CONFIG_POWEROFF is not set
+# CONFIG_REBOOT is not set
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_DELUSER is not set
+# CONFIG_GETTY is not set
+# CONFIG_LOGIN is not set
+# CONFIG_PASSWD is not set
+# CONFIG_SU is not set
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_CROND is not set
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_LAST is not set
+# CONFIG_HDPARM is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_MT is not set
+# CONFIG_RX is not set
+# CONFIG_STRINGS is not set
+# CONFIG_TIME is not set
+# CONFIG_WATCHDOG is not set
+
+#
+# Linux Module Utilities
+#
+CONFIG_INSMOD=y
+# CONFIG_FEATURE_2_4_MODULES is not set
+CONFIG_FEATURE_2_6_MODULES=y
+CONFIG_LSMOD=y
+# CONFIG_MODPROBE is not set
+CONFIG_RMMOD=y
+# CONFIG_FEATURE_CHECK_TAINTED_MODULE is not set
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+# CONFIG_ARPING is not set
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_HOSTNAME is not set
+# CONFIG_HTTPD is not set
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFUPDOWN is not set
+# CONFIG_INETD is not set
+# CONFIG_IP is not set
+# CONFIG_IPCALC is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+# CONFIG_IPROUTE is not set
+# CONFIG_IPTUNNEL is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_NC is not set
+CONFIG_NETSTAT=y
+# CONFIG_NSLOOKUP is not set
+CONFIG_PING=y
+# CONFIG_FEATURE_FANCY_PING is not set
+CONFIG_ROUTE=y
+# CONFIG_TELNET is not set
+# CONFIG_TELNETD is not set
+CONFIG_TFTP=y
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_FEATURE_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+# CONFIG_VCONFIG is not set
+# CONFIG_WGET is not set
+
+#
+# udhcp Server/Client
+#
+# CONFIG_UDHCPD is not set
+# CONFIG_UDHCPC is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+# CONFIG_PIDOF is not set
+CONFIG_PS=y
+CONFIG_RENICE=y
+CONFIG_TOP=y
+FEATURE_CPU_USAGE_PERCENTAGE=y
+CONFIG_UPTIME=y
+# CONFIG_SYSCTL is not set
+
+#
+# Another Bourne-like Shell
+#
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_LASH is not set
+# CONFIG_FEATURE_SH_IS_MSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_ASH=y
+
+#
+# Ash Shell Options
+#
+CONFIG_ASH_JOB_CONTROL=y
+CONFIG_ASH_ALIAS=y
+CONFIG_ASH_MATH_SUPPORT=y
+CONFIG_ASH_MATH_SUPPORT_64=y
+# CONFIG_ASH_GETOPTS is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_HUSH is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+CONFIG_FEATURE_COMMAND_EDITING=y
+CONFIG_FEATURE_COMMAND_HISTORY=15
+CONFIG_FEATURE_COMMAND_SAVEHISTORY=y
+CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
+# CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_SH_FANCY_PROMPT=y
+
+#
+# System Logging Utilities
+#
+# CONFIG_SYSLOGD is not set
+# CONFIG_LOGGER is not set
+
+#
+# Linux System Utilities
+#
+# CONFIG_DMESG is not set
+# CONFIG_FBSET is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+CONFIG_FDISK=y
+CONFIG_MKDOSFS=y
+CONFIG_DOSFSCK=y
+# FDISK_SUPPORT_LARGE_DISKS is not set
+CONFIG_FEATURE_FDISK_WRITABLE=y
+# CONFIG_FEATURE_AIX_LABEL is not set
+# CONFIG_FEATURE_SGI_LABEL is not set
+# CONFIG_FEATURE_SUN_LABEL is not set
+# CONFIG_FEATURE_OSF_LABEL is not set
+# CONFIG_FEATURE_FDISK_ADVANCED is not set
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_GETOPT is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_MKSWAP is not set
+# CONFIG_MORE is not set
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_SWAPONOFF is not set
+CONFIG_MOUNT=y
+# CONFIG_NFSMOUNT is not set
+CONFIG_UMOUNT=y
+CONFIG_FEATURE_MOUNT_FORCE=y
+
+#
+# Common options for mount/umount
+#
+CONFIG_FEATURE_MOUNT_LOOP=y
+CONFIG_FEATURE_MTAB_SUPPORT=y
+CONFIG_FEATURE_MTAB_FILENAME="/etc/mtab"
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
diff -pruwN busybox-1.01/coreutils/Config.in busybox-1.01-livebox/coreutils/Config.in
--- busybox-1.01/coreutils/Config.in	2005-08-17 03:29:14.000000000 +0200
+++ busybox-1.01-livebox/coreutils/Config.in	2011-02-01 13:48:39.000000000 +0100
@@ -70,7 +70,10 @@ config CONFIG_CUT
 	default n
 	help
 	  cut is used to print selected parts of lines from
-	  each file to stdout.
+config CONFIG_DATE
+		default y
+        help 
+    	  set the date
 
 if CONFIG_WATCH
 	config CONFIG_DATE
diff -pruwN busybox-1.01/editors/vi.c busybox-1.01-livebox/editors/vi.c
--- busybox-1.01/editors/vi.c	2005-08-17 03:29:16.000000000 +0200
+++ busybox-1.01-livebox/editors/vi.c	2011-02-01 13:48:39.000000000 +0100
@@ -19,7 +19,7 @@
  */
 
 static const char vi_Version[] =
-	"$Id: vi.c,v 1.38 2004/08/19 19:15:06 andersen Exp $";
+	"$Id: vi.c,v 1.1.4.1 2005/09/20 12:56:02 yariv Exp $";
 
 /*
  * To compile for standalone use:
diff -pruwN busybox-1.01/include/applets.h busybox-1.01-livebox/include/applets.h
--- busybox-1.01/include/applets.h	2005-08-17 03:29:15.000000000 +0200
+++ busybox-1.01-livebox/include/applets.h	2011-02-01 13:48:39.000000000 +0100
@@ -41,12 +41,10 @@
   #define APPLET_ODDNAME(a,b,c,d,e) {a,b,c,d},
 #endif
 
-#ifdef CONFIG_INSTALL_NO_USR
+/* A simple way to put them all in /bin */
 #define _BB_DIR_USR_BIN _BB_DIR_BIN
-#define _BB_DIR_USR_SBIN _BB_DIR_SBIN
-#endif
-
-
+#define _BB_DIR_USR_SBIN _BB_DIR_BIN
+#define _BB_DIR_SBIN _BB_DIR_BIN
 
 #ifdef CONFIG_TEST
 	APPLET_NOUSAGE("[", test_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
@@ -157,6 +155,9 @@
 #ifdef CONFIG_DOS2UNIX
 	APPLET(dos2unix, dos2unix_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
+#ifdef CONFIG_DOSFSCK
+	APPLET(dosfsck, dosfsck_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_DPKG
 	APPLET(dpkg, dpkg_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
@@ -370,6 +371,9 @@
 #ifdef CONFIG_MKDIR
 	APPLET(mkdir, mkdir_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
+#ifdef CONFIG_MKDOSFS
+	APPLET(mkdosfs, mkdosfs_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_MKFIFO
 	APPLET(mkfifo, mkfifo_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
diff -pruwN busybox-1.01/include/applets.h.orig busybox-1.01-livebox/include/applets.h.orig
--- busybox-1.01/include/applets.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include/applets.h.orig	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,678 @@
+/*
+ * applets.h - a listing of all busybox applets.
+ *
+ * If you write a new applet, you need to add an entry to this list to make
+ * busybox aware of it.
+ *
+ * It is CRUCIAL that this listing be kept in ascii order, otherwise the binary
+ * search lookup contributed by Gaute B Strokkenes stops working. If you value
+ * your kneecaps, you'll be sure to *make sure* that any changes made to this
+ * file result in the listing remaining in ascii order. You have been warned.
+ */
+
+#undef APPLET
+#undef APPLET_ODDNAME
+#undef APPLET_NOUSAGE
+
+
+#if defined(PROTOTYPES)
+  #define APPLET(a,b,c,d) extern int b(int argc, char **argv);
+  #define APPLET_NOUSAGE(a,b,c,d) extern int b(int argc, char **argv);
+  #define APPLET_ODDNAME(a,b,c,d,e) extern int b(int argc, char **argv);
+  extern const char usage_messages[];
+#elif defined(MAKE_USAGE)
+  #ifdef CONFIG_FEATURE_VERBOSE_USAGE
+    #define APPLET(a,b,c,d) a##_trivial_usage "\n\n" a##_full_usage "\0"
+    #define APPLET_NOUSAGE(a,b,c,d) "\b\0"
+    #define APPLET_ODDNAME(a,b,c,d,e) e##_trivial_usage "\n\n" e##_full_usage "\0"
+  #else
+    #define APPLET(a,b,c,d) a##_trivial_usage "\0"
+    #define APPLET_NOUSAGE(a,b,c,d) "\b\0"
+    #define APPLET_ODDNAME(a,b,c,d,e) e##_trivial_usage "\0"
+  #endif
+#elif defined(MAKE_LINKS)
+#  define APPLET(a,b,c,d) LINK c a
+#  define APPLET_NOUSAGE(a,b,c,d) LINK c a
+#  define APPLET_ODDNAME(a,b,c,d,e) LINK c a
+#else
+  const struct BB_applet applets[] = {
+  #define APPLET(a,b,c,d) {#a,b,c,d},
+  #define APPLET_NOUSAGE(a,b,c,d) {a,b,c,d},
+  #define APPLET_ODDNAME(a,b,c,d,e) {a,b,c,d},
+#endif
+
+#ifdef CONFIG_INSTALL_NO_USR
+#define _BB_DIR_USR_BIN _BB_DIR_BIN
+#define _BB_DIR_USR_SBIN _BB_DIR_SBIN
+#endif
+
+
+
+#ifdef CONFIG_TEST
+	APPLET_NOUSAGE("[", test_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_ADDGROUP
+	APPLET(addgroup, addgroup_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_ADDUSER
+	APPLET(adduser, adduser_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_ADJTIMEX
+	APPLET(adjtimex, adjtimex_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_AR
+	APPLET(ar, ar_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_ARPING
+	APPLET(arping, arping_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_ASH
+	APPLET_NOUSAGE("ash", ash_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_AWK
+	APPLET(awk, awk_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_BASENAME
+	APPLET(basename, basename_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_BUNZIP2
+	APPLET(bunzip2, bunzip2_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+	APPLET_NOUSAGE("busybox", busybox_main, _BB_DIR_BIN, _BB_SUID_MAYBE)
+#ifdef CONFIG_BUNZIP2
+	APPLET(bzcat, bunzip2_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CAL
+	APPLET(cal, cal_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CAT
+	APPLET(cat, cat_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CHGRP
+	APPLET(chgrp, chgrp_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CHMOD
+	APPLET(chmod, chmod_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CHOWN
+	APPLET(chown, chown_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CHROOT
+	APPLET(chroot, chroot_main, _BB_DIR_USR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CHVT
+	APPLET(chvt, chvt_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CLEAR
+	APPLET(clear, clear_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CMP
+	APPLET(cmp, cmp_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CP
+	APPLET(cp, cp_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CPIO
+	APPLET(cpio, cpio_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CROND
+	APPLET(crond, crond_main, _BB_DIR_USR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_CRONTAB
+	APPLET(crontab, crontab_main, _BB_DIR_USR_BIN, _BB_SUID_ALWAYS)
+#endif
+#ifdef CONFIG_CUT
+	APPLET(cut, cut_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DATE
+	APPLET(date, date_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DC
+	APPLET(dc, dc_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DD
+	APPLET(dd, dd_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DEALLOCVT
+	APPLET(deallocvt, deallocvt_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DELGROUP
+	APPLET(delgroup, delgroup_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DELUSER
+	APPLET(deluser, deluser_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DEVFSD
+	APPLET(devfsd, devfsd_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DF
+	APPLET(df, df_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DIRNAME
+	APPLET(dirname, dirname_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DMESG
+	APPLET(dmesg, dmesg_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DOS2UNIX
+	APPLET(dos2unix, dos2unix_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DPKG
+	APPLET(dpkg, dpkg_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DPKG_DEB
+	APPLET_ODDNAME("dpkg-deb", dpkg_deb_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER, dpkg_deb)
+#endif
+#ifdef CONFIG_DU
+	APPLET(du, du_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DUMPKMAP
+	APPLET(dumpkmap, dumpkmap_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_DUMPLEASES
+        APPLET(dumpleases, dumpleases_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_ECHO
+	APPLET(echo, echo_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#if defined(CONFIG_FEATURE_GREP_EGREP_ALIAS)
+	APPLET_NOUSAGE("egrep", grep_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_ENV
+	APPLET(env, env_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_EXPR
+	APPLET(expr, expr_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FALSE
+	APPLET(false, false_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FBSET
+	APPLET(fbset, fbset_main, _BB_DIR_USR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FDFLUSH
+	APPLET(fdflush, fdflush_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FDFORMAT
+	APPLET(fdformat, fdformat_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FDISK
+	APPLET(fdisk, fdisk_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#if defined(CONFIG_FEATURE_GREP_FGREP_ALIAS)
+	APPLET_NOUSAGE("fgrep", grep_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FIND
+	APPLET(find, find_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FOLD
+	APPLET(fold, fold_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FREE
+	APPLET(free, free_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FREERAMDISK
+	APPLET(freeramdisk, freeramdisk_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FSCK_MINIX
+	APPLET_ODDNAME("fsck.minix", fsck_minix_main, _BB_DIR_SBIN, _BB_SUID_NEVER, fsck_minix)
+#endif
+#ifdef CONFIG_FTPGET
+	APPLET(ftpget, ftpgetput_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FTPPUT
+	APPLET(ftpput, ftpgetput_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_GETOPT
+	APPLET(getopt, getopt_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_GETTY
+	APPLET(getty, getty_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_GREP
+	APPLET(grep, grep_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_GUNZIP
+	APPLET(gunzip, gunzip_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_GZIP
+	APPLET(gzip, gzip_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_HALT
+	APPLET(halt, halt_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_HDPARM
+	APPLET(hdparm, hdparm_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_HEAD
+	APPLET(head, head_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_HEXDUMP
+	APPLET(hexdump, hexdump_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_HOSTID
+	APPLET(hostid, hostid_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_HOSTNAME
+	APPLET(hostname, hostname_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_HTTPD
+	APPLET(httpd, httpd_main, _BB_DIR_USR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_HUSH
+	APPLET_NOUSAGE("hush", hush_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_HWCLOCK
+	APPLET(hwclock, hwclock_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_ID
+	APPLET(id, id_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_IFCONFIG
+	APPLET(ifconfig, ifconfig_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_IFUPDOWN
+	APPLET(ifdown, ifupdown_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_IFUPDOWN
+	APPLET(ifup, ifupdown_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_INETD
+	APPLET(inetd, inetd_main, _BB_DIR_USR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_INIT
+	APPLET(init, init_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_INSMOD
+	APPLET(insmod, insmod_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_INSTALL
+	APPLET(install, install_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_IP
+	APPLET(ip, ip_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_IPADDR
+	APPLET(ipaddr, ipaddr_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_IPCALC
+	APPLET(ipcalc, ipcalc_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_IPLINK
+	APPLET(iplink, iplink_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_IPROUTE
+	APPLET(iproute, iproute_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_IPTUNNEL
+	APPLET(iptunnel, iptunnel_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_KILL
+	APPLET(kill, kill_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_KILLALL
+	APPLET(killall, kill_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_KLOGD
+	APPLET(klogd, klogd_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LASH
+	APPLET(lash, lash_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LAST
+	APPLET(last, last_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LENGTH
+	APPLET(length, length_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_FEATURE_INITRD
+	APPLET_NOUSAGE("linuxrc", init_main, _BB_DIR_ROOT, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LN
+	APPLET(ln, ln_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LOADFONT
+	APPLET(loadfont, loadfont_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LOADKMAP
+	APPLET(loadkmap, loadkmap_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LOGGER
+	APPLET(logger, logger_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LOGIN
+	APPLET(login, login_main, _BB_DIR_BIN, _BB_SUID_ALWAYS)
+#endif
+#ifdef CONFIG_LOGNAME
+	APPLET(logname, logname_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LOGREAD
+	APPLET(logread, logread_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LOSETUP
+	APPLET(losetup, losetup_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LS
+	APPLET(ls, ls_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_LSMOD
+	APPLET(lsmod, lsmod_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MAKEDEVS
+	APPLET(makedevs, makedevs_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MD5SUM
+	APPLET(md5sum, md5sum_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MESG
+	APPLET(mesg, mesg_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MKDIR
+	APPLET(mkdir, mkdir_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MKFIFO
+	APPLET(mkfifo, mkfifo_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MKFS_MINIX
+	APPLET_ODDNAME("mkfs.minix", mkfs_minix_main, _BB_DIR_SBIN, _BB_SUID_NEVER, mkfs_minix)
+#endif
+#ifdef CONFIG_MKNOD
+	APPLET(mknod, mknod_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MKSWAP
+	APPLET(mkswap, mkswap_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MKTEMP
+	APPLET(mktemp, mktemp_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MODPROBE
+	APPLET(modprobe, modprobe_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MORE
+	APPLET(more, more_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MOUNT
+	APPLET(mount, mount_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MSH
+	APPLET_NOUSAGE("msh", msh_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MT
+	APPLET(mt, mt_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_MV
+	APPLET(mv, mv_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_NAMEIF
+	APPLET(nameif, nameif_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_NC
+	APPLET(nc, nc_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_NETSTAT
+	APPLET(netstat, netstat_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_NSLOOKUP
+	APPLET(nslookup, nslookup_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_OD
+	APPLET(od, od_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_OPENVT
+	APPLET(openvt, openvt_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_PASSWD
+	APPLET(passwd, passwd_main, _BB_DIR_USR_BIN, _BB_SUID_ALWAYS)
+#endif
+#ifdef CONFIG_PATCH
+	APPLET(patch, patch_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_PIDOF
+	APPLET(pidof, pidof_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_PING
+	APPLET(ping, ping_main, _BB_DIR_BIN, _BB_SUID_MAYBE)
+#endif
+#ifdef CONFIG_PING6
+	APPLET(ping6, ping6_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_PIPE_PROGRESS
+	APPLET_NOUSAGE("pipe_progress", pipe_progress_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_PIVOT_ROOT
+	APPLET(pivot_root, pivot_root_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_POWEROFF
+	APPLET(poweroff, poweroff_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_PRINTF
+	APPLET(printf, printf_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_PS
+	APPLET(ps, ps_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_PWD
+	APPLET(pwd, pwd_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_RDATE
+	APPLET(rdate, rdate_main, _BB_DIR_USR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_READLINK
+	APPLET(readlink, readlink_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_REALPATH
+	APPLET(realpath, realpath_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_REBOOT
+	APPLET(reboot, reboot_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_RENICE
+	APPLET(renice, renice_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_RESET
+	APPLET(reset, reset_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_RM
+	APPLET(rm, rm_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_RMDIR
+	APPLET(rmdir, rmdir_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_RMMOD
+	APPLET(rmmod, rmmod_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_ROUTE
+	APPLET(route, route_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_RPM
+	APPLET(rpm, rpm_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_RPM2CPIO
+	APPLET(rpm2cpio, rpm2cpio_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_RUN_PARTS
+	APPLET_ODDNAME("run-parts", run_parts_main, _BB_DIR_BIN, _BB_SUID_NEVER, run_parts)
+#endif
+#ifdef CONFIG_RX
+	APPLET(rx, rx_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SED
+	APPLET(sed, sed_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SEQ
+	APPLET(seq, seq_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SETKEYCODES
+	APPLET(setkeycodes, setkeycodes_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#if defined(CONFIG_FEATURE_SH_IS_ASH) && defined(CONFIG_ASH)
+	APPLET_NOUSAGE("sh", ash_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#elif defined(CONFIG_FEATURE_SH_IS_HUSH) && defined(CONFIG_HUSH)
+	APPLET_NOUSAGE("sh", hush_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#elif defined(CONFIG_FEATURE_SH_IS_LASH) && defined(CONFIG_LASH)
+	APPLET_NOUSAGE("sh", lash_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#elif defined(CONFIG_FEATURE_SH_IS_MSH) && defined(CONFIG_MSH)
+	APPLET_NOUSAGE("sh", msh_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SHA1SUM
+	APPLET(sha1sum, sha1sum_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SLEEP
+	APPLET(sleep, sleep_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SORT
+	APPLET(sort, sort_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_START_STOP_DAEMON
+    APPLET_ODDNAME("start-stop-daemon", start_stop_daemon_main, _BB_DIR_SBIN, _BB_SUID_NEVER, start_stop_daemon)
+#endif
+#ifdef CONFIG_STRINGS
+	APPLET(strings, strings_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_STTY
+	APPLET(stty, stty_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SU
+	APPLET(su, su_main, _BB_DIR_BIN, _BB_SUID_ALWAYS)
+#endif
+#ifdef CONFIG_SULOGIN
+	APPLET(sulogin, sulogin_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SWAPONOFF
+	APPLET(swapoff, swap_on_off_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SWAPONOFF
+	APPLET(swapon, swap_on_off_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SYNC
+	APPLET(sync, sync_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SYSCTL
+	APPLET(sysctl, sysctl_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_SYSLOGD
+	APPLET(syslogd, syslogd_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TAIL
+	APPLET(tail, tail_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TAR
+	APPLET(tar, tar_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TEE
+	APPLET(tee, tee_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TELNET
+	APPLET(telnet, telnet_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TELNETD
+	APPLET(telnetd, telnetd_main, _BB_DIR_USR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TEST
+	APPLET(test, test_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TFTP
+	APPLET(tftp, tftp_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TIME
+	APPLET(time, time_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TOP
+	APPLET(top, top_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TOUCH
+	APPLET(touch, touch_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TR
+	APPLET(tr, tr_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TRACEROUTE
+	APPLET(traceroute, traceroute_main, _BB_DIR_USR_BIN, _BB_SUID_MAYBE)
+#endif
+#ifdef CONFIG_TRUE
+	APPLET(true, true_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_TTY
+	APPLET(tty, tty_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UDHCPC
+	APPLET(udhcpc, udhcpc_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UDHCPD
+        APPLET(udhcpd, udhcpd_main, _BB_DIR_USR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UMOUNT
+	APPLET(umount, umount_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UNAME
+	APPLET(uname, uname_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UNCOMPRESS
+	APPLET(uncompress, uncompress_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UNIQ
+	APPLET(uniq, uniq_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UNIX2DOS
+	APPLET(unix2dos, dos2unix_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UNZIP
+	APPLET(unzip, unzip_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UPTIME
+	APPLET(uptime, uptime_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_USLEEP
+	APPLET(usleep, usleep_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UUDECODE
+	APPLET(uudecode, uudecode_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_UUENCODE
+	APPLET(uuencode, uuencode_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_VCONFIG
+	APPLET(vconfig, vconfig_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_VI
+	APPLET(vi, vi_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_VLOCK
+	APPLET(vlock, vlock_main, _BB_DIR_USR_BIN, _BB_SUID_ALWAYS)
+#endif
+#ifdef CONFIG_WATCH
+	APPLET(watch, watch_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_WATCHDOG
+	APPLET(watchdog, watchdog_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_WC
+	APPLET(wc, wc_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_WGET
+	APPLET(wget, wget_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_WHICH
+	APPLET(which, which_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_WHO
+	APPLET(who, who_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_WHOAMI
+	APPLET(whoami, whoami_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_XARGS
+	APPLET(xargs, xargs_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_YES
+	APPLET(yes, yes_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
+#ifdef CONFIG_GUNZIP
+	APPLET(zcat, gunzip_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+
+#if !defined(PROTOTYPES) && !defined(MAKE_USAGE)
+	{ 0,NULL,0,0 }
+};
+
+#endif
diff -pruwN busybox-1.01/include/usage.h busybox-1.01-livebox/include/usage.h
--- busybox-1.01/include/usage.h	2005-08-17 03:29:15.000000000 +0200
+++ busybox-1.01-livebox/include/usage.h	2011-02-01 13:48:39.000000000 +0100
@@ -623,6 +623,44 @@
 	"\t-S SECTORS  Set the number of sectors\n" \
 	"\t-v  Give fdisk version"
 
+#define mkdosfs_trivial_usage \
+	"[options] /dev/name [blocks]"
+#define mkdosfs_full_usage \
+	"Create an MS-DOS file system under Linux\n" \
+	"Options:\n" \
+	"\t-b  sector-of-backup Selects the location of the backup boot sector for FAT32\n" \
+	"\t-c  Check the device for bad blocks before creating the file system\n" \
+	"\t-C  Create the file given as device on the command line\n" \
+	"\t-f  number-of-FATs Specify the number of file allocation tables in the file system\n" \
+	"\t-F  FAT-size Specifies the type of file allocation tables used (12, 16 or 32 bit)\n" \
+	"\t-h  number-of-hidden-sectors Select the number of hidden sectors in the volume\n" \
+	"\t-i  volume-id Sets the volume ID of the newly created filesystem\n" \
+	"\t-I  This switch will force mkdosfs to work properly\n" \
+	"\t-l  filename Read the bad blocks list from filename\n" \
+	"\t-n  volume-name Sets the volume name (label) of the filesystem\n" \
+	"\t-r  root-dir-entries Select the number of entries available in the root directory\n" \
+	"\t-R  number-of-reserved-sectors Select the number of reserved sectos\n" \
+	"\t-s  sectors-per-cluster Specify the number of disk sectors per cluster\n" \
+	"\t-S  logical-sector-size Specify the number of bytes per logical sector\n" \
+	"\t-v  Verbose execution\n"
+
+#define dosfsck_trivial_usage \
+    "[options] /dev/name"
+#define dosfsck_full_usage \
+	"Check and repair MS-DOS file systems\n" \
+    "Options:\n" \
+    "-a Automatically repair the file system\n" \
+    "-d path  drop that file\n" \
+    "-f Salvage unused chains to files\n" \
+    "-l List path names\n" \
+    "-n No-op, check non-interactively without changing\n" \
+    "-r Interactively repair the file system\n" \
+    "-t Test for bad clusters\n" \
+    "-u path Try to undelete that (non-directory) file\n" \
+    "-v Verbose mode\n" \
+    "-V Perform a verification pass\n" \
+    "-w Write changes to disk immediately\n"
+
 #ifdef CONFIG_FEATURE_FIND_TYPE
   #define USAGE_FIND_TYPE(a) a
 #else
diff -pruwN busybox-1.01/include2/alloca.h busybox-1.01-livebox/include2/alloca.h
--- busybox-1.01/include2/alloca.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/alloca.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,41 @@
+/* Copyright (C) 1992, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_ALLOCA_H
+#define	_ALLOCA_H	1
+
+#include <features.h>
+
+#define	__need_size_t
+#include <stddef.h>
+
+__BEGIN_DECLS
+
+/* Remove any previous definitions.  */
+#undef	alloca
+
+/* Allocate a block that will be freed when the calling function exits.  */
+extern void *alloca (size_t __size) __THROW;
+
+#ifdef	__GNUC__
+# define alloca(size)	__builtin_alloca (size)
+#endif /* GCC.  */
+
+__END_DECLS
+
+#endif /* alloca.h */
diff -pruwN busybox-1.01/include2/arpa/inet.h busybox-1.01-livebox/include2/arpa/inet.h
--- busybox-1.01/include2/arpa/inet.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/arpa/inet.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,106 @@
+/* Copyright (C) 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _ARPA_INET_H
+#define	_ARPA_INET_H	1
+
+#include <features.h>
+#include <netinet/in.h>		/* To define `struct in_addr'.  */
+
+/* Type for length arguments in socket calls.  */
+#ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+# define __socklen_t_defined
+#endif
+
+__BEGIN_DECLS
+
+/* Convert Internet host address from numbers-and-dots notation in CP
+   into binary data in network byte order.  */
+extern in_addr_t inet_addr (__const char *__cp) __THROW;
+
+/* Return the local host address part of the Internet address in IN.  */
+extern in_addr_t inet_lnaof (struct in_addr __in) __THROW;
+
+/* Make Internet host address in network byte order by combining the
+   network number NET with the local address HOST.  */
+extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
+     __THROW;
+
+/* Return network number part of the Internet address IN.  */
+extern in_addr_t inet_netof (struct in_addr __in) __THROW;
+
+/* Extract the network number in network byte order from the address
+   in numbers-and-dots natation starting at CP.  */
+extern in_addr_t inet_network (__const char *__cp) __THROW;
+
+/* Convert Internet number in IN to ASCII representation.  The return value
+   is a pointer to an internal array containing the string.  */
+extern char *inet_ntoa (struct in_addr __in) __THROW;
+
+/* Convert from presentation format of an Internet number in buffer
+   starting at CP to the binary network format and store result for
+   interface type AF in buffer starting at BUF.  */
+extern int inet_pton (int __af, __const char *__restrict __cp,
+		      void *__restrict __buf) __THROW;
+
+/* Convert a Internet address in binary network format for interface
+   type AF in buffer starting at CP to presentation form and place
+   result in buffer of length LEN astarting at BUF.  */
+extern __const char *inet_ntop (int __af, __const void *__restrict __cp,
+				char *__restrict __buf, socklen_t __len)
+     __THROW;
+
+
+/* The following functions are not part of XNS 5.2.  */
+#ifdef __USE_MISC
+/* Convert Internet host address from numbers-and-dots notation in CP
+   into binary data and store the result in the structure INP.  */
+extern in_addr_t inet_aton (__const char *__cp, struct in_addr *__inp) __THROW;
+
+/* Format a network number NET into presentation format and place result
+   in buffer starting at BUF with length of LEN bytes.  */
+extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __THROW;
+
+/* Convert network number for interface type AF in buffer starting at
+   CP to presentation format.  The result will specifiy BITS bits of
+   the number.  */
+extern char *inet_net_ntop (int __af, __const void *__cp, int __bits,
+			    char *__buf, size_t __len) __THROW;
+
+/* Convert network number for interface type AF from presentation in
+   buffer starting at CP to network format and store result int
+   buffer starting at BUF of size LEN.  */
+extern int inet_net_pton (int __af, __const char *__cp,
+			  void *__buf, size_t __len) __THROW;
+
+/* Convert ASCII representation in hexadecimal form of the Internet
+   address to binary form and place result in buffer of length LEN
+   starting at BUF.  */
+extern unsigned int inet_nsap_addr (__const char *__cp,
+				    unsigned char *__buf, int __len) __THROW;
+
+/* Convert internet address in binary form in LEN bytes starting at CP
+   a presentation form and place result in BUF.  */
+extern char *inet_nsap_ntoa (int __len, __const unsigned char *__cp,
+			     char *__buf) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* arpa/inet.h */
diff -pruwN busybox-1.01/include2/asm/byteorder.h busybox-1.01-livebox/include2/asm/byteorder.h
--- busybox-1.01/include2/asm/byteorder.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/byteorder.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,30 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1996, 99, 2003 by Ralf Baechle
+ */
+#ifndef _ASM_BYTEORDER_H
+#define _ASM_BYTEORDER_H
+
+#include <asm/types.h>
+
+#ifdef __GNUC__
+
+#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#endif /* __GNUC__ */
+
+#if defined (__MIPSEB__)
+#  include <linux/byteorder/big_endian.h>
+#elif defined (__MIPSEL__)
+#  include <linux/byteorder/little_endian.h>
+#else
+#  error "MIPS, but neither __MIPSEB__, nor __MIPSEL__???"
+#endif
+
+#endif /* _ASM_BYTEORDER_H */
diff -pruwN busybox-1.01/include2/asm/ioctl.h busybox-1.01-livebox/include2/asm/ioctl.h
--- busybox-1.01/include2/asm/ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/ioctl.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,99 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 96, 99, 2001 Ralf Baechle
+ */
+#ifndef _ASM_IOCTL_H
+#define _ASM_IOCTL_H
+
+/*
+ * The original linux ioctl numbering scheme was just a general
+ * "anything goes" setup, where more or less random numbers were
+ * assigned.  Sorry, I was clueless when I started out on this.
+ *
+ * On the alpha, we'll try to clean it up a bit, using a more sane
+ * ioctl numbering, and also trying to be compatible with OSF/1 in
+ * the process. I'd like to clean it up for the i386 as well, but
+ * it's so painful recognizing both the new and the old numbers..
+ *
+ * The same applies for for the MIPS ABI; in fact even the macros
+ * from Linux/Alpha fit almost perfectly.
+ */
+
+#define _IOC_NRBITS	8
+#define _IOC_TYPEBITS	8
+#define _IOC_SIZEBITS	13
+#define _IOC_DIRBITS	3
+
+#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT	0
+#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+/*
+ * We to additionally limit parameters to a maximum 255 bytes.
+ */
+#define _IOC_SLMASK	0xff
+
+/*
+ * Direction bits _IOC_NONE could be 0, but OSF/1 gives it a bit.
+ * And this turns out useful to catch old ioctl numbers in header
+ * files for us.
+ */
+#define _IOC_NONE	1U
+#define _IOC_READ	2U
+#define _IOC_WRITE	4U
+
+/*
+ * The following are included for compatibility
+ */
+#define _IOC_VOID	0x20000000
+#define _IOC_OUT	0x40000000
+#define _IOC_IN		0x80000000
+#define _IOC_INOUT	(IOC_IN|IOC_OUT)
+
+#define _IOC(dir,type,nr,size) \
+	(((dir)  << _IOC_DIRSHIFT) | \
+	 ((type) << _IOC_TYPESHIFT) | \
+	 ((nr)   << _IOC_NRSHIFT) | \
+	 ((size) << _IOC_SIZESHIFT))
+
+/* provoke compile error for invalid uses of size argument */
+extern unsigned int __invalid_size_argument_for_IOC;
+#define _IOC_TYPECHECK(t) \
+	((sizeof(t) == sizeof(t[1]) && \
+	  sizeof(t) < (1 << _IOC_SIZEBITS)) ? \
+	  sizeof(t) : __invalid_size_argument_for_IOC)
+
+/* used to create numbers */
+#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+
+
+/* used to decode them.. */
+#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
+#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
+#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
+#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files... */
+
+#define IOC_IN		(_IOC_WRITE << _IOC_DIRSHIFT)
+#define IOC_OUT		(_IOC_READ << _IOC_DIRSHIFT)
+#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
+#define IOCSIZE_MASK	(_IOC_SIZEMASK << _IOC_SIZESHIFT)
+#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
+
+#endif /* _ASM_IOCTL_H */
diff -pruwN busybox-1.01/include2/asm/ioctls.h busybox-1.01-livebox/include2/asm/ioctls.h
--- busybox-1.01/include2/asm/ioctls.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/ioctls.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,105 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 1996, 2001 Ralf Baechle
+ * Copyright (C) 2001 MIPS Technologies, Inc.
+ */
+#ifndef __ASM_IOCTLS_H
+#define __ASM_IOCTLS_H
+
+#include <asm/ioctl.h>
+
+#define TCGETA		0x5401
+#define TCSETA		0x5402	/* Clashes with SNDCTL_TMR_START sound ioctl */
+#define TCSETAW		0x5403
+#define TCSETAF		0x5404
+
+#define TCSBRK		0x5405
+#define TCXONC		0x5406
+#define TCFLSH		0x5407
+
+#define TCGETS		0x540d
+#define TCSETS		0x540e
+#define TCSETSW		0x540f
+#define TCSETSF		0x5410
+
+#define TIOCEXCL	0x740d		/* set exclusive use of tty */
+#define TIOCNXCL	0x740e		/* reset exclusive use of tty */
+#define TIOCOUTQ	0x7472		/* output queue size */
+#define TIOCSTI		0x5472		/* simulate terminal input */
+#define TIOCMGET	0x741d		/* get all modem bits */
+#define TIOCMBIS	0x741b		/* bis modem bits */
+#define TIOCMBIC	0x741c		/* bic modem bits */
+#define TIOCMSET	0x741a		/* set all modem bits */
+#define TIOCPKT		0x5470		/* pty: set/clear packet mode */
+#define	 TIOCPKT_DATA		0x00	/* data packet */
+#define	 TIOCPKT_FLUSHREAD	0x01	/* flush packet */
+#define	 TIOCPKT_FLUSHWRITE	0x02	/* flush packet */
+#define	 TIOCPKT_STOP		0x04	/* stop output */
+#define	 TIOCPKT_START		0x08	/* start output */
+#define	 TIOCPKT_NOSTOP		0x10	/* no more ^S, ^Q */
+#define	 TIOCPKT_DOSTOP		0x20	/* now do ^S ^Q */
+/* #define  TIOCPKT_IOCTL		0x40	state change of pty driver */
+#define TIOCSWINSZ	_IOW('t', 103, struct winsize)	/* set window size */
+#define TIOCGWINSZ	_IOR('t', 104, struct winsize)	/* get window size */
+#define TIOCNOTTY	0x5471		/* void tty association */
+#define TIOCSETD	0x7401
+#define TIOCGETD	0x7400
+
+#define FIOCLEX		0x6601
+#define FIONCLEX	0x6602
+#define FIOASYNC	0x667d
+#define FIONBIO		0x667e
+#define FIOQSIZE	0x667f
+
+#define TIOCGLTC	0x7474			/* get special local chars */
+#define TIOCSLTC	0x7475			/* set special local chars */
+#define TIOCSPGRP	_IOW('t', 118, int)	/* set pgrp of tty */
+#define TIOCGPGRP	_IOR('t', 119, int)	/* get pgrp of tty */
+#define TIOCCONS	_IOW('t', 120, int)	/* become virtual console */
+
+#define FIONREAD	0x467f
+#define TIOCINQ		FIONREAD
+
+#define TIOCGETP        0x7408
+#define TIOCSETP        0x7409
+#define TIOCSETN        0x740a			/* TIOCSETP wo flush */
+
+/* #define TIOCSETA	_IOW('t', 20, struct termios) set termios struct */
+/* #define TIOCSETAW	_IOW('t', 21, struct termios) drain output, set */
+/* #define TIOCSETAF	_IOW('t', 22, struct termios) drn out, fls in, set */
+/* #define TIOCGETD	_IOR('t', 26, int)	get line discipline */
+/* #define TIOCSETD	_IOW('t', 27, int)	set line discipline */
+						/* 127-124 compat */
+
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x7416  /* Return the session ID of FD */
+#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
+
+/* I hope the range from 0x5480 on is free ... */
+#define TIOCSCTTY	0x5480		/* become controlling tty */
+#define TIOCGSOFTCAR	0x5481
+#define TIOCSSOFTCAR	0x5482
+#define TIOCLINUX	0x5483
+#define TIOCGSERIAL	0x5484
+#define TIOCSSERIAL	0x5485
+#define TCSBRKP		0x5486	/* Needed for POSIX tcsendbreak() */
+#define TIOCSERCONFIG	0x5488
+#define TIOCSERGWILD	0x5489
+#define TIOCSERSWILD	0x548a
+#define TIOCGLCKTRMIOS	0x548b
+#define TIOCSLCKTRMIOS	0x548c
+#define TIOCSERGSTRUCT	0x548d /* For debugging only */
+#define TIOCSERGETLSR   0x548e /* Get line status register */
+#define TIOCSERGETMULTI 0x548f /* Get multiport config  */
+#define TIOCSERSETMULTI 0x5490 /* Set multiport config */
+#define TIOCMIWAIT      0x5491 /* wait for a change on serial input line(s) */
+#define TIOCGICOUNT     0x5492 /* read serial port inline interrupt counts */
+#define TIOCGHAYESESP	0x5493 /* Get Hayes ESP configuration */
+#define TIOCSHAYESESP	0x5494 /* Set Hayes ESP configuration */
+
+#endif /* __ASM_IOCTLS_H */
diff -pruwN busybox-1.01/include2/asm/page.h busybox-1.01-livebox/include2/asm/page.h
--- busybox-1.01/include2/asm/page.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/page.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,165 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1994 - 1999, 2000, 03 Ralf Baechle
+ * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_PAGE_H
+#define _ASM_PAGE_H
+
+#include <linux/config.h>
+
+#ifdef __KERNEL__
+
+#include <spaces.h>
+
+#endif
+
+/*
+ * PAGE_SHIFT determines the page size
+ */
+#ifdef CONFIG_PAGE_SIZE_4KB
+#define PAGE_SHIFT	12
+#endif
+#ifdef CONFIG_PAGE_SIZE_8KB
+#define PAGE_SHIFT	13
+#endif
+#ifdef CONFIG_PAGE_SIZE_16KB
+#define PAGE_SHIFT	14
+#endif
+#ifdef CONFIG_PAGE_SIZE_64KB
+#define PAGE_SHIFT	16
+#endif
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_MASK       (~((1 << PAGE_SHIFT) - 1))
+
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+
+extern void clear_page(void * page);
+extern void copy_page(void * to, void * from);
+
+extern unsigned long shm_align_mask;
+
+static inline unsigned long pages_do_alias(unsigned long addr1,
+	unsigned long addr2)
+{
+	return (addr1 ^ addr2) & shm_align_mask;
+}
+
+struct page;
+
+static inline void clear_user_page(void *addr, unsigned long vaddr,
+	struct page *page)
+{
+	extern void (*flush_data_cache_page)(unsigned long addr);
+
+	clear_page(addr);
+	if (pages_do_alias((unsigned long) addr, vaddr))
+		flush_data_cache_page((unsigned long)addr);
+}
+
+static inline void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,
+	struct page *to)
+{
+	extern void (*flush_data_cache_page)(unsigned long addr);
+
+	copy_page(vto, vfrom);
+	if (pages_do_alias((unsigned long)vto, vaddr))
+		flush_data_cache_page((unsigned long)vto);
+}
+
+/*
+ * These are used to make use of C type-checking..
+ */
+#ifdef CONFIG_64BIT_PHYS_ADDR
+  #ifdef CONFIG_CPU_MIPS32
+    typedef struct { unsigned long pte_low, pte_high; } pte_t;
+    #define pte_val(x)    ((x).pte_low | ((unsigned long long)(x).pte_high << 32))
+  #else
+     typedef struct { unsigned long long pte; } pte_t;
+     #define pte_val(x)	((x).pte)
+  #endif
+#else
+typedef struct { unsigned long pte; } pte_t;
+#define pte_val(x)	((x).pte)
+#endif
+#define __pte(x)	((pte_t) { (x) } )
+
+/*
+ * For 3-level pagetables we defines these ourselves, for 2-level the
+ * definitions are supplied by <asm-generic/pgtable-nopmd.h>.
+ */
+#ifdef CONFIG_64BIT
+
+typedef struct { unsigned long pmd; } pmd_t;
+#define pmd_val(x)	((x).pmd)
+#define __pmd(x)	((pmd_t) { (x) } )
+
+#endif
+
+/*
+ * Right now we don't support 4-level pagetables, so all pud-related
+ * definitions come from <asm-generic/pgtable-nopud.h>.
+ */
+
+/*
+ * Finall the top of the hierarchy, the pgd
+ */
+typedef struct { unsigned long pgd; } pgd_t;
+#define pgd_val(x)	((x).pgd)
+#define __pgd(x)	((pgd_t) { (x) } )
+
+/*
+ * Manipulate page protection bits
+ */
+typedef struct { unsigned long pgprot; } pgprot_t;
+#define pgprot_val(x)	((x).pgprot)
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+/*
+ * On R4000-style MMUs where a TLB entry is mapping a adjacent even / odd
+ * pair of pages we only have a single global bit per pair of pages.  When
+ * writing to the TLB make sure we always have the bit set for both pages
+ * or none.  This macro is used to access the `buddy' of the pte we're just
+ * working on.
+ */
+#define ptep_buddy(x)	((pte_t *)((unsigned long)(x) ^ sizeof(pte_t)))
+
+#endif /* !__ASSEMBLY__ */
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr) + PAGE_SIZE - 1) & PAGE_MASK)
+
+#define __pa(x)			((unsigned long) (x) - PAGE_OFFSET)
+#define __va(x)			((void *)((unsigned long) (x) + PAGE_OFFSET))
+
+#define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
+
+#ifndef CONFIG_NEED_MULTIPLE_NODES
+#define pfn_to_page(pfn)	(mem_map + (pfn))
+#define page_to_pfn(page)	((unsigned long)((page) - mem_map))
+#define pfn_valid(pfn)		((pfn) < max_mapnr)
+#endif
+
+#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
+#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
+
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
+#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
+
+#endif /* defined (__KERNEL__) */
+
+#ifdef CONFIG_LIMITED_DMA
+#define WANT_PAGE_VIRTUAL
+#endif
+
+#include <asm-generic/page.h>
+
+#endif /* _ASM_PAGE_H */
diff -pruwN busybox-1.01/include2/asm/param.h busybox-1.01-livebox/include2/asm/param.h
--- busybox-1.01/include2/asm/param.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/param.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright 1994 - 2000, 2002 Ralf Baechle (ralf@gnu.org)
+ * Copyright 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_PARAM_H
+#define _ASM_PARAM_H
+
+#ifdef __KERNEL__
+
+# include <param.h>			/* Internal kernel timer frequency */
+# define USER_HZ	100		/* .. some user interfaces are in "ticks" */
+# define CLOCKS_PER_SEC	(USER_HZ)	/* like times() */
+#endif
+
+#ifndef HZ
+#define HZ 100
+#endif
+
+#define EXEC_PAGESIZE	65536
+
+#ifndef NOGROUP
+#define NOGROUP		(-1)
+#endif
+
+#define MAXHOSTNAMELEN	64	/* max length of hostname */
+
+#endif /* _ASM_PARAM_H */
diff -pruwN busybox-1.01/include2/asm/posix_types.h busybox-1.01-livebox/include2/asm/posix_types.h
--- busybox-1.01/include2/asm/posix_types.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/posix_types.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,144 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1996, 97, 98, 99, 2000 by Ralf Baechle
+ * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_POSIX_TYPES_H
+#define _ASM_POSIX_TYPES_H
+
+#include <asm/sgidefs.h>
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned int	__kernel_mode_t;
+#if (_MIPS_SZLONG == 32)
+typedef unsigned long	__kernel_nlink_t;
+#endif
+#if (_MIPS_SZLONG == 64)
+typedef unsigned int	__kernel_nlink_t;
+#endif
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef int		__kernel_ipc_pid_t;
+typedef unsigned int	__kernel_uid_t;
+typedef unsigned int	__kernel_gid_t;
+#if (_MIPS_SZLONG == 32)
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+#endif
+#if (_MIPS_SZLONG == 64)
+typedef unsigned long	__kernel_size_t;
+typedef long		__kernel_ssize_t;
+typedef long		__kernel_ptrdiff_t;
+#endif
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef long		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+typedef __kernel_uid_t	__kernel_old_uid_t;
+typedef __kernel_gid_t	__kernel_old_gid_t;
+typedef unsigned int	__kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long      __kernel_loff_t;
+#endif
+
+typedef struct {
+#if (_MIPS_SZLONG == 32)
+	long	val[2];
+#endif
+#if (_MIPS_SZLONG == 64)
+	int	val[2];
+#endif
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#undef __FD_SET
+static __inline__ void __FD_SET(unsigned long __fd, __kernel_fd_set *__fdsetp)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
+}
+
+#undef __FD_CLR
+static __inline__ void __FD_CLR(unsigned long __fd, __kernel_fd_set *__fdsetp)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
+}
+
+#undef __FD_ISSET
+static __inline__ int __FD_ISSET(unsigned long __fd, const __kernel_fd_set *__p)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
+}
+
+/*
+ * This will unroll the loop for the normal constant case (8 ints,
+ * for a 256-bit fd_set)
+ */
+#undef __FD_ZERO
+static __inline__ void __FD_ZERO(__kernel_fd_set *__p)
+{
+	unsigned long *__tmp = __p->fds_bits;
+	int __i;
+
+	if (__builtin_constant_p(__FDSET_LONGS)) {
+		switch (__FDSET_LONGS) {
+		case 16:
+			__tmp[ 0] = 0; __tmp[ 1] = 0;
+			__tmp[ 2] = 0; __tmp[ 3] = 0;
+			__tmp[ 4] = 0; __tmp[ 5] = 0;
+			__tmp[ 6] = 0; __tmp[ 7] = 0;
+			__tmp[ 8] = 0; __tmp[ 9] = 0;
+			__tmp[10] = 0; __tmp[11] = 0;
+			__tmp[12] = 0; __tmp[13] = 0;
+			__tmp[14] = 0; __tmp[15] = 0;
+			return;
+
+		case 8:
+			__tmp[ 0] = 0; __tmp[ 1] = 0;
+			__tmp[ 2] = 0; __tmp[ 3] = 0;
+			__tmp[ 4] = 0; __tmp[ 5] = 0;
+			__tmp[ 6] = 0; __tmp[ 7] = 0;
+			return;
+
+		case 4:
+			__tmp[ 0] = 0; __tmp[ 1] = 0;
+			__tmp[ 2] = 0; __tmp[ 3] = 0;
+			return;
+		}
+	}
+	__i = __FDSET_LONGS;
+	while (__i) {
+		__i--;
+		*__tmp = 0;
+		__tmp++;
+	}
+}
+
+#endif /* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) */
+
+#endif /* _ASM_POSIX_TYPES_H */
diff -pruwN busybox-1.01/include2/asm/sgidefs.h busybox-1.01-livebox/include2/asm/sgidefs.h
--- busybox-1.01/include2/asm/sgidefs.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/sgidefs.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,44 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1996, 1999, 2001 Ralf Baechle
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ * Copyright (C) 2001 MIPS Technologies, Inc.
+ */
+#ifndef __ASM_SGIDEFS_H
+#define __ASM_SGIDEFS_H
+
+/*
+ * Using a Linux compiler for building Linux seems logic but not to
+ * everybody.
+ */
+#ifndef __linux__
+#error Use a Linux compiler or give up.
+#endif
+
+/*
+ * Definitions for the ISA levels
+ *
+ * With the introduction of MIPS32 / MIPS64 instruction sets definitions
+ * MIPS ISAs are no longer subsets of each other.  Therefore comparisons
+ * on these symbols except with == may result in unexpected results and
+ * are forbidden!
+ */
+#define _MIPS_ISA_MIPS1		1
+#define _MIPS_ISA_MIPS2		2
+#define _MIPS_ISA_MIPS3		3
+#define _MIPS_ISA_MIPS4		4
+#define _MIPS_ISA_MIPS5		5
+#define _MIPS_ISA_MIPS32	6
+#define _MIPS_ISA_MIPS64	7
+
+/*
+ * Subprogram calling convention
+ */
+#define _MIPS_SIM_ABI32		1
+#define _MIPS_SIM_NABI32	2
+#define _MIPS_SIM_ABI64		3
+
+#endif /* __ASM_SGIDEFS_H */
diff -pruwN busybox-1.01/include2/asm/sigcontext.h busybox-1.01-livebox/include2/asm/sigcontext.h
--- busybox-1.01/include2/asm/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/sigcontext.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,95 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1996, 1997, 1999 by Ralf Baechle
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_SIGCONTEXT_H
+#define _ASM_SIGCONTEXT_H
+
+#include <asm/sgidefs.h>
+
+#if _MIPS_SIM == _MIPS_SIM_ABI32
+
+/*
+ * Keep this struct definition in sync with the sigcontext fragment
+ * in arch/mips/tools/offset.c
+ */
+struct sigcontext {
+	unsigned int		sc_regmask;	/* Unused */
+	unsigned int		sc_status;
+	unsigned long long	sc_pc;
+	unsigned long long	sc_regs[32];
+	unsigned long long	sc_fpregs[32];
+	unsigned int		sc_ownedfp;	/* Unused */
+	unsigned int		sc_fpc_csr;
+	unsigned int		sc_fpc_eir;	/* Unused */
+	unsigned int		sc_used_math;
+	unsigned int		sc_dsp;		/* dsp status, was sc_ssflags */
+	unsigned long long	sc_mdhi;
+	unsigned long long	sc_mdlo;
+	unsigned long		sc_hi1;		/* Was sc_cause */
+	unsigned long		sc_lo1;		/* Was sc_badvaddr */
+	unsigned long		sc_hi2;		/* Was sc_sigset[4] */
+	unsigned long		sc_lo2;
+	unsigned long		sc_hi3;
+	unsigned long		sc_lo3;
+};
+
+#endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
+
+#if _MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32
+
+/*
+ * Keep this struct definition in sync with the sigcontext fragment
+ * in arch/mips/tools/offset.c
+ *
+ * Warning: this structure illdefined with sc_badvaddr being just an unsigned
+ * int so it was changed to unsigned long in 2.6.0-test1.  This may break
+ * binary compatibility - no prisoners.
+ * DSP ASE in 2.6.12-rc4.  Turn sc_mdhi and sc_mdlo into an array of four
+ * entries, add sc_dsp and sc_reserved for padding.  No prisoners.
+ */
+struct sigcontext {
+	unsigned long	sc_regs[32];
+	unsigned long	sc_fpregs[32];
+	unsigned long	sc_hi[4];
+	unsigned long	sc_lo[4];
+	unsigned long	sc_pc;
+	unsigned int	sc_fpc_csr;
+	unsigned int	sc_used_math;
+	unsigned int	sc_dsp;
+	unsigned int	sc_reserved;
+};
+
+#ifdef __KERNEL__
+
+#include <linux/posix_types.h>
+
+struct sigcontext32 {
+	__u32		sc_regmask;	/* Unused */
+	__u32		sc_status;
+	__u64		sc_pc;
+	__u64		sc_regs[32];
+	__u64		sc_fpregs[32];
+	__u32		sc_ownedfp;	/* Unused */
+	__u32		sc_fpc_csr;
+	__u32		sc_fpc_eir;	/* Unused */
+	__u32		sc_used_math;
+	__u32		sc_dsp;		/* dsp status, was sc_ssflags */
+	__u64		sc_mdhi;
+	__u64		sc_mdlo;
+	__u32		sc_hi1;		/* Was sc_cause */
+	__u32		sc_lo1;		/* Was sc_badvaddr */
+	__u32		sc_hi2;		/* Was sc_sigset[4] */
+	__u32		sc_lo2;
+	__u32		sc_hi3;
+	__u32		sc_lo3;
+};
+#endif /* __KERNEL__ */
+
+#endif /* _MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32 */
+
+#endif /* _ASM_SIGCONTEXT_H */
diff -pruwN busybox-1.01/include2/asm/socket.h busybox-1.01-livebox/include2/asm/socket.h
--- busybox-1.01/include2/asm/socket.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/socket.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,105 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1997, 1999, 2000, 2001 Ralf Baechle
+ * Copyright (C) 2000, 2001 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_SOCKET_H
+#define _ASM_SOCKET_H
+
+#include <asm/sockios.h>
+
+/*
+ * For setsockopt(2)
+ *
+ * This defines are ABI conformant as far as Linux supports these ...
+ */
+#define SOL_SOCKET	0xffff
+
+#define SO_DEBUG	0x0001	/* Record debugging information.  */
+#define SO_REUSEADDR	0x0004	/* Allow reuse of local addresses.  */
+#define SO_KEEPALIVE	0x0008	/* Keep connections alive and send
+				   SIGPIPE when they die.  */
+#define SO_DONTROUTE	0x0010	/* Don't do local routing.  */
+#define SO_BROADCAST	0x0020	/* Allow transmission of
+				   broadcast messages.  */
+#define SO_LINGER	0x0080	/* Block on close of a reliable
+				   socket to transmit pending data.  */
+#define SO_OOBINLINE 0x0100	/* Receive out-of-band data in-band.  */
+#if 0
+To add: #define SO_REUSEPORT 0x0200	/* Allow local address and port reuse.  */
+#endif
+
+#define SO_TYPE		0x1008	/* Compatible name for SO_STYLE.  */
+#define SO_STYLE	SO_TYPE	/* Synonym */
+#define SO_ERROR	0x1007	/* get error status and clear */
+#define SO_SNDBUF	0x1001	/* Send buffer size. */
+#define SO_RCVBUF	0x1002	/* Receive buffer. */
+#define SO_SNDLOWAT	0x1003	/* send low-water mark */
+#define SO_RCVLOWAT	0x1004	/* receive low-water mark */
+#define SO_SNDTIMEO	0x1005	/* send timeout */
+#define SO_RCVTIMEO 	0x1006	/* receive timeout */
+#define SO_ACCEPTCONN	0x1009
+
+/* linux-specific, might as well be the same as on i386 */
+#define SO_NO_CHECK	11
+#define SO_PRIORITY	12
+#define SO_BSDCOMPAT	14
+
+#define SO_PASSCRED	17
+#define SO_PEERCRED	18
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
+#define SO_SECURITY_ENCRYPTION_NETWORK		24
+
+#define SO_BINDTODEVICE		25
+
+/* Socket filtering */
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+
+#define SO_PEERNAME             28
+#define SO_TIMESTAMP		29
+#define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_PEERSEC		30
+#define SO_SNDBUFFORCE		31
+#define SO_RCVBUFFORCE		33
+
+#ifdef __KERNEL__
+
+/** sock_type - Socket types
+ *
+ * Please notice that for binary compat reasons MIPS has to
+ * override the enum sock_type in include/linux/net.h, so
+ * we define ARCH_HAS_SOCKET_TYPES here.
+ *
+ * @SOCK_DGRAM - datagram (conn.less) socket
+ * @SOCK_STREAM - stream (connection) socket
+ * @SOCK_RAW - raw socket
+ * @SOCK_RDM - reliably-delivered message
+ * @SOCK_SEQPACKET - sequential packet socket
+ * @SOCK_PACKET - linux specific way of getting packets at the dev level.
+ *		  For writing rarp and other similar things on the user level.
+ */
+enum sock_type {
+	SOCK_DGRAM	= 1,
+	SOCK_STREAM	= 2,
+	SOCK_RAW	= 3,
+	SOCK_RDM	= 4,
+	SOCK_SEQPACKET	= 5,
+	SOCK_DCCP	= 6,
+	SOCK_PACKET	= 10,
+};
+
+#define SOCK_MAX (SOCK_PACKET + 1)
+
+#define ARCH_HAS_SOCKET_TYPES 1
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_SOCKET_H */
diff -pruwN busybox-1.01/include2/asm/sockios.h busybox-1.01-livebox/include2/asm/sockios.h
--- busybox-1.01/include2/asm/sockios.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/sockios.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+ * Socket-level I/O control calls.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995 by Ralf Baechle
+ */
+#ifndef _ASM_SOCKIOS_H
+#define _ASM_SOCKIOS_H
+
+#include <asm/ioctl.h>
+
+/* Socket-level I/O control calls. */
+#define FIOGETOWN	_IOR('f', 123, int)
+#define FIOSETOWN 	_IOW('f', 124, int)
+
+#define SIOCATMARK	_IOR('s', 7, int)
+#define SIOCSPGRP	_IOW('s', 8, pid_t)
+#define SIOCGPGRP	_IOR('s', 9, pid_t)
+
+#define SIOCGSTAMP	0x8906			/* Get stamp - linux-specific */
+
+#endif /* _ASM_SOCKIOS_H */
diff -pruwN busybox-1.01/include2/asm/types.h busybox-1.01-livebox/include2/asm/types.h
--- busybox-1.01/include2/asm/types.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm/types.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,106 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1994, 1995, 1996, 1999 by Ralf Baechle
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_TYPES_H
+#define _ASM_TYPES_H
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#if (_MIPS_SZLONG == 64)
+
+typedef __signed__ long __s64;
+typedef unsigned long __u64;
+
+#else
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+#define BITS_PER_LONG _MIPS_SZLONG
+
+#ifndef __ASSEMBLY__
+
+#include <linux/config.h>
+
+typedef __signed char s8;
+typedef unsigned char u8;
+
+typedef __signed short s16;
+typedef unsigned short u16;
+
+typedef __signed int s32;
+typedef unsigned int u32;
+
+#if (_MIPS_SZLONG == 64)
+
+typedef __signed__ long s64;
+typedef unsigned long u64;
+
+#else
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long s64;
+typedef unsigned long long u64;
+#endif
+
+#endif
+
+#if (defined(CONFIG_HIGHMEM) && defined(CONFIG_64BIT_PHYS_ADDR)) \
+    || defined(CONFIG_64BIT)
+typedef u64 dma_addr_t;
+#else
+typedef u32 dma_addr_t;
+#endif
+typedef u64 dma64_addr_t;
+
+/*
+ * Don't use phys_t.  You've been warned.
+ */
+#ifdef CONFIG_64BIT_PHYS_ADDR
+typedef unsigned long long phys_t;
+#else
+typedef unsigned long phys_t;
+#endif
+
+#ifdef CONFIG_LBD
+typedef u64 sector_t;
+#define HAVE_SECTOR_T
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_TYPES_H */
diff -pruwN busybox-1.01/include2/asm-generic/page.h busybox-1.01-livebox/include2/asm-generic/page.h
--- busybox-1.01/include2/asm-generic/page.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/asm-generic/page.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,26 @@
+#ifndef _ASM_GENERIC_PAGE_H
+#define _ASM_GENERIC_PAGE_H
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+
+#include <linux/compiler.h>
+
+/* Pure 2^n version of get_order */
+static __inline__ __attribute_const__ int get_order(unsigned long size)
+{
+	int order;
+
+	size = (size - 1) >> (PAGE_SHIFT - 1);
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+	return order;
+}
+
+#endif	/* __ASSEMBLY__ */
+#endif	/* __KERNEL__ */
+
+#endif	/* _ASM_GENERIC_PAGE_H */
diff -pruwN busybox-1.01/include2/assert.h busybox-1.01-livebox/include2/assert.h
--- busybox-1.01/include2/assert.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/assert.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,70 @@
+/* Copyright (C) 1991,1992,1994-1999,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
+ */
+
+#ifndef	__ASSERT_H
+#define	__ASSERT_H
+#include <features.h>
+
+/* If NDEBUG is defined, do nothing.
+   If not, and EXPRESSION is zero, print an error message and abort.  */
+
+#ifdef	NDEBUG
+
+#define	assert(expr)		((void) 0)
+
+#else /* Not NDEBUG.  */
+
+__BEGIN_DECLS
+extern void __assert __P((const char *, const char *, int, const char *));
+__END_DECLS
+
+#define	assert(expr)							      \
+  ((void) ((expr) ||							      \
+	   (__assert (__STRING(expr),				      \
+			   __FILE__, __LINE__, __ASSERT_FUNCTION), 0)))
+
+  
+/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
+   which contains the name of the function currently being defined.
+#  define __ASSERT_FUNCTION	__PRETTY_FUNCTION__
+   This is broken in G++ before version 2.6.
+   C9x has a similar variable called __func__, but prefer the GCC one since
+   it demangles C++ function names.  */
+# ifdef __GNUC__
+#  if __GNUC__ > 2 || (__GNUC__ == 2 \
+		       && __GNUC_MINOR__ >= (defined __cplusplus ? 6 : 4))
+#   define __ASSERT_FUNCTION	__PRETTY_FUNCTION__
+#  else
+#   define __ASSERT_FUNCTION	((__const char *) 0)
+#  endif
+# else
+#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#   define __ASSERT_FUNCTION	__func__
+#  else
+#   define __ASSERT_FUNCTION	((__const char *) 0)
+#  endif
+# endif
+
+
+#endif /* NDEBUG.  */
+
+#endif /* __ASSERT_H */
diff -pruwN busybox-1.01/include2/bits/byteswap.h busybox-1.01-livebox/include2/bits/byteswap.h
--- busybox-1.01/include2/bits/byteswap.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/byteswap.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,84 @@
+/* Macros to swap the order of bytes in integer values.
+   Copyright (C) 1997, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _BYTESWAP_H && !defined _NETINET_IN_H
+# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
+#endif
+
+#ifndef _BITS_BYTESWAP_H
+#define _BITS_BYTESWAP_H 1
+
+/* Swap bytes in 16 bit value.  */
+#ifdef __GNUC__
+# define __bswap_16(x) \
+    (__extension__							      \
+     ({ unsigned short int __bsx = (x);					      \
+        ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)); }))
+#else
+static __inline unsigned short int
+__bswap_16 (unsigned short int __bsx)
+{
+  return ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8));
+}
+#endif
+
+/* Swap bytes in 32 bit value.  */
+#ifdef __GNUC__
+# define __bswap_32(x) \
+    (__extension__							      \
+     ({ unsigned int __bsx = (x);					      \
+        ((((__bsx) & 0xff000000) >> 24) | (((__bsx) & 0x00ff0000) >>  8) |    \
+	 (((__bsx) & 0x0000ff00) <<  8) | (((__bsx) & 0x000000ff) << 24)); }))
+#else
+static __inline unsigned int
+__bswap_32 (unsigned int __bsx)
+{
+  return ((((__bsx) & 0xff000000) >> 24) | (((__bsx) & 0x00ff0000) >>  8) |
+	  (((__bsx) & 0x0000ff00) <<  8) | (((__bsx) & 0x000000ff) << 24));
+}
+#endif
+
+#if defined __GNUC__ && __GNUC__ >= 2
+/* Swap bytes in 64 bit value.  */
+# define __bswap_constant_64(x) \
+     ((((x) & 0xff00000000000000ull) >> 56)				      \
+      | (((x) & 0x00ff000000000000ull) >> 40)				      \
+      | (((x) & 0x0000ff0000000000ull) >> 24)				      \
+      | (((x) & 0x000000ff00000000ull) >> 8)				      \
+      | (((x) & 0x00000000ff000000ull) << 8)				      \
+      | (((x) & 0x0000000000ff0000ull) << 24)				      \
+      | (((x) & 0x000000000000ff00ull) << 40)				      \
+      | (((x) & 0x00000000000000ffull) << 56))
+
+# define __bswap_64(x) \
+     (__extension__							      \
+      ({ union { __extension__ unsigned long long int __ll;		      \
+		 unsigned int __l[2]; } __w, __r;			      \
+         if (__builtin_constant_p (x))					      \
+	   __r.__ll = __bswap_constant_64 (x);				      \
+	 else								      \
+	   {								      \
+	     __w.__ll = (x);						      \
+	     __r.__l[0] = __bswap_32 (__w.__l[1]);			      \
+	     __r.__l[1] = __bswap_32 (__w.__l[0]);			      \
+	   }								      \
+	 __r.__ll; }))
+#endif
+
+#endif /* _BITS_BYTESWAP_H */
diff -pruwN busybox-1.01/include2/bits/confname.h busybox-1.01-livebox/include2/bits/confname.h
--- busybox-1.01/include2/bits/confname.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/confname.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,566 @@
+/* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
+   Copyright (C) 1993, 1995-1998, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UNISTD_H
+# error "Never use <bits/confname.h> directly; include <unistd.h> instead."
+#endif
+
+/* Values for the NAME argument to `pathconf' and `fpathconf'.  */
+enum
+  {
+    _PC_LINK_MAX,
+#define	_PC_LINK_MAX			_PC_LINK_MAX
+    _PC_MAX_CANON,
+#define	_PC_MAX_CANON			_PC_MAX_CANON
+    _PC_MAX_INPUT,
+#define	_PC_MAX_INPUT			_PC_MAX_INPUT
+    _PC_NAME_MAX,
+#define	_PC_NAME_MAX			_PC_NAME_MAX
+    _PC_PATH_MAX,
+#define	_PC_PATH_MAX			_PC_PATH_MAX
+    _PC_PIPE_BUF,
+#define	_PC_PIPE_BUF			_PC_PIPE_BUF
+    _PC_CHOWN_RESTRICTED,
+#define	_PC_CHOWN_RESTRICTED		_PC_CHOWN_RESTRICTED
+    _PC_NO_TRUNC,
+#define	_PC_NO_TRUNC			_PC_NO_TRUNC
+    _PC_VDISABLE,
+#define _PC_VDISABLE			_PC_VDISABLE
+    _PC_SYNC_IO,
+#define	_PC_SYNC_IO			_PC_SYNC_IO
+    _PC_ASYNC_IO,
+#define	_PC_ASYNC_IO			_PC_ASYNC_IO
+    _PC_PRIO_IO,
+#define	_PC_PRIO_IO			_PC_PRIO_IO
+    _PC_SOCK_MAXBUF,
+#define	_PC_SOCK_MAXBUF			_PC_SOCK_MAXBUF
+    _PC_FILESIZEBITS,
+#define _PC_FILESIZEBITS		_PC_FILESIZEBITS
+    _PC_REC_INCR_XFER_SIZE,
+#define _PC_REC_INCR_XFER_SIZE		_PC_REC_INCR_XFER_SIZE
+    _PC_REC_MAX_XFER_SIZE,
+#define _PC_REC_MAX_XFER_SIZE		_PC_REC_MAX_XFER_SIZE
+    _PC_REC_MIN_XFER_SIZE,
+#define _PC_REC_MIN_XFER_SIZE		_PC_REC_MIN_XFER_SIZE
+    _PC_REC_XFER_ALIGN,
+#define _PC_REC_XFER_ALIGN		_PC_REC_XFER_ALIGN
+    _PC_ALLOC_SIZE_MIN,
+#define _PC_ALLOC_SIZE_MIN		_PC_ALLOC_SIZE_MIN
+    _PC_SYMLINK_MAX
+#define _PC_SYMLINK_MAX			_PC_SYMLINK_MAX
+  };
+
+/* Values for the argument to `sysconf'.  */
+enum
+  {
+    _SC_ARG_MAX,
+#define	_SC_ARG_MAX			_SC_ARG_MAX
+    _SC_CHILD_MAX,
+#define	_SC_CHILD_MAX			_SC_CHILD_MAX
+    _SC_CLK_TCK,
+#define	_SC_CLK_TCK			_SC_CLK_TCK
+    _SC_NGROUPS_MAX,
+#define	_SC_NGROUPS_MAX			_SC_NGROUPS_MAX
+    _SC_OPEN_MAX,
+#define	_SC_OPEN_MAX			_SC_OPEN_MAX
+    _SC_STREAM_MAX,
+#define	_SC_STREAM_MAX			_SC_STREAM_MAX
+    _SC_TZNAME_MAX,
+#define	_SC_TZNAME_MAX			_SC_TZNAME_MAX
+    _SC_JOB_CONTROL,
+#define	_SC_JOB_CONTROL			_SC_JOB_CONTROL
+    _SC_SAVED_IDS,
+#define	_SC_SAVED_IDS			_SC_SAVED_IDS
+    _SC_REALTIME_SIGNALS,
+#define	_SC_REALTIME_SIGNALS		_SC_REALTIME_SIGNALS
+    _SC_PRIORITY_SCHEDULING,
+#define	_SC_PRIORITY_SCHEDULING		_SC_PRIORITY_SCHEDULING
+    _SC_TIMERS,
+#define	_SC_TIMERS			_SC_TIMERS
+    _SC_ASYNCHRONOUS_IO,
+#define	_SC_ASYNCHRONOUS_IO		_SC_ASYNCHRONOUS_IO
+    _SC_PRIORITIZED_IO,
+#define	_SC_PRIORITIZED_IO		_SC_PRIORITIZED_IO
+    _SC_SYNCHRONIZED_IO,
+#define	_SC_SYNCHRONIZED_IO		_SC_SYNCHRONIZED_IO
+    _SC_FSYNC,
+#define	_SC_FSYNC			_SC_FSYNC
+    _SC_MAPPED_FILES,
+#define	_SC_MAPPED_FILES		_SC_MAPPED_FILES
+    _SC_MEMLOCK,
+#define	_SC_MEMLOCK			_SC_MEMLOCK
+    _SC_MEMLOCK_RANGE,
+#define	_SC_MEMLOCK_RANGE		_SC_MEMLOCK_RANGE
+    _SC_MEMORY_PROTECTION,
+#define	_SC_MEMORY_PROTECTION		_SC_MEMORY_PROTECTION
+    _SC_MESSAGE_PASSING,
+#define	_SC_MESSAGE_PASSING		_SC_MESSAGE_PASSING
+    _SC_SEMAPHORES,
+#define	_SC_SEMAPHORES			_SC_SEMAPHORES
+    _SC_SHARED_MEMORY_OBJECTS,
+#define	_SC_SHARED_MEMORY_OBJECTS	_SC_SHARED_MEMORY_OBJECTS
+    _SC_AIO_LISTIO_MAX,
+#define	_SC_AIO_LISTIO_MAX		_SC_AIO_LISTIO_MAX
+    _SC_AIO_MAX,
+#define	_SC_AIO_MAX			_SC_AIO_MAX
+    _SC_AIO_PRIO_DELTA_MAX,
+#define	_SC_AIO_PRIO_DELTA_MAX		_SC_AIO_PRIO_DELTA_MAX
+    _SC_DELAYTIMER_MAX,
+#define	_SC_DELAYTIMER_MAX		_SC_DELAYTIMER_MAX
+    _SC_MQ_OPEN_MAX,
+#define	_SC_MQ_OPEN_MAX			_SC_MQ_OPEN_MAX
+    _SC_MQ_PRIO_MAX,
+#define	_SC_MQ_PRIO_MAX			_SC_MQ_PRIO_MAX
+    _SC_VERSION,
+#define	_SC_VERSION			_SC_VERSION
+    _SC_PAGESIZE,
+#define	_SC_PAGESIZE			_SC_PAGESIZE
+#define	_SC_PAGE_SIZE			_SC_PAGESIZE
+    _SC_RTSIG_MAX,
+#define	_SC_RTSIG_MAX			_SC_RTSIG_MAX
+    _SC_SEM_NSEMS_MAX,
+#define	_SC_SEM_NSEMS_MAX		_SC_SEM_NSEMS_MAX
+    _SC_SEM_VALUE_MAX,
+#define	_SC_SEM_VALUE_MAX		_SC_SEM_VALUE_MAX
+    _SC_SIGQUEUE_MAX,
+#define	_SC_SIGQUEUE_MAX		_SC_SIGQUEUE_MAX
+    _SC_TIMER_MAX,
+#define	_SC_TIMER_MAX			_SC_TIMER_MAX
+
+    /* Values for the argument to `sysconf'
+       corresponding to _POSIX2_* symbols.  */
+    _SC_BC_BASE_MAX,
+#define	_SC_BC_BASE_MAX			_SC_BC_BASE_MAX
+    _SC_BC_DIM_MAX,
+#define	_SC_BC_DIM_MAX			_SC_BC_DIM_MAX
+    _SC_BC_SCALE_MAX,
+#define	_SC_BC_SCALE_MAX		_SC_BC_SCALE_MAX
+    _SC_BC_STRING_MAX,
+#define	_SC_BC_STRING_MAX		_SC_BC_STRING_MAX
+    _SC_COLL_WEIGHTS_MAX,
+#define	_SC_COLL_WEIGHTS_MAX		_SC_COLL_WEIGHTS_MAX
+    _SC_EQUIV_CLASS_MAX,
+#define	_SC_EQUIV_CLASS_MAX		_SC_EQUIV_CLASS_MAX
+    _SC_EXPR_NEST_MAX,
+#define	_SC_EXPR_NEST_MAX		_SC_EXPR_NEST_MAX
+    _SC_LINE_MAX,
+#define	_SC_LINE_MAX			_SC_LINE_MAX
+    _SC_RE_DUP_MAX,
+#define	_SC_RE_DUP_MAX			_SC_RE_DUP_MAX
+    _SC_CHARCLASS_NAME_MAX,
+#define	_SC_CHARCLASS_NAME_MAX		_SC_CHARCLASS_NAME_MAX
+
+    _SC_2_VERSION,
+#define	_SC_2_VERSION			_SC_2_VERSION
+    _SC_2_C_BIND,
+#define	_SC_2_C_BIND			_SC_2_C_BIND
+    _SC_2_C_DEV,
+#define	_SC_2_C_DEV			_SC_2_C_DEV
+    _SC_2_FORT_DEV,
+#define	_SC_2_FORT_DEV			_SC_2_FORT_DEV
+    _SC_2_FORT_RUN,
+#define	_SC_2_FORT_RUN			_SC_2_FORT_RUN
+    _SC_2_SW_DEV,
+#define	_SC_2_SW_DEV			_SC_2_SW_DEV
+    _SC_2_LOCALEDEF,
+#define	_SC_2_LOCALEDEF			_SC_2_LOCALEDEF
+
+    _SC_PII,
+#define	_SC_PII				_SC_PII
+    _SC_PII_XTI,
+#define	_SC_PII_XTI			_SC_PII_XTI
+    _SC_PII_SOCKET,
+#define	_SC_PII_SOCKET			_SC_PII_SOCKET
+    _SC_PII_INTERNET,
+#define	_SC_PII_INTERNET		_SC_PII_INTERNET
+    _SC_PII_OSI,
+#define	_SC_PII_OSI			_SC_PII_OSI
+    _SC_POLL,
+#define	_SC_POLL			_SC_POLL
+    _SC_SELECT,
+#define	_SC_SELECT			_SC_SELECT
+    _SC_UIO_MAXIOV,
+#define	_SC_UIO_MAXIOV			_SC_UIO_MAXIOV
+    _SC_IOV_MAX = _SC_UIO_MAXIOV,
+#define _SC_IOV_MAX			_SC_IOV_MAX
+    _SC_PII_INTERNET_STREAM,
+#define	_SC_PII_INTERNET_STREAM		_SC_PII_INTERNET_STREAM
+    _SC_PII_INTERNET_DGRAM,
+#define	_SC_PII_INTERNET_DGRAM		_SC_PII_INTERNET_DGRAM
+    _SC_PII_OSI_COTS,
+#define	_SC_PII_OSI_COTS		_SC_PII_OSI_COTS
+    _SC_PII_OSI_CLTS,
+#define	_SC_PII_OSI_CLTS		_SC_PII_OSI_CLTS
+    _SC_PII_OSI_M,
+#define	_SC_PII_OSI_M			_SC_PII_OSI_M
+    _SC_T_IOV_MAX,
+#define	_SC_T_IOV_MAX			_SC_T_IOV_MAX
+
+    /* Values according to POSIX 1003.1c (POSIX threads).  */
+    _SC_THREADS,
+#define	_SC_THREADS			_SC_THREADS
+    _SC_THREAD_SAFE_FUNCTIONS,
+#define _SC_THREAD_SAFE_FUNCTIONS	_SC_THREAD_SAFE_FUNCTIONS
+    _SC_GETGR_R_SIZE_MAX,
+#define	_SC_GETGR_R_SIZE_MAX		_SC_GETGR_R_SIZE_MAX
+    _SC_GETPW_R_SIZE_MAX,
+#define	_SC_GETPW_R_SIZE_MAX		_SC_GETPW_R_SIZE_MAX
+    _SC_LOGIN_NAME_MAX,
+#define	_SC_LOGIN_NAME_MAX		_SC_LOGIN_NAME_MAX
+    _SC_TTY_NAME_MAX,
+#define	_SC_TTY_NAME_MAX		_SC_TTY_NAME_MAX
+    _SC_THREAD_DESTRUCTOR_ITERATIONS,
+#define	_SC_THREAD_DESTRUCTOR_ITERATIONS _SC_THREAD_DESTRUCTOR_ITERATIONS
+    _SC_THREAD_KEYS_MAX,
+#define	_SC_THREAD_KEYS_MAX		_SC_THREAD_KEYS_MAX
+    _SC_THREAD_STACK_MIN,
+#define	_SC_THREAD_STACK_MIN		_SC_THREAD_STACK_MIN
+    _SC_THREAD_THREADS_MAX,
+#define	_SC_THREAD_THREADS_MAX		_SC_THREAD_THREADS_MAX
+    _SC_THREAD_ATTR_STACKADDR,
+#define	_SC_THREAD_ATTR_STACKADDR	_SC_THREAD_ATTR_STACKADDR
+    _SC_THREAD_ATTR_STACKSIZE,
+#define	_SC_THREAD_ATTR_STACKSIZE	_SC_THREAD_ATTR_STACKSIZE
+    _SC_THREAD_PRIORITY_SCHEDULING,
+#define	_SC_THREAD_PRIORITY_SCHEDULING	_SC_THREAD_PRIORITY_SCHEDULING
+    _SC_THREAD_PRIO_INHERIT,
+#define	_SC_THREAD_PRIO_INHERIT		_SC_THREAD_PRIO_INHERIT
+    _SC_THREAD_PRIO_PROTECT,
+#define	_SC_THREAD_PRIO_PROTECT		_SC_THREAD_PRIO_PROTECT
+    _SC_THREAD_PROCESS_SHARED,
+#define	_SC_THREAD_PROCESS_SHARED	_SC_THREAD_PROCESS_SHARED
+
+    _SC_NPROCESSORS_CONF,
+#define _SC_NPROCESSORS_CONF		_SC_NPROCESSORS_CONF
+    _SC_NPROCESSORS_ONLN,
+#define _SC_NPROCESSORS_ONLN		_SC_NPROCESSORS_ONLN
+    _SC_PHYS_PAGES,
+#define _SC_PHYS_PAGES			_SC_PHYS_PAGES
+    _SC_AVPHYS_PAGES,
+#define _SC_AVPHYS_PAGES		_SC_AVPHYS_PAGES
+    _SC_ATEXIT_MAX,
+#define _SC_ATEXIT_MAX			_SC_ATEXIT_MAX
+    _SC_PASS_MAX,
+#define _SC_PASS_MAX			_SC_PASS_MAX
+
+    _SC_XOPEN_VERSION,
+#define _SC_XOPEN_VERSION		_SC_XOPEN_VERSION
+    _SC_XOPEN_XCU_VERSION,
+#define _SC_XOPEN_XCU_VERSION		_SC_XOPEN_XCU_VERSION
+    _SC_XOPEN_UNIX,
+#define _SC_XOPEN_UNIX			_SC_XOPEN_UNIX
+    _SC_XOPEN_CRYPT,
+#define _SC_XOPEN_CRYPT			_SC_XOPEN_CRYPT
+    _SC_XOPEN_ENH_I18N,
+#define _SC_XOPEN_ENH_I18N		_SC_XOPEN_ENH_I18N
+    _SC_XOPEN_SHM,
+#define _SC_XOPEN_SHM			_SC_XOPEN_SHM
+
+    _SC_2_CHAR_TERM,
+#define _SC_2_CHAR_TERM			_SC_2_CHAR_TERM
+    _SC_2_C_VERSION,
+#define _SC_2_C_VERSION			_SC_2_C_VERSION
+    _SC_2_UPE,
+#define _SC_2_UPE			_SC_2_UPE
+
+    _SC_XOPEN_XPG2,
+#define _SC_XOPEN_XPG2			_SC_XOPEN_XPG2
+    _SC_XOPEN_XPG3,
+#define _SC_XOPEN_XPG3			_SC_XOPEN_XPG3
+    _SC_XOPEN_XPG4,
+#define _SC_XOPEN_XPG4			_SC_XOPEN_XPG4
+
+    _SC_CHAR_BIT,
+#define	_SC_CHAR_BIT			_SC_CHAR_BIT
+    _SC_CHAR_MAX,
+#define	_SC_CHAR_MAX			_SC_CHAR_MAX
+    _SC_CHAR_MIN,
+#define	_SC_CHAR_MIN			_SC_CHAR_MIN
+    _SC_INT_MAX,
+#define	_SC_INT_MAX			_SC_INT_MAX
+    _SC_INT_MIN,
+#define	_SC_INT_MIN			_SC_INT_MIN
+    _SC_LONG_BIT,
+#define	_SC_LONG_BIT			_SC_LONG_BIT
+    _SC_WORD_BIT,
+#define	_SC_WORD_BIT			_SC_WORD_BIT
+    _SC_MB_LEN_MAX,
+#define	_SC_MB_LEN_MAX			_SC_MB_LEN_MAX
+    _SC_NZERO,
+#define	_SC_NZERO			_SC_NZERO
+    _SC_SSIZE_MAX,
+#define	_SC_SSIZE_MAX			_SC_SSIZE_MAX
+    _SC_SCHAR_MAX,
+#define	_SC_SCHAR_MAX			_SC_SCHAR_MAX
+    _SC_SCHAR_MIN,
+#define	_SC_SCHAR_MIN			_SC_SCHAR_MIN
+    _SC_SHRT_MAX,
+#define	_SC_SHRT_MAX			_SC_SHRT_MAX
+    _SC_SHRT_MIN,
+#define	_SC_SHRT_MIN			_SC_SHRT_MIN
+    _SC_UCHAR_MAX,
+#define	_SC_UCHAR_MAX			_SC_UCHAR_MAX
+    _SC_UINT_MAX,
+#define	_SC_UINT_MAX			_SC_UINT_MAX
+    _SC_ULONG_MAX,
+#define	_SC_ULONG_MAX			_SC_ULONG_MAX
+    _SC_USHRT_MAX,
+#define	_SC_USHRT_MAX			_SC_USHRT_MAX
+
+    _SC_NL_ARGMAX,
+#define	_SC_NL_ARGMAX			_SC_NL_ARGMAX
+    _SC_NL_LANGMAX,
+#define	_SC_NL_LANGMAX			_SC_NL_LANGMAX
+    _SC_NL_MSGMAX,
+#define	_SC_NL_MSGMAX			_SC_NL_MSGMAX
+    _SC_NL_NMAX,
+#define	_SC_NL_NMAX			_SC_NL_NMAX
+    _SC_NL_SETMAX,
+#define	_SC_NL_SETMAX			_SC_NL_SETMAX
+    _SC_NL_TEXTMAX,
+#define	_SC_NL_TEXTMAX			_SC_NL_TEXTMAX
+
+    _SC_XBS5_ILP32_OFF32,
+#define _SC_XBS5_ILP32_OFF32		_SC_XBS5_ILP32_OFF32
+    _SC_XBS5_ILP32_OFFBIG,
+#define _SC_XBS5_ILP32_OFFBIG		_SC_XBS5_ILP32_OFFBIG
+    _SC_XBS5_LP64_OFF64,
+#define _SC_XBS5_LP64_OFF64		_SC_XBS5_LP64_OFF64
+    _SC_XBS5_LPBIG_OFFBIG,
+#define _SC_XBS5_LPBIG_OFFBIG		_SC_XBS5_LPBIG_OFFBIG
+
+    _SC_XOPEN_LEGACY,
+#define _SC_XOPEN_LEGACY		_SC_XOPEN_LEGACY
+    _SC_XOPEN_REALTIME,
+#define _SC_XOPEN_REALTIME		_SC_XOPEN_REALTIME
+    _SC_XOPEN_REALTIME_THREADS,
+#define _SC_XOPEN_REALTIME_THREADS	_SC_XOPEN_REALTIME_THREADS
+
+    _SC_ADVISORY_INFO,
+#define _SC_ADVISORY_INFO		_SC_ADVISORY_INFO
+    _SC_BARRIERS,
+#define _SC_BARRIERS			_SC_BARRIERS
+    _SC_BASE,
+#define _SC_BASE			_SC_BASE
+    _SC_C_LANG_SUPPORT,
+#define _SC_C_LANG_SUPPORT		_SC_C_LANG_SUPPORT
+    _SC_C_LANG_SUPPORT_R,
+#define _SC_C_LANG_SUPPORT_R		_SC_C_LANG_SUPPORT_R
+    _SC_CLOCK_SELECTION,
+#define _SC_CLOCK_SELECTION		_SC_CLOCK_SELECTION
+    _SC_CPUTIME,
+#define _SC_CPUTIME			_SC_CPUTIME
+    _SC_THREAD_CPUTIME,
+#define _SC_THREAD_CPUTIME		_SC_THREAD_CPUTIME
+    _SC_DEVICE_IO,
+#define _SC_DEVICE_IO			_SC_DEVICE_IO
+    _SC_DEVICE_SPECIFIC,
+#define _SC_DEVICE_SPECIFIC		_SC_DEVICE_SPECIFIC
+    _SC_DEVICE_SPECIFIC_R,
+#define _SC_DEVICE_SPECIFIC_R		_SC_DEVICE_SPECIFIC_R
+    _SC_FD_MGMT,
+#define _SC_FD_MGMT			_SC_FD_MGMT
+    _SC_FIFO,
+#define _SC_FIFO			_SC_FIFO
+    _SC_PIPE,
+#define _SC_PIPE			_SC_PIPE
+    _SC_FILE_ATTRIBUTES,
+#define _SC_FILE_ATTRIBUTES		_SC_FILE_ATTRIBUTES
+    _SC_FILE_LOCKING,
+#define _SC_FILE_LOCKING		_SC_FILE_LOCKING
+    _SC_FILE_SYSTEM,
+#define _SC_FILE_SYSTEM			_SC_FILE_SYSTEM
+    _SC_MONOTONIC_CLOCK,
+#define _SC_MONOTONIC_CLOCK		_SC_MONOTONIC_CLOCK
+    _SC_MULTI_PROCESS,
+#define _SC_MULTI_PROCESS		_SC_MULTI_PROCESS
+    _SC_SINGLE_PROCESS,
+#define _SC_SINGLE_PROCESS		_SC_SINGLE_PROCESS
+    _SC_NETWORKING,
+#define _SC_NETWORKING			_SC_NETWORKING
+    _SC_READER_WRITER_LOCKS,
+#define _SC_READER_WRITER_LOCKS		_SC_READER_WRITER_LOCKS
+    _SC_SPIN_LOCKS,
+#define _SC_SPIN_LOCKS			_SC_SPIN_LOCKS
+    _SC_REGEXP,
+#define _SC_REGEXP			_SC_REGEXP
+    _SC_REGEX_VERSION,
+#define _SC_REGEX_VERSION		_SC_REGEX_VERSION
+    _SC_SHELL,
+#define _SC_SHELL			_SC_SHELL
+    _SC_SIGNALS,
+#define _SC_SIGNALS			_SC_SIGNALS
+    _SC_SPAWN,
+#define _SC_SPAWN			_SC_SPAWN
+    _SC_SPORADIC_SERVER,
+#define _SC_SPORADIC_SERVER		_SC_SPORADIC_SERVER
+    _SC_THREAD_SPORADIC_SERVER,
+#define _SC_THREAD_SPORADIC_SERVER	_SC_THREAD_SPORADIC_SERVER
+    _SC_SYSTEM_DATABASE,
+#define _SC_SYSTEM_DATABASE		_SC_SYSTEM_DATABASE
+    _SC_SYSTEM_DATABASE_R,
+#define _SC_SYSTEM_DATABASE_R		_SC_SYSTEM_DATABASE_R
+    _SC_TIMEOUTS,
+#define _SC_TIMEOUTS			_SC_TIMEOUTS
+    _SC_TYPED_MEMORY_OBJECTS,
+#define _SC_TYPED_MEMORY_OBJECTS	_SC_TYPED_MEMORY_OBJECTS
+    _SC_USER_GROUPS,
+#define _SC_USER_GROUPS			_SC_USER_GROUPS
+    _SC_USER_GROUPS_R,
+#define _SC_USER_GROUPS_R		_SC_USER_GROUPS_R
+    _SC_2_PBS,
+#define _SC_2_PBS			_SC_2_PBS
+    _SC_2_PBS_ACCOUNTING,
+#define _SC_2_PBS_ACCOUNTING		_SC_2_PBS_ACCOUNTING
+    _SC_2_PBS_LOCATE,
+#define _SC_2_PBS_LOCATE		_SC_2_PBS_LOCATE
+    _SC_2_PBS_MESSAGE,
+#define _SC_2_PBS_MESSAGE		_SC_2_PBS_MESSAGE
+    _SC_2_PBS_TRACK,
+#define _SC_2_PBS_TRACK			_SC_2_PBS_TRACK
+    _SC_SYMLOOP_MAX,
+#define _SC_SYMLOOP_MAX			_SC_SYMLOOP_MAX
+    _SC_STREAMS,
+#define _SC_STREAMS			_SC_STREAMS
+    _SC_2_PBS_CHECKPOINT,
+#define _SC_2_PBS_CHECKPOINT		_SC_2_PBS_CHECKPOINT
+
+    _SC_V6_ILP32_OFF32,
+#define _SC_V6_ILP32_OFF32		_SC_V6_ILP32_OFF32
+    _SC_V6_ILP32_OFFBIG,
+#define _SC_V6_ILP32_OFFBIG		_SC_V6_ILP32_OFFBIG
+    _SC_V6_LP64_OFF64,
+#define _SC_V6_LP64_OFF64		_SC_V6_LP64_OFF64
+    _SC_V6_LPBIG_OFFBIG,
+#define _SC_V6_LPBIG_OFFBIG		_SC_V6_LPBIG_OFFBIG
+
+    _SC_HOST_NAME_MAX,
+#define _SC_HOST_NAME_MAX		_SC_HOST_NAME_MAX
+    _SC_TRACE,
+#define _SC_TRACE			_SC_TRACE
+    _SC_TRACE_EVENT_FILTER,
+#define _SC_TRACE_EVENT_FILTER		_SC_TRACE_EVENT_FILTER
+    _SC_TRACE_INHERIT,
+#define _SC_TRACE_INHERIT		_SC_TRACE_INHERIT
+    _SC_TRACE_LOG
+#define _SC_TRACE_LOG			_SC_TRACE_LOG
+  };
+
+#if (defined __USE_POSIX2 || defined __USE_UNIX98 \
+     || defined __USE_FILE_OFFSET64 || defined __USE_LARGEFILE64 \
+     || defined __USE_LARGEFILE)
+/* Values for the NAME argument to `confstr'.  */
+enum
+  {
+    _CS_PATH,			/* The default search path.  */
+#define _CS_PATH		_CS_PATH
+
+# if (defined __USE_FILE_OFFSET64 || defined __USE_LARGEFILE64 \
+     || defined __USE_LARGEFILE)
+    _CS_LFS_CFLAGS = 1000,
+#  define _CS_LFS_CFLAGS		_CS_LFS_CFLAGS
+    _CS_LFS_LDFLAGS,
+#  define _CS_LFS_LDFLAGS	_CS_LFS_LDFLAGS
+    _CS_LFS_LIBS,
+#  define _CS_LFS_LIBS		_CS_LFS_LIBS
+    _CS_LFS_LINTFLAGS,
+#  define _CS_LFS_LINTFLAGS	_CS_LFS_LINTFLAGS
+    _CS_LFS64_CFLAGS,
+#  define _CS_LFS64_CFLAGS	_CS_LFS64_CFLAGS
+    _CS_LFS64_LDFLAGS,
+#  define _CS_LFS64_LDFLAGS	_CS_LFS64_LDFLAGS
+    _CS_LFS64_LIBS,
+#  define _CS_LFS64_LIBS		_CS_LFS64_LIBS
+    _CS_LFS64_LINTFLAGS,
+#  define _CS_LFS64_LINTFLAGS	_CS_LFS64_LINTFLAGS
+# endif
+
+# ifdef __USE_UNIX98
+    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
+#  define _CS_XBS5_ILP32_OFF32_CFLAGS _CS_XBS5_ILP32_OFF32_CFLAGS
+    _CS_XBS5_ILP32_OFF32_LDFLAGS,
+#  define _CS_XBS5_ILP32_OFF32_LDFLAGS _CS_XBS5_ILP32_OFF32_LDFLAGS
+    _CS_XBS5_ILP32_OFF32_LIBS,
+#  define _CS_XBS5_ILP32_OFF32_LIBS _CS_XBS5_ILP32_OFF32_LIBS
+    _CS_XBS5_ILP32_OFF32_LINTFLAGS,
+#  define _CS_XBS5_ILP32_OFF32_LINTFLAGS _CS_XBS5_ILP32_OFF32_LINTFLAGS
+    _CS_XBS5_ILP32_OFFBIG_CFLAGS,
+#  define _CS_XBS5_ILP32_OFFBIG_CFLAGS _CS_XBS5_ILP32_OFFBIG_CFLAGS
+    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
+#  define _CS_XBS5_ILP32_OFFBIG_LDFLAGS _CS_XBS5_ILP32_OFFBIG_LDFLAGS
+    _CS_XBS5_ILP32_OFFBIG_LIBS,
+#  define _CS_XBS5_ILP32_OFFBIG_LIBS _CS_XBS5_ILP32_OFFBIG_LIBS
+    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
+#  define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS _CS_XBS5_ILP32_OFFBIG_LINTFLAGS
+    _CS_XBS5_LP64_OFF64_CFLAGS,
+#  define _CS_XBS5_LP64_OFF64_CFLAGS _CS_XBS5_LP64_OFF64_CFLAGS
+    _CS_XBS5_LP64_OFF64_LDFLAGS,
+#  define _CS_XBS5_LP64_OFF64_LDFLAGS _CS_XBS5_LP64_OFF64_LDFLAGS
+    _CS_XBS5_LP64_OFF64_LIBS,
+#  define _CS_XBS5_LP64_OFF64_LIBS _CS_XBS5_LP64_OFF64_LIBS
+    _CS_XBS5_LP64_OFF64_LINTFLAGS,
+#  define _CS_XBS5_LP64_OFF64_LINTFLAGS _CS_XBS5_LP64_OFF64_LINTFLAGS
+    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
+#  define _CS_XBS5_LPBIG_OFFBIG_CFLAGS _CS_XBS5_LPBIG_OFFBIG_CFLAGS
+    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
+#  define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS _CS_XBS5_LPBIG_OFFBIG_LDFLAGS
+    _CS_XBS5_LPBIG_OFFBIG_LIBS,
+#  define _CS_XBS5_LPBIG_OFFBIG_LIBS _CS_XBS5_LPBIG_OFFBIG_LIBS
+    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
+#  define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS
+# endif
+# ifdef __USE_XOPEN2K
+    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
+#  define _CS_POSIX_V6_ILP32_OFF32_CFLAGS _CS_POSIX_V6_ILP32_OFF32_CFLAGS
+    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
+#  define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS _CS_POSIX_V6_ILP32_OFF32_LDFLAGS
+    _CS_POSIX_V6_ILP32_OFF32_LIBS,
+#  define _CS_POSIX_V6_ILP32_OFF32_LIBS _CS_POSIX_V6_ILP32_OFF32_LIBS
+    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
+#  define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
+    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
+#  define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
+    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
+#  define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
+    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
+#  define _CS_POSIX_V6_ILP32_OFFBIG_LIBS _CS_POSIX_V6_ILP32_OFFBIG_LIBS
+    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
+#  define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
+    _CS_POSIX_V6_LP64_OFF64_CFLAGS,
+#  define _CS_POSIX_V6_LP64_OFF64_CFLAGS _CS_POSIX_V6_LP64_OFF64_CFLAGS
+    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
+#  define _CS_POSIX_V6_LP64_OFF64_LDFLAGS _CS_POSIX_V6_LP64_OFF64_LDFLAGS
+    _CS_POSIX_V6_LP64_OFF64_LIBS,
+#  define _CS_POSIX_V6_LP64_OFF64_LIBS _CS_POSIX_V6_LP64_OFF64_LIBS
+    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
+#  define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS _CS_POSIX_V6_LP64_OFF64_LINTFLAGS
+    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
+#  define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
+    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
+#  define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
+    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
+#  define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS _CS_POSIX_V6_LPBIG_OFFBIG_LIBS
+    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
+#  define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
+# endif
+
+    _CS_V6_WIDTH_RESTRICTED_ENVS
+# define _CS_V6_WIDTH_RESTRICTED_ENVS	_CS_V6_WIDTH_RESTRICTED_ENVS
+  };
+#endif
diff -pruwN busybox-1.01/include2/bits/dirent.h busybox-1.01-livebox/include2/bits/dirent.h
--- busybox-1.01/include2/bits/dirent.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/dirent.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,53 @@
+/* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _DIRENT_H
+# error "Never use <bits/dirent.h> directly; include <dirent.h> instead."
+#endif
+
+struct dirent
+  {
+#ifndef __USE_FILE_OFFSET64
+    __ino_t d_ino;
+    __off_t d_off;
+#else
+    __ino64_t d_ino;
+    __off64_t d_off;
+#endif
+    unsigned short int d_reclen;
+    unsigned char d_type;
+    char d_name[256];		/* We must not include limits.h! */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct dirent64
+  {
+    __ino64_t d_ino;
+    __off64_t d_off;
+    unsigned short int d_reclen;
+    unsigned char d_type;
+    char d_name[256];		/* We must not include limits.h! */
+  };
+#endif
+
+#define d_fileno	d_ino	/* Backwards compatibility.  */
+
+#undef  _DIRENT_HAVE_D_NAMLEN
+#define _DIRENT_HAVE_D_RECLEN
+#define _DIRENT_HAVE_D_OFF
+#define _DIRENT_HAVE_D_TYPE
diff -pruwN busybox-1.01/include2/bits/endian.h busybox-1.01-livebox/include2/bits/endian.h
--- busybox-1.01/include2/bits/endian.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/endian.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,16 @@
+/* The MIPS architecture has selectable endianness.
+   Linux/MIPS exists in two both little and big endian flavours and we
+   want to be able to share the installed headerfiles between both,
+   so we define __BYTE_ORDER based on GCC's predefines.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#ifdef __MIPSEB__
+# define __BYTE_ORDER __BIG_ENDIAN
+#else
+# ifdef __MIPSEL__
+#  define __BYTE_ORDER __LITTLE_ENDIAN
+# endif
+#endif
diff -pruwN busybox-1.01/include2/bits/environments.h busybox-1.01-livebox/include2/bits/environments.h
--- busybox-1.01/include2/bits/environments.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/environments.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,75 @@
+/* Copyright (C) 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UNISTD_H
+# error "Never include this file directly.  Use <unistd.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+/* This header should define the following symbols under the described
+   situations.  A value `1' means that the model is always supported,
+   `-1' means it is never supported.  Undefined means it cannot be
+   statically decided.
+
+   _POSIX_V6_ILP32_OFF32   32bit int, long, pointers, and off_t type
+   _POSIX_V6_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
+
+   _POSIX_V6_LP64_OFF32	   64bit long and pointers and 32bit off_t type
+   _POSIX_V6_LPBIG_OFFBIG  64bit long and pointers and large off_t type
+
+   The macros _XBS5_ILP32_OFF32, _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and
+   _XBS5_LPBIG_OFFBIG were used in previous versions of the Unix standard
+   and are available only for compatibility.
+*/
+
+#if __WORDSIZE == 64
+
+/* We can never provide environments with 32-bit wide pointers.  */
+# define _POSIX_V6_ILP32_OFF32	-1
+# define _POSIX_V6_ILP32_OFFBIG	-1
+# define _XBS5_ILP32_OFF32	-1
+# define _XBS5_ILP32_OFFBIG	-1
+/* We also have no use (for now) for an environment with bigger pointers
+   and offsets.  */
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
+# define _POSIX_V6_LP64_OFF64	1
+# define _XBS5_LP64_OFF64	1
+
+#else /* __WORDSIZE == 32 */
+
+/* By default we have 32-bit wide `int', `long int', pointers and `off_t'
+   and all platforms support LFS.  */
+# define _POSIX_V6_ILP32_OFF32	1
+# define _POSIX_V6_ILP32_OFFBIG	1
+# define _XBS5_ILP32_OFF32	1
+# define _XBS5_ILP32_OFFBIG	1
+
+/* We optionally provide an environment with the above size but an 64-bit
+   side `off_t'.  Therefore we don't define _XBS5_ILP32_OFFBIG.  */
+
+/* We can never provide environments with 64-bit wide pointers.  */
+# define _POSIX_V6_LP64_OFF64	-1
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LP64_OFF64	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+#endif /* __WORDSIZE == 32 */
diff -pruwN busybox-1.01/include2/bits/errno.h busybox-1.01-livebox/include2/bits/errno.h
--- busybox-1.01/include2/bits/errno.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/errno.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,52 @@
+/* Error constants.  Linux specific version.
+   Copyright (C) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef _ERRNO_H
+
+# include <bits/errno_values.h>
+
+#ifndef ENOTSUP
+# define ENOTSUP EOPNOTSUPP
+#endif
+
+#ifndef ECANCELED
+# define ECANCELED	125
+#endif
+
+# ifndef __ASSEMBLER__
+
+/* We now need a declaration of the `errno' variable.  */
+extern int errno;
+
+/* Function to get address of global `errno' variable.  */
+extern int *__errno_location (void) __THROW __attribute__ ((__const__));
+
+#  if defined _LIBC
+/* We wouldn't need a special macro anymore but it is history.  */
+#   define __set_errno(val) ((errno) = (val))
+#  endif /* _LIBC */
+
+#  if defined __UCLIBC_HAS_THREADS__
+/* When using threads, errno is a per-thread value.  */
+#   define errno (*__errno_location ())
+#  endif
+
+# endif /* !__ASSEMBLER__ */
+#endif /* _ERRNO_H */
+
diff -pruwN busybox-1.01/include2/bits/errno_values.h busybox-1.01-livebox/include2/bits/errno_values.h
--- busybox-1.01/include2/bits/errno_values.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/errno_values.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,135 @@
+#ifndef _BITS_ERRNO_VALUES_H
+#define _BITS_ERRNO_VALUES_H
+
+/* These error numbers are intended to be MIPS ABI compatible */
+
+#define	EPERM		 1	/* Operation not permitted */
+#define	ENOENT		 2	/* No such file or directory */
+#define	ESRCH		 3	/* No such process */
+#define	EINTR		 4	/* Interrupted system call */
+#define	EIO		 5	/* I/O error */
+#define	ENXIO		 6	/* No such device or address */
+#define	E2BIG		 7	/* Argument list too long */
+#define	ENOEXEC		 8	/* Exec format error */
+#define	EBADF		 9	/* Bad file number */
+#define	ECHILD		10	/* No child processes */
+#define	EAGAIN		11	/* Try again */
+#define	ENOMEM		12	/* Out of memory */
+#define	EACCES		13	/* Permission denied */
+#define	EFAULT		14	/* Bad address */
+#define	ENOTBLK		15	/* Block device required */
+#define	EBUSY		16	/* Device or resource busy */
+#define	EEXIST		17	/* File exists */
+#define	EXDEV		18	/* Cross-device link */
+#define	ENODEV		19	/* No such device */
+#define	ENOTDIR		20	/* Not a directory */
+#define	EISDIR		21	/* Is a directory */
+#define	EINVAL		22	/* Invalid argument */
+#define	ENFILE		23	/* File table overflow */
+#define	EMFILE		24	/* Too many open files */
+#define	ENOTTY		25	/* Not a typewriter */
+#define	ETXTBSY		26	/* Text file busy */
+#define	EFBIG		27	/* File too large */
+#define	ENOSPC		28	/* No space left on device */
+#define	ESPIPE		29	/* Illegal seek */
+#define	EROFS		30	/* Read-only file system */
+#define	EMLINK		31	/* Too many links */
+#define	EPIPE		32	/* Broken pipe */
+#define	EDOM		33	/* Math argument out of domain of func */
+#define	ERANGE		34	/* Math result not representable */
+#define	ENOMSG		35	/* No message of desired type */
+#define	EIDRM		36	/* Identifier removed */
+#define	ECHRNG		37	/* Channel number out of range */
+#define	EL2NSYNC	38	/* Level 2 not synchronized */
+#define	EL3HLT		39	/* Level 3 halted */
+#define	EL3RST		40	/* Level 3 reset */
+#define	ELNRNG		41	/* Link number out of range */
+#define	EUNATCH		42	/* Protocol driver not attached */
+#define	ENOCSI		43	/* No CSI structure available */
+#define	EL2HLT		44	/* Level 2 halted */
+#define	EDEADLK		45	/* Resource deadlock would occur */
+#define	ENOLCK		46	/* No record locks available */
+#define	EBADE		50	/* Invalid exchange */
+#define	EBADR		51	/* Invalid request descriptor */
+#define	EXFULL		52	/* Exchange full */
+#define	ENOANO		53	/* No anode */
+#define	EBADRQC		54	/* Invalid request code */
+#define	EBADSLT		55	/* Invalid slot */
+#define	EDEADLOCK	56	/* File locking deadlock error */
+#define	EBFONT		59	/* Bad font file format */
+#define	ENOSTR		60	/* Device not a stream */
+#define	ENODATA		61	/* No data available */
+#define	ETIME		62	/* Timer expired */
+#define	ENOSR		63	/* Out of streams resources */
+#define	ENONET		64	/* Machine is not on the network */
+#define	ENOPKG		65	/* Package not installed */
+#define	EREMOTE		66	/* Object is remote */
+#define	ENOLINK		67	/* Link has been severed */
+#define	EADV		68	/* Advertise error */
+#define	ESRMNT		69	/* Srmount error */
+#define	ECOMM		70	/* Communication error on send */
+#define	EPROTO		71	/* Protocol error */
+#define	EDOTDOT		73	/* RFS specific error */
+#define	EMULTIHOP	74	/* Multihop attempted */
+#define	EBADMSG		77	/* Not a data message */
+#define	ENAMETOOLONG	78	/* File name too long */
+#define	EOVERFLOW	79	/* Value too large for defined data type */
+#define	ENOTUNIQ	80	/* Name not unique on network */
+#define	EBADFD		81	/* File descriptor in bad state */
+#define	EREMCHG		82	/* Remote address changed */
+#define	ELIBACC		83	/* Can not access a needed shared library */
+#define	ELIBBAD		84	/* Accessing a corrupted shared library */
+#define	ELIBSCN		85	/* .lib section in a.out corrupted */
+#define	ELIBMAX		86	/* Attempting to link in too many shared libraries */
+#define	ELIBEXEC	87	/* Cannot exec a shared library directly */
+#define	EILSEQ		88	/* Illegal byte sequence */
+#define	ENOSYS		89	/* Function not implemented */
+#define	ELOOP		90	/* Too many symbolic links encountered */
+#define	ERESTART	91	/* Interrupted system call should be restarted */
+#define	ESTRPIPE	92	/* Streams pipe error */
+#define	ENOTEMPTY	93	/* Directory not empty */
+#define	EUSERS		94	/* Too many users */
+#define	ENOTSOCK	95	/* Socket operation on non-socket */
+#define	EDESTADDRREQ	96	/* Destination address required */
+#define	EMSGSIZE	97	/* Message too long */
+#define	EPROTOTYPE	98	/* Protocol wrong type for socket */
+#define	ENOPROTOOPT	99	/* Protocol not available */
+#define	EPROTONOSUPPORT	120	/* Protocol not supported */
+#define	ESOCKTNOSUPPORT	121	/* Socket type not supported */
+#define	EOPNOTSUPP	122	/* Operation not supported on transport endpoint */
+#define	EPFNOSUPPORT	123	/* Protocol family not supported */
+#define	EAFNOSUPPORT	124	/* Address family not supported by protocol */
+#define	EADDRINUSE	125	/* Address already in use */
+#define	EADDRNOTAVAIL	126	/* Cannot assign requested address */
+#define	ENETDOWN	127	/* Network is down */
+#define	ENETUNREACH	128	/* Network is unreachable */
+#define	ENETRESET	129	/* Network dropped connection because of reset */
+#define	ECONNABORTED	130	/* Software caused connection abort */
+#define	ECONNRESET	131	/* Connection reset by peer */
+#define	ENOBUFS		132	/* No buffer space available */
+#define	EISCONN		133	/* Transport endpoint is already connected */
+#define	ENOTCONN	134	/* Transport endpoint is not connected */
+#define	EUCLEAN		135	/* Structure needs cleaning */
+#define	ENOTNAM		137	/* Not a XENIX named type file */
+#define	ENAVAIL		138	/* No XENIX semaphores available */
+#define	EISNAM		139	/* Is a named type file */
+#define	EREMOTEIO	140	/* Remote I/O error */
+#define EINIT		141	/* Reserved */
+#define EREMDEV		142	/* Error 142 */
+#define	ESHUTDOWN	143	/* Cannot send after transport endpoint shutdown */
+#define	ETOOMANYREFS	144	/* Too many references: cannot splice */
+#define	ETIMEDOUT	145	/* Connection timed out */
+#define	ECONNREFUSED	146	/* Connection refused */
+#define	EHOSTDOWN	147	/* Host is down */
+#define	EHOSTUNREACH	148	/* No route to host */
+#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
+#define	EALREADY	149	/* Operation already in progress */
+#define	EINPROGRESS	150	/* Operation now in progress */
+#define	ESTALE		151	/* Stale NFS file handle */
+#define ECANCELED	158	/* AIO operation canceled */
+/* These errors are Linux extensions.  */
+#define ENOMEDIUM	159	/* No medium found */
+#define EMEDIUMTYPE	160	/* Wrong medium type */
+#define EDQUOT		1133	/* Quota exceeded */
+
+#endif /* _BITS_ERRNO_VALUES_H */
diff -pruwN busybox-1.01/include2/bits/fcntl.h busybox-1.01-livebox/include2/bits/fcntl.h
--- busybox-1.01/include2/bits/fcntl.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/fcntl.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,187 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	0x0003
+#define O_RDONLY	0x0000
+#define O_WRONLY	0x0001
+#define O_RDWR		0x0002
+#define O_APPEND	0x0008
+#define O_SYNC		0x0010
+#define O_NONBLOCK	0x0080
+#define O_CREAT		0x0100	/* not fcntl */
+#define O_TRUNC		0x0200	/* not fcntl */
+#define O_EXCL		0x0400	/* not fcntl */
+#define O_NOCTTY	0x0800	/* not fcntl */
+#define O_FSYNC		O_SYNC
+#define O_ASYNC		0x1000
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0x2000	/* Allow large file opens.  */
+#endif
+
+#ifdef __USE_GNU
+# define O_NOFOLLOW	0x20000	/* Do not follow links.	 */
+# define O_DIRECT	0x8000	/* Direct disk access hint.  */
+# define O_DIRECTORY	0x10000	/* Must be a directory.	 */
+# define O_STREAMING	0x4000000/* streaming access */
+#endif
+
+#define O_NDELAY	O_NONBLOCK
+
+/* For now Linux has no synchronisity options for data and read
+   operations.	We define the symbols here but let them do the same as
+   O_SYNC since this is a superset.  */
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	14	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+
+#define F_GETLK64	33	/* Get record locking info.  */
+#define F_SETLK64	34	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	35	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+# define F_SETOWN	24	/* Get owner of socket (receiver of SIGIO).  */
+# define F_GETOWN	23	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+#endif
+
+/* for F_[GET|SET]FL */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* for old implementation of bsd flock () */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation */
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+typedef struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    long int l_sysid;	/* XXX */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+#ifndef __USE_FILE_OFFSET64
+    long int pad[4];	/* XXX */
+#endif
+} flock_t;
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
diff -pruwN busybox-1.01/include2/bits/getopt.h busybox-1.01-livebox/include2/bits/getopt.h
--- busybox-1.01/include2/bits/getopt.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/getopt.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,162 @@
+/* Declarations for getopt.
+   Copyright (C) 1989-1994, 1996-1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _GETOPT_H
+
+#ifndef __need_getopt
+# define _GETOPT_H 1
+#endif
+
+/* If __GNU_LIBRARY__ is not already defined, either we are being used
+   standalone, or this is the first header included in the source file.
+   If we are being used with glibc, we need to include <features.h>, but
+   that does not exist if we are standalone.  So: if __GNU_LIBRARY__ is
+   not defined, include <ctype.h>, which will pull in <features.h> for us
+   if it's from glibc.  (Why ctype.h?  It's guaranteed to exist and it
+   doesn't flood the namespace with stuff the way some other headers do.)  */
+#if !defined __GNU_LIBRARY__
+# include <ctype.h>
+#endif
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* For communication from `getopt' to the caller.
+   When `getopt' finds an option that takes an argument,
+   the argument value is returned here.
+   Also, when `ordering' is RETURN_IN_ORDER,
+   each non-option ARGV-element is returned here.  */
+
+extern char *optarg;
+
+/* Index in ARGV of the next element to be scanned.
+   This is used for communication to and from the caller
+   and for communication between successive calls to `getopt'.
+
+   On entry to `getopt', zero means this is the first call; initialize.
+
+   When `getopt' returns -1, this is the index of the first of the
+   non-option elements that the caller should itself scan.
+
+   Otherwise, `optind' communicates from one call to the next
+   how much of ARGV has been scanned so far.  */
+
+extern int optind;
+
+/* Callers store zero here to inhibit the error message `getopt' prints
+   for unrecognized options.  */
+
+extern int opterr;
+
+/* Set to an option character which was unrecognized.  */
+
+extern int optopt;
+
+#ifndef __need_getopt
+/* Describe the long-named options requested by the application.
+   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
+   of `struct option' terminated by an element containing a name which is
+   zero.
+
+   The field `has_arg' is:
+   no_argument		(or 0) if the option does not take an argument,
+   required_argument	(or 1) if the option requires an argument,
+   optional_argument 	(or 2) if the option takes an optional argument.
+
+   If the field `flag' is not NULL, it points to a variable that is set
+   to the value given in the field `val' when the option is found, but
+   left unchanged if the option is not found.
+
+   To have a long-named option do something other than set an `int' to
+   a compiled-in constant, such as set a value from `optarg', set the
+   option's `flag' field to zero and its `val' field to a nonzero
+   value (the equivalent single-letter option character, if there is
+   one).  For long options that have a zero `flag' field, `getopt'
+   returns the contents of the `val' field.  */
+
+struct option
+{
+  const char *name;
+  /* has_arg can't be an enum because some compilers complain about
+     type mismatches in all the code that assumes it is an int.  */
+  int has_arg;
+  int *flag;
+  int val;
+};
+
+/* Names for the values of the `has_arg' field of `struct option'.  */
+
+# define no_argument		0
+# define required_argument	1
+# define optional_argument	2
+#endif	/* need getopt */
+
+
+/* Get definitions and prototypes for functions to process the
+   arguments in ARGV (ARGC of them, minus the program name) for
+   options given in OPTS.
+
+   Return the option character from OPTS just read.  Return -1 when
+   there are no more options.  For unrecognized options, or options
+   missing arguments, `optopt' is set to the option letter, and '?' is
+   returned.
+
+   The OPTS string is a list of characters which are recognized option
+   letters, optionally followed by colons, specifying that that letter
+   takes an argument, to be placed in `optarg'.
+
+   If a letter in OPTS is followed by two colons, its argument is
+   optional.  This behavior is specific to the GNU `getopt'.
+
+   The argument `--' causes premature termination of argument
+   scanning, explicitly telling `getopt' that there are no more
+   options.
+
+   If OPTS begins with `--', then non-option arguments are treated as
+   arguments to the option '\0'.  This behavior is specific to the GNU
+   `getopt'.  */
+
+/* Many other libraries have conflicting prototypes for getopt, with
+   differences in the consts, in stdlib.h.  To avoid compilation
+   errors, only prototype getopt for the GNU C library.  */
+extern int getopt (int __argc, char *const *__argv, const char *__shortopts);
+
+#ifndef __need_getopt
+extern int getopt_long (int __argc, char *const *__argv, const char *__shortopts,
+		        const struct option *__longopts, int *__longind);
+extern int getopt_long_only (int __argc, char *const *__argv,
+			     const char *__shortopts,
+		             const struct option *__longopts, int *__longind);
+
+/* Internal only.  Users should not call this directly.  */
+extern int _getopt_internal (int __argc, char *const *__argv,
+			     const char *__shortopts,
+		             const struct option *__longopts, int *__longind,
+			     int __long_only);
+#endif
+
+#ifdef	__cplusplus
+}
+#endif
+
+/* Make sure we later can get all the definitions and declarations.  */
+#undef __need_getopt
+
+#endif /* getopt.h */
diff -pruwN busybox-1.01/include2/bits/in.h busybox-1.01-livebox/include2/bits/in.h
--- busybox-1.01/include2/bits/in.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/in.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,141 @@
+/* Copyright (C) 1991-1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Linux version.  */
+
+#ifndef _NETINET_IN_H
+# error "Never use <bits/in.h> directly; include <netinet/in.h> instead."
+#endif
+
+/* Options for use with `getsockopt' and `setsockopt' at the IP level.
+   The first word in the comment at the right is the data type used;
+   "bool" means a boolean value stored in an `int'.  */
+#define IP_TOS             1	/* int; IP type of service and precedence.  */
+#define IP_TTL             2	/* int; IP time to live.  */
+#define IP_HDRINCL         3	/* int; Header is included with data.  */
+#define IP_OPTIONS         4	/* ip_opts; IP per-packet options.  */
+#define IP_ROUTER_ALERT    5	/* bool */
+#define IP_RECVOPTS        6	/* bool */
+#define IP_RETOPTS         7	/* bool */
+#define IP_PKTINFO         8	/* bool */
+#define IP_PKTOPTIONS      9
+#define IP_PMTUDISC        10	/* obsolete name? */
+#define IP_MTU_DISCOVER    10	/* int; see below */
+#define IP_RECVERR         11	/* bool */
+#define IP_RECVTTL         12	/* bool */
+#define IP_RECVTOS         13	/* bool */
+#define IP_MULTICAST_IF    32	/* in_addr; set/get IP multicast i/f */
+#define IP_MULTICAST_TTL   33	/* u_char; set/get IP multicast ttl */
+#define IP_MULTICAST_LOOP  34	/* i_char; set/get IP multicast loopback */
+#define IP_ADD_MEMBERSHIP  35	/* ip_mreq; add an IP group membership */
+#define IP_DROP_MEMBERSHIP 36	/* ip_mreq; drop an IP group membership */
+
+/* For BSD compatibility.  */
+#define IP_RECVRETOPTS	IP_RETOPTS
+
+/* IP_MTU_DISCOVER arguments.  */
+#define IP_PMTUDISC_DONT   0	/* Never send DF frames.  */
+#define IP_PMTUDISC_WANT   1	/* Use per route hints.  */
+#define IP_PMTUDISC_DO     2	/* Always DF.  */
+
+/* To select the IP level.  */
+#define SOL_IP	0
+
+#define IP_DEFAULT_MULTICAST_TTL        1
+#define IP_DEFAULT_MULTICAST_LOOP       1
+#define IP_MAX_MEMBERSHIPS              20
+
+/* Structure used to describe IP options for IP_OPTIONS. The `ip_dst'
+   field is used for the first-hop gateway when using a source route
+   (this gets put into the header proper).  */
+struct ip_opts
+  {
+    struct in_addr ip_dst;	/* First hop; zero without source route.  */
+    char ip_opts[40];		/* Actually variable in size.  */
+  };
+
+/* Structure used for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP. */
+struct ip_mreq
+  {
+    struct in_addr imr_multiaddr;	/* IP multicast address of group */
+    struct in_addr imr_interface;	/* local IP address of interface */
+  };
+
+/* As above but including interface specification by index.  */
+struct ip_mreqn
+  {
+    struct in_addr imr_multiaddr;	/* IP multicast address of group */
+    struct in_addr imr_address;		/* local IP address of interface */
+    int	imr_ifindex;			/* Interface index */
+  };
+
+/* Structure used for IP_PKTINFO.  */
+struct in_pktinfo
+  {
+    int ipi_ifindex;			/* Interface index  */
+    struct in_addr ipi_spec_dst;	/* Routing destination address  */
+    struct in_addr ipi_addr;		/* Header destination address  */
+  };
+
+/* Options for use with `getsockopt' and `setsockopt' at the IPv6 level.
+   The first word in the comment at the right is the data type used;
+   "bool" means a boolean value stored in an `int'.  */
+#define IPV6_ADDRFORM		1
+#define IPV6_PKTINFO		2
+#define IPV6_HOPOPTS		3
+#define IPV6_DSTOPTS		4
+#define IPV6_RTHDR		5
+#define IPV6_PKTOPTIONS		6
+#define IPV6_CHECKSUM		7
+#define IPV6_HOPLIMIT		8
+#define IPV6_NEXTHOP		9
+#define IPV6_AUTHHDR		10
+#define IPV6_UNICAST_HOPS	16
+#define IPV6_MULTICAST_IF	17
+#define IPV6_MULTICAST_HOPS	18
+#define IPV6_MULTICAST_LOOP	19
+#define IPV6_JOIN_GROUP		20
+#define IPV6_LEAVE_GROUP	21
+#define IPV6_ROUTER_ALERT	22
+#define IPV6_MTU_DISCOVER	23
+#define IPV6_MTU		24
+#define IPV6_RECVERR		25
+
+#define SCM_SRCRT		IPV6_RXSRCRT
+
+/* Obsolete synonyms for the above.  */
+#define IPV6_RXHOPOPTS		IPV6_HOPOPTS
+#define IPV6_RXDSTOPTS		IPV6_DSTOPTS
+#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
+
+
+/* IPV6_MTU_DISCOVER values.  */
+#define IPV6_PMTUDISC_DONT	0	/* Never send DF frames.  */
+#define IPV6_PMTUDISC_WANT	1	/* Use per route hints.  */
+#define IPV6_PMTUDISC_DO	2	/* Always DF.  */
+
+/* Socket level values for IPv6.  */
+#define SOL_IPV6        41
+#define SOL_ICMPV6      58
+
+/* Routing header options for IPv6.  */
+#define IPV6_RTHDR_LOOSE	0	/* Hop doesn't need to be neighbour. */
+#define IPV6_RTHDR_STRICT	1	/* Hop must be a neighbour.  */
+
+#define IPV6_RTHDR_TYPE_0	0	/* IPv6 Routing header type 0.  */
diff -pruwN busybox-1.01/include2/bits/ioctls.h busybox-1.01-livebox/include2/bits/ioctls.h
--- busybox-1.01/include2/bits/ioctls.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/ioctls.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,108 @@
+/* Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IOCTL_H
+# error "Never use <bits/ioctls.h> directly; include <sys/ioctl.h> instead."
+#endif
+
+/* Use the definitions from the kernel header files.  */
+#include <asm/ioctls.h>
+
+/* Routing table calls.  */
+#define SIOCADDRT	0x890B		/* add routing table entry	*/
+#define SIOCDELRT	0x890C		/* delete routing table entry	*/
+#define SIOCRTMSG	0x890D		/* call to routing system	*/
+
+/* Socket configuration controls. */
+#define SIOCGIFNAME	0x8910		/* get iface name		*/
+#define SIOCSIFLINK	0x8911		/* set iface channel		*/
+#define SIOCGIFCONF	0x8912		/* get iface list		*/
+#define SIOCGIFFLAGS	0x8913		/* get flags			*/
+#define SIOCSIFFLAGS	0x8914		/* set flags			*/
+#define SIOCGIFADDR	0x8915		/* get PA address		*/
+#define SIOCSIFADDR	0x8916		/* set PA address		*/
+#define SIOCGIFDSTADDR	0x8917		/* get remote PA address	*/
+#define SIOCSIFDSTADDR	0x8918		/* set remote PA address	*/
+#define SIOCGIFBRDADDR	0x8919		/* get broadcast PA address	*/
+#define SIOCSIFBRDADDR	0x891a		/* set broadcast PA address	*/
+#define SIOCGIFNETMASK	0x891b		/* get network PA mask		*/
+#define SIOCSIFNETMASK	0x891c		/* set network PA mask		*/
+#define SIOCGIFMETRIC	0x891d		/* get metric			*/
+#define SIOCSIFMETRIC	0x891e		/* set metric			*/
+#define SIOCGIFMEM	0x891f		/* get memory address (BSD)	*/
+#define SIOCSIFMEM	0x8920		/* set memory address (BSD)	*/
+#define SIOCGIFMTU	0x8921		/* get MTU size			*/
+#define SIOCSIFMTU	0x8922		/* set MTU size			*/
+#define	SIOCSIFHWADDR	0x8924		/* set hardware address 	*/
+#define SIOCGIFENCAP	0x8925		/* get/set encapsulations       */
+#define SIOCSIFENCAP	0x8926
+#define SIOCGIFHWADDR	0x8927		/* Get hardware address		*/
+#define SIOCGIFSLAVE	0x8929		/* Driver slaving support	*/
+#define SIOCSIFSLAVE	0x8930
+#define SIOCADDMULTI	0x8931		/* Multicast address lists	*/
+#define SIOCDELMULTI	0x8932
+#define SIOCGIFINDEX	0x8933		/* name -> if_index mapping	*/
+#define SIOGIFINDEX	SIOCGIFINDEX	/* misprint compatibility :-)	*/
+#define SIOCSIFPFLAGS	0x8934		/* set/get extended flags set	*/
+#define SIOCGIFPFLAGS	0x8935
+#define SIOCDIFADDR	0x8936		/* delete PA address		*/
+#define	SIOCSIFHWBROADCAST	0x8937	/* set hardware broadcast addr	*/
+#define SIOCGIFCOUNT	0x8938		/* get number of devices */
+
+#define SIOCGIFBR	0x8940		/* Bridging support		*/
+#define SIOCSIFBR	0x8941		/* Set bridging options 	*/
+
+#define SIOCGIFTXQLEN	0x8942		/* Get the tx queue length	*/
+#define SIOCSIFTXQLEN	0x8943		/* Set the tx queue length 	*/
+
+
+/* ARP cache control calls. */
+		    /*  0x8950 - 0x8952  * obsolete calls, don't re-use */
+#define SIOCDARP	0x8953		/* delete ARP table entry	*/
+#define SIOCGARP	0x8954		/* get ARP table entry		*/
+#define SIOCSARP	0x8955		/* set ARP table entry		*/
+
+/* RARP cache control calls. */
+#define SIOCDRARP	0x8960		/* delete RARP table entry	*/
+#define SIOCGRARP	0x8961		/* get RARP table entry		*/
+#define SIOCSRARP	0x8962		/* set RARP table entry		*/
+
+/* Driver configuration calls */
+
+#define SIOCGIFMAP	0x8970		/* Get device parameters	*/
+#define SIOCSIFMAP	0x8971		/* Set device parameters	*/
+
+/* DLCI configuration calls */
+
+#define SIOCADDDLCI	0x8980		/* Create new DLCI device	*/
+#define SIOCDELDLCI	0x8981		/* Delete DLCI device		*/
+
+/* Device private ioctl calls.  */
+
+/* These 16 ioctls are available to devices via the do_ioctl() device
+   vector.  Each device should include this file and redefine these
+   names as their own. Because these are device dependent it is a good
+   idea _NOT_ to issue them to random objects and hope.  */
+
+#define SIOCDEVPRIVATE 		0x89F0	/* to 89FF */
+
+/*
+ *	These 16 ioctl calls are protocol private
+ */
+
+#define SIOCPROTOPRIVATE 0x89E0 /* to 89EF */
diff -pruwN busybox-1.01/include2/bits/ioctl-types.h busybox-1.01-livebox/include2/bits/ioctl-types.h
--- busybox-1.01/include2/bits/ioctl-types.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/ioctl-types.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,76 @@
+/* Structure types for pre-termios terminal ioctls.  Linux/MIPS version.
+   Copyright (C) 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IOCTL_H
+# error "Never use <bits/ioctl-types.h> directly; include <sys/ioctl.h> instead."
+#endif
+
+/* Get definition of constants for use with `ioctl'.  */
+#include <asm/ioctls.h>
+
+struct winsize
+  {
+    unsigned short int ws_row;
+    unsigned short int ws_col;
+    unsigned short int ws_xpixel;
+    unsigned short int ws_ypixel;
+  };
+
+#define NCC	8
+struct termio
+  {
+    unsigned short int c_iflag;		/* input mode flags */
+    unsigned short int c_oflag;		/* output mode flags */
+    unsigned short int c_cflag;		/* control mode flags */
+    unsigned short int c_lflag;		/* local mode flags */
+    char c_line;			/* line discipline */
+    /* Yes, this is really NCCS.  */
+    unsigned char c_cc[32 /* NCCS */]; /* control characters */
+  };
+
+/* modem lines */
+#define TIOCM_LE	0x001		/* line enable */
+#define TIOCM_DTR	0x002		/* data terminal ready */
+#define TIOCM_RTS	0x004		/* request to send */
+#define TIOCM_ST	0x010		/* secondary transmit */
+#define TIOCM_SR	0x020		/* secondary receive */
+#define TIOCM_CTS	0x040		/* clear to send */
+#define TIOCM_CAR	0x100		/* carrier detect */
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RNG	0x200		/* ring */
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_DSR	0x400		/* data set ready */
+
+/* line disciplines */
+#define N_TTY		0
+#define N_SLIP		1
+#define N_MOUSE		2
+#define N_PPP		3
+#define N_STRIP		4
+#define N_AX25		5
+#define N_X25		6	/* X.25 async  */
+#define N_6PACK		7
+#define N_MASC		8	/* Mobitex module  */
+#define N_R3964		9	/* Simatic R3964 module  */
+#define N_PROFIBUS_FDL	10	/* Profibus  */
+#define N_IRDA		11	/* Linux IR  */
+#define N_SMSBLOCK	12	/* SMS block mode  */
+#define N_HDLC		13	/* synchronous HDLC  */
+#define N_SYNC_PPP	14	/* synchronous PPP  */
+#define	N_HCI		15	/* Bluetooth HCI UART  */
diff -pruwN busybox-1.01/include2/bits/kernel_types.h busybox-1.01-livebox/include2/bits/kernel_types.h
--- busybox-1.01/include2/bits/kernel_types.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/kernel_types.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,79 @@
+/* Note that we use the exact same include guard #define names
+ * as asm/posix_types.h.  This will avoid gratuitous conflicts 
+ * with the posix_types.h kernel header, and will ensure that 
+ * our private content, and not the kernel header, will win.
+ *  -Erik
+ */
+#ifndef _ASM_POSIX_TYPES_H
+#define _ASM_POSIX_TYPES_H
+
+# if __WORDSIZE == 64
+typedef unsigned int	__kernel_dev_t;
+typedef unsigned int	__kernel_ino_t;
+typedef unsigned int	__kernel_mode_t;
+typedef unsigned int	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef int		__kernel_ipc_pid_t;
+typedef int		__kernel_uid_t;
+typedef int		__kernel_gid_t;
+typedef unsigned long	__kernel_size_t;
+typedef long		__kernel_ssize_t;
+typedef long		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef long		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef int		__kernel_uid32_t;
+typedef int		__kernel_gid32_t;
+typedef __kernel_uid_t	__kernel_old_uid_t;
+typedef __kernel_gid_t	__kernel_old_gid_t;
+typedef __kernel_dev_t	__kernel_old_dev_t;
+typedef long long      __kernel_loff_t;
+#else
+typedef unsigned int	__kernel_dev_t;
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned int	__kernel_mode_t;
+
+/* Linux 2.4.20 include/asm-mips/posix_types.h has this:
+but apparently that is an error?!?!?
+*/
+#if 0
+typedef int            __kernel_nlink_t;
+#else
+/* So use this instead */
+typedef unsigned long  __kernel_nlink_t;
+#endif
+
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef int		__kernel_ipc_pid_t;
+typedef int		__kernel_uid_t;
+typedef int		__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef long		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef int		__kernel_uid32_t;
+typedef int		__kernel_gid32_t;
+typedef __kernel_uid_t	__kernel_old_uid_t;
+typedef __kernel_gid_t	__kernel_old_gid_t;
+typedef __kernel_dev_t	__kernel_old_dev_t;
+typedef long long      __kernel_loff_t;
+#endif
+
+
+typedef struct {
+	long val[2];
+} __kernel_fsid_t;
+
+#endif /* _ASM_POSIX_TYPES_H */
diff -pruwN busybox-1.01/include2/bits/local_lim.h busybox-1.01-livebox/include2/bits/local_lim.h
--- busybox-1.01/include2/bits/local_lim.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/local_lim.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,77 @@
+/* Minimum guaranteed maximum values for system limits.  Linux version.
+   Copyright (C) 1993, 94, 95, 96, 97, 98, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* The kernel header pollutes the namespace with the NR_OPEN symbol
+   and defines LINK_MAX although filesystems have different maxima.  A
+   similar thing is true for OPEN_MAX: the limit can be changed at
+   runtime and therefore the macro must not be defined.  Remove this
+   after including the header if necessary.  */
+#ifndef NR_OPEN
+# define __undef_NR_OPEN
+#endif
+#ifndef LINK_MAX
+# define __undef_LINK_MAX
+#endif
+#ifndef OPEN_MAX
+# define __undef_OPEN_MAX
+#endif
+
+/* The kernel sources contain a file with all the needed information.  */
+#include <linux/limits.h>
+
+/* Have to remove NR_OPEN?  */
+#ifdef __undef_NR_OPEN
+# undef NR_OPEN
+# undef __undef_NR_OPEN
+#endif
+/* Have to remove LINK_MAX?  */
+#ifdef __undef_LINK_MAX
+# undef LINK_MAX
+# undef __undef_LINK_MAX
+#endif
+/* Have to remove OPEN_MAX?  */
+#ifdef __undef_OPEN_MAX
+# undef OPEN_MAX
+# undef __undef_OPEN_MAX
+#endif
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+/* This is the value this implementation supports.  */
+#define PTHREAD_KEYS_MAX	1024
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+/* Number of iterations this implementation does.  */
+#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
+/* This is the value this implementation supports.  */
+#define PTHREAD_THREADS_MAX	1024
+
+/* Maximum amount by which a process can descrease its asynchronous I/O
+   priority level.  */
+#define AIO_PRIO_DELTA_MAX	20
+
+/* Minimum size for a thread.  We are free to choose a reasonable value.  */
+#define PTHREAD_STACK_MIN	16384
+
+/* Maximum number of POSIX timers available.  */
+#define TIMER_MAX	256
diff -pruwN busybox-1.01/include2/bits/mman.h busybox-1.01-livebox/include2/bits/mman.h
--- busybox-1.01/include2/bits/mman.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/mman.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,86 @@
+/* Definitions for POSIX memory map interface.  Linux/MIPS version.
+   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0x00
+# define MAP_ANONYMOUS	0x0800		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+# define MAP_RENAME	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_NORESERVE	0x0400		/* don't check for reservations */
+# define MAP_ANONYMOUS	0x0800		/* don't use a file */
+# define MAP_GROWSDOWN	0x1000		/* stack-like segment */
+# define MAP_DENYWRITE	0x2000		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x4000		/* mark it as an executable */
+# define MAP_LOCKED	0x8000		/* pages are locked */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+#define MADV_NORMAL	0		/* default page-in behavior */
+#define MADV_RANDOM	1		/* page-in minimum required */
+#define MADV_SEQUENTIAL	2		/* read-ahead aggressively */
+#define MADV_WILLNEED	3		/* pre-fault pages */
+#define MADV_DONTNEED	4		/* discard these pages */
+#endif
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+#endif
diff -pruwN busybox-1.01/include2/bits/netdb.h busybox-1.01-livebox/include2/bits/netdb.h
--- busybox-1.01/include2/bits/netdb.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/netdb.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,33 @@
+/* Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _NETDB_H
+# error "Never include <bits/netdb.h> directly; use <netdb.h> instead."
+#endif
+
+
+/* Description of data base entry for a single network.  NOTE: here a
+   poor assumption is made.  The network number is expected to fit
+   into an unsigned long int variable.  */
+struct netent
+{
+  char *n_name;			/* Official name of network.  */
+  char **n_aliases;		/* Alias list.  */
+  int n_addrtype;		/* Net address type.  */
+  uint32_t n_net;		/* Network number.  */
+};
diff -pruwN busybox-1.01/include2/bits/posix1_lim.h busybox-1.01-livebox/include2/bits/posix1_lim.h
--- busybox-1.01/include2/bits/posix1_lim.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/posix1_lim.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,145 @@
+/* Copyright (C) 1991-1993,96,98,2000,01,02,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
+ *
+ *	Never include this file directly; use <limits.h> instead.
+ */
+
+#ifndef	_BITS_POSIX1_LIM_H
+#define	_BITS_POSIX1_LIM_H	1
+
+
+/* These are the standard-mandated minimum values.  */
+
+/* Minimum number of operations in one list I/O call.  */
+#define _POSIX_AIO_LISTIO_MAX	2
+
+/* Minimal number of outstanding asynchronous I/O operations.  */
+#define _POSIX_AIO_MAX		1
+
+/* Maximum length of arguments to `execve', including environment.  */
+#define	_POSIX_ARG_MAX		4096
+
+/* Maximum simultaneous processes per real user ID.  */
+#define	_POSIX_CHILD_MAX	6
+
+/* Minimal number of timer expiration overruns.  */
+#define _POSIX_DELAYTIMER_MAX	32
+
+/* Maximum link count of a file.  */
+#define	_POSIX_LINK_MAX		8
+
+/* Number of bytes in a terminal canonical input queue.  */
+#define	_POSIX_MAX_CANON	255
+
+/* Number of bytes for which space will be
+   available in a terminal input queue.  */
+#define	_POSIX_MAX_INPUT	255
+
+/* Maximum number of message queues open for a process.  */
+#define _POSIX_MQ_OPEN_MAX	8
+
+/* Maximum number of supported message priorities.  */
+#define _POSIX_MQ_PRIO_MAX	32
+
+/* Number of simultaneous supplementary group IDs per process.  */
+#ifdef __USE_XOPEN2K
+# define _POSIX_NGROUPS_MAX	8
+#else
+# define _POSIX_NGROUPS_MAX	0
+#endif
+
+/* Number of files one process can have open at once.  */
+#define	_POSIX_OPEN_MAX		16
+
+/* Number of descriptors that a process may examine with `pselect' or
+   `select'.  */
+#define	_POSIX_FD_SETSIZE	_POSIX_OPEN_MAX
+
+/* Number of bytes in a filename.  */
+#define	_POSIX_NAME_MAX		14
+
+/* Number of bytes in a pathname.  */
+#define	_POSIX_PATH_MAX		256
+
+/* Number of bytes than can be written atomically to a pipe.  */
+#define	_POSIX_PIPE_BUF		512
+
+/* Minimal number of realtime signals reserved for the application.  */
+#define _POSIX_RTSIG_MAX	8
+
+/* Number of semaphores a process can have.  */
+#define _POSIX_SEM_NSEMS_MAX	256
+
+/* Maximal value of a semaphore.  */
+#define _POSIX_SEM_VALUE_MAX	32767
+
+/* Number of pending realtime signals.  */
+#define _POSIX_SIGQUEUE_MAX	32
+
+/* Largest value of a `ssize_t'.  */
+#define	_POSIX_SSIZE_MAX	32767
+
+/* Number of streams a process can have open at once.  */
+#define	_POSIX_STREAM_MAX	8
+
+/* Maximum length of a timezone name (element of `tzname').  */
+#define	_POSIX_TZNAME_MAX	6
+
+/* Maximum number of connections that can be queued on a socket.  */
+#define	_POSIX_QLIMIT		1
+
+/* Maximum number of bytes that can be buffered on a socket for send
+   or receive.  */
+#define	_POSIX_HIWAT		_POSIX_PIPE_BUF
+
+/* Maximum number of elements in an `iovec' array.  */
+#define	_POSIX_UIO_MAXIOV	16
+
+/* Maximum number of characters in a tty name.  */
+#define	_POSIX_TTY_NAME_MAX	9
+
+/* Number of timer for a process.  */
+#define _POSIX_TIMER_MAX	32
+
+/* Maximum length of login name.  */
+#define	_POSIX_LOGIN_NAME_MAX	9
+
+/* Maximum clock resolution in nanoseconds.  */
+#define _POSIX_CLOCKRES_MIN	20000000
+
+
+/* Get the implementation-specific values for the above.  */
+#include <bits/local_lim.h>
+
+
+#ifndef	SSIZE_MAX
+# define SSIZE_MAX	LONG_MAX
+#endif
+
+
+/* This value is a guaranteed minimum maximum.
+   The current maximum can be got from `sysconf'.  */
+
+#ifndef	NGROUPS_MAX
+# define NGROUPS_MAX	8
+#endif
+
+#endif	/* bits/posix1_lim.h  */
diff -pruwN busybox-1.01/include2/bits/posix2_lim.h busybox-1.01-livebox/include2/bits/posix2_lim.h
--- busybox-1.01/include2/bits/posix2_lim.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/posix2_lim.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,91 @@
+/* Copyright (C) 1991, 1996, 1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; include <limits.h> instead.
+ */
+
+#ifndef	_BITS_POSIX2_LIM_H
+#define	_BITS_POSIX2_LIM_H	1
+
+
+/* The maximum `ibase' and `obase' values allowed by the `bc' utility.  */
+#define	_POSIX2_BC_BASE_MAX		99
+
+/* The maximum number of elements allowed in an array by the `bc' utility.  */
+#define	_POSIX2_BC_DIM_MAX		2048
+
+/* The maximum `scale' value allowed by the `bc' utility.  */
+#define	_POSIX2_BC_SCALE_MAX		99
+
+/* The maximum length of a string constant accepted by the `bc' utility.  */
+#define	_POSIX2_BC_STRING_MAX		1000
+
+/* The maximum number of weights that can be assigned to an entry of
+   the LC_COLLATE `order' keyword in the locale definition file.  */
+#define	_POSIX2_COLL_WEIGHTS_MAX	2
+
+/* The maximum number of expressions that can be nested
+   within parentheses by the `expr' utility.  */
+#define	_POSIX2_EXPR_NEST_MAX		32
+
+/* The maximum length, in bytes, of an input line.  */
+#define	_POSIX2_LINE_MAX		2048
+
+/* The maximum number of repeated occurrences of a regular expression
+   permitted when using the interval notation `\{M,N\}'.  */
+#define	_POSIX2_RE_DUP_MAX		255
+
+/* The maximum number of bytes in a character class name.  We have no
+   fixed limit, 2048 is a high number.  */
+#define	_POSIX2_CHARCLASS_NAME_MAX	14
+
+
+/* These values are implementation-specific,
+   and may vary within the implementation.
+   Their precise values can be obtained from sysconf.  */
+
+#ifndef	BC_BASE_MAX
+#define	BC_BASE_MAX		_POSIX2_BC_BASE_MAX
+#endif
+#ifndef	BC_DIM_MAX
+#define	BC_DIM_MAX		_POSIX2_BC_DIM_MAX
+#endif
+#ifndef	BC_SCALE_MAX
+#define	BC_SCALE_MAX		_POSIX2_BC_SCALE_MAX
+#endif
+#ifndef	BC_STRING_MAX
+#define	BC_STRING_MAX		_POSIX2_BC_STRING_MAX
+#endif
+#ifndef	COLL_WEIGHTS_MAX
+#define	COLL_WEIGHTS_MAX	255
+#endif
+#ifndef	EXPR_NEST_MAX
+#define	EXPR_NEST_MAX		_POSIX2_EXPR_NEST_MAX
+#endif
+#ifndef	LINE_MAX
+#define	LINE_MAX		_POSIX2_LINE_MAX
+#endif
+#ifndef	CHARCLASS_NAME_MAX
+#define	CHARCLASS_NAME_MAX	2048
+#endif
+
+/* This value is defined like this in regex.h.  */
+#define	RE_DUP_MAX (0x7fff)
+
+#endif	/* bits/posix2_lim.h */
diff -pruwN busybox-1.01/include2/bits/posix_opt.h busybox-1.01-livebox/include2/bits/posix_opt.h
--- busybox-1.01/include2/bits/posix_opt.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/posix_opt.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,192 @@
+/* Define POSIX options for Linux.
+   Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef	_POSIX_OPT_H
+#define	_POSIX_OPT_H	1
+
+/* Job control is supported.  */
+#define	_POSIX_JOB_CONTROL	1
+
+/* Processes have a saved set-user-ID and a saved set-group-ID.  */
+#define	_POSIX_SAVED_IDS	1
+
+/* Priority scheduling is supported.  */
+#define	_POSIX_PRIORITY_SCHEDULING	1
+
+/* Synchronizing file data is supported.  */
+#define	_POSIX_SYNCHRONIZED_IO	1
+
+/* The fsync function is present.  */
+#define	_POSIX_FSYNC	1
+
+/* Mapping of files to memory is supported.  */
+#define	_POSIX_MAPPED_FILES	1
+
+/* Locking of all memory is supported.  */
+#ifdef __ARCH_HAS_MMU__
+# define	_POSIX_MEMLOCK	1
+#else
+# undef		_POSIX_MEMLOCK
+#endif
+
+/* Locking of ranges of memory is supported.  */
+#ifdef __ARCH_HAS_MMU__
+# define	_POSIX_MEMLOCK_RANGE	1
+#else
+# define	_POSIX_MEMLOCK_RANGE
+#endif
+
+/* Setting of memory protections is supported.  */
+#ifdef __ARCH_HAS_MMU__
+# define	_POSIX_MEMORY_PROTECTION	1
+#else
+# undef		_POSIX_MEMORY_PROTECTION
+#endif
+
+/* Implementation supports `poll' function.  */
+#define	_POSIX_POLL	1
+
+/* Implementation supports `select' and `pselect' functions.  */
+#define	_POSIX_SELECT	1
+
+/* Only root can change owner of file.  */
+#define	_POSIX_CHOWN_RESTRICTED	1
+
+/* `c_cc' member of 'struct termios' structure can be disabled by
+   using the value _POSIX_VDISABLE.  */
+#define	_POSIX_VDISABLE	'\0'
+
+/* Filenames are not silently truncated.  */
+#define	_POSIX_NO_TRUNC	1
+
+/* X/Open realtime support is available.  */
+#define _XOPEN_REALTIME	1
+
+/* X/Open realtime thread support is available.  */
+#ifdef __UCLIBC_HAS_THREADS__
+# define _XOPEN_REALTIME_THREADS	1
+#else
+# undef _XOPEN_REALTIME_THREADS
+#endif
+
+/* XPG4.2 shared memory is supported.  */
+#define	_XOPEN_SHM	1
+
+/* Tell we have POSIX threads.  */
+#ifdef __UCLIBC_HAS_THREADS__
+# define _POSIX_THREADS	1
+#else
+# undef _POSIX_THREADS
+#endif
+
+/* We have the reentrant functions described in POSIX.  */
+#ifdef __UCLIBC_HAS_THREADS__
+# define _POSIX_REENTRANT_FUNCTIONS      1
+# define _POSIX_THREAD_SAFE_FUNCTIONS	1
+#else
+# undef _POSIX_REENTRANT_FUNCTIONS
+# undef _POSIX_THREAD_SAFE_FUNCTIONS
+#endif
+
+/* We provide priority scheduling for threads.  */
+#define	_POSIX_THREAD_PRIORITY_SCHEDULING	1
+
+/* We support user-defined stack sizes.  */
+#define _POSIX_THREAD_ATTR_STACKSIZE	1
+
+/* We support user-defined stacks.  */
+#define _POSIX_THREAD_ATTR_STACKADDR	1
+
+/* We support POSIX.1b semaphores, but only the non-shared form for now.  */
+#ifdef __UCLIBC_HAS_THREADS__
+# define _POSIX_SEMAPHORES	1
+#else
+# undef _POSIX_SEMAPHORES
+#endif
+
+/* Real-time signals are supported.  */
+#define _POSIX_REALTIME_SIGNALS	1
+
+/* We support asynchronous I/O.  */
+#define _POSIX_ASYNCHRONOUS_IO	1
+#define _POSIX_ASYNC_IO		1
+/* Alternative name for Unix98.  */
+#define _LFS_ASYNCHRONOUS_IO	1
+
+/* The LFS support in asynchronous I/O is also available.  */
+#ifdef __UCLIBC_HAS_LFS__
+# define _LFS64_ASYNCHRONOUS_IO	1
+#else
+# undef _LFS64_ASYNCHRONOUS_IO
+#endif
+
+/* The rest of the LFS is also available.  */
+#ifdef __UCLIBC_HAS_LFS__
+# define _LFS_LARGEFILE		1
+# define _LFS64_LARGEFILE	1
+# define _LFS64_STDIO		1
+#else
+# undef _LFS_LARGEFILE
+# undef _LFS64_LARGEFILE
+# undef _LFS64_STDIO
+#endif
+
+/* POSIX shared memory objects are implemented.  */
+#define _POSIX_SHARED_MEMORY_OBJECTS	1
+
+/* GNU libc provides regular expression handling.  */
+#ifdef __UCLIBC_HAS_REGEX__
+# define _POSIX_REGEXP	1
+#else
+# undef _POSIX_REGEXP
+#endif
+
+#if defined(__i386__)
+/* CPU-time clocks supported.  */
+#define _POSIX_CPUTIME 200912L
+
+/* We support the clock also in threads.  */
+#define _POSIX_THREAD_CPUTIME  200912L
+#endif
+
+/* Reader/Writer locks are available.  */
+#define _POSIX_READER_WRITER_LOCKS	200912L
+
+/* We have a POSIX shell.  */
+#define _POSIX_SHELL	1
+
+/* We support the Timeouts option.  */
+#define _POSIX_TIMEOUTS	200912L
+
+/* We support spinlocks.  */
+#define _POSIX_SPIN_LOCKS	200912L
+
+/* The `spawn' function family is supported.  */
+#define _POSIX_SPAWN	200912L
+
+/* We have POSIX timers.  */
+#define _POSIX_TIMERS	1
+
+/* The barrier functions are available.  */
+#define _POSIX_BARRIERS	200912L
+
+/* POSIX message queues are not yet supported.  */
+#undef	_POSIX_MESSAGE_PASSING
+
+#endif /* posix_opt.h */
diff -pruwN busybox-1.01/include2/bits/pthreadtypes.h busybox-1.01-livebox/include2/bits/pthreadtypes.h
--- busybox-1.01/include2/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/pthreadtypes.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,142 @@
+/* Linuxthreads - a simple clone()-based implementation of Posix        */
+/* threads for Linux.                                                   */
+/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
+/*                                                                      */
+/* This program is free software; you can redistribute it and/or        */
+/* modify it under the terms of the GNU Library General Public License  */
+/* as published by the Free Software Foundation; either version 2       */
+/* of the License, or (at your option) any later version.               */
+/*                                                                      */
+/* This program is distributed in the hope that it will be useful,      */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
+/* GNU Library General Public License for more details.                 */
+
+#if !defined _BITS_TYPES_H && !defined _PTHREAD_H
+# error "Never include <bits/pthreadtypes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#define __need_schedparam
+#include <bits/sched.h>
+
+/* Fast locks (not abstract because mutexes and conditions aren't abstract). */
+struct _pthread_fastlock
+{
+  long int __status;   /* "Free" or "taken" or head of waiting list */
+  int __spinlock;      /* Used by compare_and_swap emulation. Also,
+			  adaptive SMP lock stores spin count here. */
+};
+
+#ifndef _PTHREAD_DESCR_DEFINED
+/* Thread descriptors */
+typedef struct _pthread_descr_struct *_pthread_descr;
+# define _PTHREAD_DESCR_DEFINED
+#endif
+
+
+/* Attributes for threads.  */
+typedef struct __pthread_attr_s
+{
+  int __detachstate;
+  int __schedpolicy;
+  struct __sched_param __schedparam;
+  int __inheritsched;
+  int __scope;
+  size_t __guardsize;
+  int __stackaddr_set;
+  void *__stackaddr;
+  size_t __stacksize;
+} pthread_attr_t;
+
+
+/* Conditions (not abstract because of PTHREAD_COND_INITIALIZER */
+typedef struct
+{
+  struct _pthread_fastlock __c_lock; /* Protect against concurrent access */
+  _pthread_descr __c_waiting;        /* Threads waiting on this condition */
+} pthread_cond_t;
+
+
+/* Attribute for conditionally variables.  */
+typedef struct
+{
+  int __dummy;
+} pthread_condattr_t;
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Mutexes (not abstract because of PTHREAD_MUTEX_INITIALIZER).  */
+/* (The layout is unnatural to maintain binary compatibility
+    with earlier releases of LinuxThreads.) */
+typedef struct
+{
+  int __m_reserved;               /* Reserved for future use */
+  int __m_count;                  /* Depth of recursive locking */
+  _pthread_descr __m_owner;       /* Owner thread (if recursive or errcheck) */
+  int __m_kind;                   /* Mutex kind: fast, recursive or errcheck */
+  struct _pthread_fastlock __m_lock; /* Underlying fast lock */
+} pthread_mutex_t;
+
+
+/* Attribute for mutex.  */
+typedef struct
+{
+  int __mutexkind;
+} pthread_mutexattr_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#ifdef __USE_UNIX98
+/* Read-write locks.  */
+typedef struct _pthread_rwlock_t
+{
+  struct _pthread_fastlock __rw_lock; /* Lock to guarantee mutual exclusion */
+  int __rw_readers;                   /* Number of readers */
+  _pthread_descr __rw_writer;         /* Identity of writer, or NULL if none */
+  _pthread_descr __rw_read_waiting;   /* Threads waiting for reading */
+  _pthread_descr __rw_write_waiting;  /* Threads waiting for writing */
+  int __rw_kind;                      /* Reader/Writer preference selection */
+  int __rw_pshared;                   /* Shared between processes or not */
+} pthread_rwlock_t;
+
+
+/* Attribute for read-write locks.  */
+typedef struct
+{
+  int __lockkind;
+  int __pshared;
+} pthread_rwlockattr_t;
+#endif
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+/* POSIX barrier. */
+typedef struct {
+  struct _pthread_fastlock __ba_lock; /* Lock to guarantee mutual exclusion */
+  int __ba_required;                  /* Threads needed for completion */
+  int __ba_present;                   /* Threads waiting */
+  _pthread_descr __ba_waiting;        /* Queue of waiting threads */
+} pthread_barrier_t;
+
+/* barrier attribute */
+typedef struct {
+  int __pshared;
+} pthread_barrierattr_t;
+
+#endif
+
+
+/* Thread identifiers */
+typedef unsigned long int pthread_t;
+
+#endif	/* bits/pthreadtypes.h */
diff -pruwN busybox-1.01/include2/bits/resource.h busybox-1.01-livebox/include2/bits/resource.h
--- busybox-1.01/include2/bits/resource.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/resource.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,208 @@
+/* Bit values & structures for resource limits.  Linux/MIPS version.
+   Copyright (C) 1994,1996,1997,1998,1999,2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  RLIMIT_RSS = 7,
+#define	RLIMIT_RSS RLIMIT_RSS
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 5,
+  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+#define RLIMIT_NOFILE RLIMIT_NOFILE
+#define RLIMIT_OFILE RLIMIT_OFILE
+
+  /* Address space limit (?) */
+  RLIMIT_AS = 6,
+#define RLIMIT_AS RLIMIT_AS
+
+  /* Number of processes.  */
+  RLIMIT_NPROC = 8,
+#define RLIMIT_NPROC RLIMIT_NPROC
+
+  /* Locked-in-memory address space.  */
+  RLIMIT_MEMLOCK = 9,
+#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
+
+  /* Maximum number of file locks.  */
+  RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS RLIMIT_LOCKS
+
+  RLIM_NLIMITS = 11
+#define RLIMIT_NLIMITS RLIMIT_NLIMITS
+#define RLIM_NLIMITS RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((long int)(~0UL >> 1))
+#else
+# define RLIM_INFINITY 0x7fffffffffffffffLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0x7fffffffffffffffLL
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1,
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+
+  /* Both.  */
+  RUSAGE_BOTH = -2
+#define RUSAGE_BOTH RUSAGE_BOTH
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
diff -pruwN busybox-1.01/include2/bits/sched.h busybox-1.01-livebox/include2/bits/sched.h
--- busybox-1.01/include2/bits/sched.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/sched.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,73 @@
+/* Definitions of constants and data structure for POSIX 1003.1b-1993
+   scheduling interface.
+   Copyright (C) 1996, 1997, 1998, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __need_schedparam
+
+#ifndef _SCHED_H
+# error "Never include <bits/sched.h> directly; use <sched.h> instead."
+#endif
+
+
+/* Scheduling algorithms.  */
+#define SCHED_OTHER	0
+#define SCHED_FIFO	1
+#define SCHED_RR	2
+
+#ifdef __USE_MISC
+/* Cloning flags.  */
+# define CSIGNAL       0x000000ff /* Signal mask to be sent at exit.  */
+# define CLONE_VM      0x00000100 /* Set if VM shared between processes.  */
+# define CLONE_FS      0x00000200 /* Set if fs info shared between processes.  */
+# define CLONE_FILES   0x00000400 /* Set if open files shared between processes.  */
+# define CLONE_SIGHAND 0x00000800 /* Set if signal handlers shared.  */
+# define CLONE_PID     0x00001000 /* Set if pid shared.  */
+# define CLONE_PTRACE  0x00002000 /* Set if tracing continues on the child.  */
+# define CLONE_VFORK   0x00004000 /* Set if the parent wants the child to
+				     wake it up on mm_release.  */
+#endif
+
+/* The official definition.  */
+struct sched_param
+  {
+    int __sched_priority;
+  };
+
+__BEGIN_DECLS
+
+/* Clone current process.  */
+#ifdef __USE_MISC
+extern int clone (int (*__fn) (void *__arg), void *__child_stack,
+		  int __flags, void *__arg) __THROW;
+#endif
+
+__END_DECLS
+
+#endif	/* need schedparam */
+
+#if !defined __defined_schedparam \
+    && (defined __need_schedparam || defined _SCHED_H)
+# define __defined_schedparam	1
+/* Data structure to describe a process' schedulability.  */
+struct __sched_param
+  {
+    int __sched_priority;
+  };
+# undef __need_schedparam
+#endif
diff -pruwN busybox-1.01/include2/bits/select.h busybox-1.01-livebox/include2/bits/select.h
--- busybox-1.01/include2/bits/select.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/select.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,35 @@
+/* Copyright (C) 1997, 1998, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SELECT_H
+# error "Never use <bits/select.h> directly; include <sys/select.h> instead."
+#endif
+
+
+/* We don't use `memset' because this would require a prototype and
+   the array isn't too big.  */
+#define __FD_ZERO(s) \
+  do {									      \
+    unsigned int __i;							      \
+    fd_set *__arr = (s);						      \
+    for (__i = 0; __i < sizeof (fd_set) / sizeof (__fd_mask); ++__i)	      \
+      __FDS_BITS (__arr)[__i] = 0;					      \
+  } while (0)
+#define __FD_SET(d, s)     (__FDS_BITS (s)[__FDELT(d)] |= __FDMASK(d))
+#define __FD_CLR(d, s)     (__FDS_BITS (s)[__FDELT(d)] &= ~__FDMASK(d))
+#define __FD_ISSET(d, s)   ((__FDS_BITS (s)[__FDELT(d)] & __FDMASK(d)) != 0)
diff -pruwN busybox-1.01/include2/bits/setjmp.h busybox-1.01-livebox/include2/bits/setjmp.h
--- busybox-1.01/include2/bits/setjmp.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/setjmp.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,57 @@
+/* Define the machine-dependent type `jmp_buf'.  MIPS version.
+   Copyright (C) 1992,93,95,97,2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SETJMP_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+typedef struct
+  {
+    /* Program counter.  */
+    void * __pc;
+
+    /* Stack pointer.  */
+    void * __sp;
+
+    /* Callee-saved registers s0 through s7.  */
+    int __regs[8];
+
+    /* The frame pointer.  */
+    void * __fp;
+
+    /* The global pointer.  */
+    void * __gp;
+
+    /* Floating point status register.  */
+    int __fpc_csr;
+
+    /* Callee-saved floating point registers.  */
+    double __fpregs[6];
+  } __jmp_buf[1];
+
+#ifdef __USE_MISC
+/* Offset to the program counter in `jmp_buf'.  */
+# define JB_PC	0
+#endif
+
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *) (address) < (jmpbuf)[0].__sp)
diff -pruwN busybox-1.01/include2/bits/sigaction.h busybox-1.01-livebox/include2/bits/sigaction.h
--- busybox-1.01/include2/bits/sigaction.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/sigaction.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,89 @@
+/* The proper definitions for Linux/MIPS's sigaction.
+   Copyright (C) 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2003
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SIGNAL_H
+# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
+#endif
+
+/* Structure describing the action to be taken when a signal arrives.  */
+struct sigaction
+  {
+    /* Special flags.  */
+    unsigned int sa_flags;
+
+    /* Signal handler.  */
+#ifdef __USE_POSIX199309
+    union
+      {
+	/* Used if SA_SIGINFO is not set.  */
+	__sighandler_t sa_handler;
+	/* Used if SA_SIGINFO is set.  */
+	void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+# define sa_handler    __sigaction_handler.sa_handler
+# define sa_sigaction  __sigaction_handler.sa_sigaction
+#else
+    __sighandler_t sa_handler;
+#endif
+    /* Additional set of signals to be blocked.  */
+    __sigset_t sa_mask;
+
+    /* The ABI says here are two unused ints following. */
+    /* Restore handler.  */
+    void (*sa_restorer) (void);
+
+#if _MIPS_SZPTR < 64
+    int sa_resv[1];
+#endif
+  };
+
+/* Bits in `sa_flags'.  */
+/* Please note that some Linux kernels versions use different values for these
+   flags which is a bug in those kernel versions.  */
+#define SA_NOCLDSTOP  0x00000001 /* Don't send SIGCHLD when children stop.  */
+#define SA_NOCLDWAIT  0x00010000 /* Don't create zombie on child death.  */
+#define SA_SIGINFO    0x00000008 /* Invoke signal-catching function with
+				    three arguments instead of one.  */
+#if defined __USE_UNIX98 || defined __USE_MISC
+# define SA_ONSTACK   0x08000000 /* Use signal stack by using `sa_restorer'. */
+# define SA_RESETHAND 0x80000000 /* Reset to SIG_DFL on entry to handler.  */
+# define SA_RESTART   0x10000000 /* Restart syscall on signal return.  */
+# define SA_NODEFER   0x40000000 /* Don't automatically block the signal when
+				    its handler is being executed.  */
+#endif
+#ifdef __USE_MISC
+# define SA_INTERRUPT 0x20000000 /* Historical no-op.  */
+
+/* Some aliases for the SA_ constants.  */
+# define SA_NOMASK    SA_NODEFER
+# define SA_ONESHOT   SA_RESETHAND
+# define SA_STACK     SA_ONSTACK
+#endif
+
+/* Values for the HOW argument to `sigprocmask'.  */
+#define SIG_NOP	      0		/* 0 is unused to catch errors */
+#define	SIG_BLOCK     1		/* Block signals.  */
+#define	SIG_UNBLOCK   2		/* Unblock signals.  */
+#define	SIG_SETMASK   3		/* Set the set of blocked signals.  */
+#ifdef __USE_MISC
+# define SIG_SETMASK32 256	/* Goodie from SGI for BSD compatibility:
+				   set only the low 32 bit of the sigset.  */
+#endif
diff -pruwN busybox-1.01/include2/bits/sigcontext.h busybox-1.01-livebox/include2/bits/sigcontext.h
--- busybox-1.01/include2/bits/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/sigcontext.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,29 @@
+/* Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef sigcontext_struct
+/* Kernel headers before 2.1.1 define a struct sigcontext_struct, but
+   we need sigcontext.  */
+# define sigcontext_struct sigcontext
+
+# include <asm/sigcontext.h>
+#endif
diff -pruwN busybox-1.01/include2/bits/siginfo.h busybox-1.01-livebox/include2/bits/siginfo.h
--- busybox-1.01/include2/bits/siginfo.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/siginfo.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,297 @@
+/* siginfo_t, sigevent and constants.  Linux/MIPS version.
+   Copyright (C) 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined __need_siginfo_t \
+    && !defined __need_sigevent_t
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+#if (!defined __have_sigval_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t \
+	 || defined __need_sigevent_t))
+# define __have_sigval_t	1
+
+/* Type for data associated with a signal.  */
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+#endif
+
+#if (!defined __have_siginfo_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t))
+# define __have_siginfo_t	1
+
+# define __SI_MAX_SIZE     128
+# define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 3)
+
+typedef struct siginfo
+  {
+    int si_signo;		/* Signal number.  */
+    int si_code;		/* Signal code.  */
+    int si_errno;		/* If non-zero, an errno value associated with
+				   this signal, as defined in <errno.h>.  */
+
+    union
+      {
+	int _pad[__SI_PAD_SIZE];
+
+	 /* kill().  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	  } _kill;
+
+	/* SIGCHLD.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Which child.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    int si_status;	/* Exit value or signal.  */
+	    __clock_t si_utime;
+	    __clock_t si_stime;
+	  } _sigchld;
+
+	/* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
+	struct
+	  {
+	    void *si_addr;	/* Faulting insn/memory ref.  */
+	  } _sigfault;
+
+	/* SIGPOLL.  */
+	struct
+	  {
+	    int si_band;	/* Band event for SIGPOLL.  */
+	    int si_fd;
+	  } _sigpoll;
+
+	/* POSIX.1b timers.  */
+	struct
+	  {
+	    unsigned int _timer1;
+	    unsigned int _timer2;
+	  } _timer;
+
+	/* POSIX.1b signals.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    sigval_t si_sigval;	/* Signal value.  */
+	  } _rt;
+      } _sifields;
+  } siginfo_t;
+
+
+/* X/Open requires some more fields with fixed names.  */
+# define si_pid		_sifields._kill.si_pid
+# define si_uid		_sifields._kill.si_uid
+# define si_status	_sifields._sigchld.si_status
+# define si_utime	_sifields._sigchld.si_utime
+# define si_stime	_sifields._sigchld.si_stime
+# define si_value	_sifields._rt.si_sigval
+# define si_int		_sifields._rt.si_sigval.sival_int
+# define si_ptr		_sifields._rt.si_sigval.sival_ptr
+# define si_addr	_sifields._sigfault.si_addr
+# define si_band	_sifields._sigpoll.si_band
+# define si_fd		_sifields._sigpoll.si_fd
+
+
+/* Values for `si_code'.  Positive values are reserved for kernel-generated
+   signals.  */
+enum
+{
+  SI_ASYNCNL = -6,		/* Sent by asynch name lookup completion.  */
+# define SI_ASYNCNL	SI_ASYNCNL
+  SI_SIGIO,			/* Sent by queued SIGIO. */
+# define SI_SIGIO	SI_SIGIO
+  SI_MESGQ,			/* Sent by real time mesq state change.  */
+# define SI_MESGQ	SI_MESGQ
+  SI_TIMER,			/* Sent by real time mesq state change.  */
+# define SI_TIMER	SI_TIMER
+  SI_ASYNCIO,			/* Sent by AIO completion.  */
+# define SI_ASYNCIO	SI_ASYNCIO
+  SI_QUEUE,			/* Sent by sigqueue.  */
+# define SI_QUEUE	SI_QUEUE
+  SI_USER,			/* Sent by kill, sigsend, raise.  */
+# define SI_USER	SI_USER
+  SI_KERNEL = 0x80		/* Send by kernel.  */
+#define SI_KERNEL	SI_KERNEL
+};
+
+
+/* `si_code' values for SIGILL signal.  */
+enum
+{
+  ILL_ILLOPC = 1,		/* Illegal opcode.  */
+# define ILL_ILLOPC	ILL_ILLOPC
+  ILL_ILLOPN,			/* Illegal operand.  */
+# define ILL_ILLOPN	ILL_ILLOPN
+  ILL_ILLADR,			/* Illegal addressing mode.  */
+# define ILL_ILLADR	ILL_ILLADR
+  ILL_ILLTRP,			/* Illegal trap. */
+# define ILL_ILLTRP	ILL_ILLTRP
+  ILL_PRVOPC,			/* Privileged opcode.  */
+# define ILL_PRVOPC	ILL_PRVOPC
+  ILL_PRVREG,			/* Privileged register.  */
+# define ILL_PRVREG	ILL_PRVREG
+  ILL_COPROC,			/* Coprocessor error.  */
+# define ILL_COPROC	ILL_COPROC
+  ILL_BADSTK			/* Internal stack error.  */
+# define ILL_BADSTK	ILL_BADSTK
+};
+
+/* `si_code' values for SIGFPE signal.  */
+enum
+{
+  FPE_INTDIV = 1,		/* Integer divide by zero.  */
+# define FPE_INTDIV	FPE_INTDIV
+  FPE_INTOVF,			/* Integer overflow.  */
+# define FPE_INTOVF	FPE_INTOVF
+  FPE_FLTDIV,			/* Floating point divide by zero.  */
+# define FPE_FLTDIV	FPE_FLTDIV
+  FPE_FLTOVF,			/* Floating point overflow.  */
+# define FPE_FLTOVF	FPE_FLTOVF
+  FPE_FLTUND,			/* Floating point underflow.  */
+# define FPE_FLTUND	FPE_FLTUND
+  FPE_FLTRES,			/* Floating point inexact result.  */
+# define FPE_FLTRES	FPE_FLTRES
+  FPE_FLTINV,			/* Floating point invalid operation.  */
+# define FPE_FLTINV	FPE_FLTINV
+  FPE_FLTSUB			/* Subscript out of range.  */
+# define FPE_FLTSUB	FPE_FLTSUB
+};
+
+/* `si_code' values for SIGSEGV signal.  */
+enum
+{
+  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
+# define SEGV_MAPERR	SEGV_MAPERR
+  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
+# define SEGV_ACCERR	SEGV_ACCERR
+};
+
+/* `si_code' values for SIGBUS signal.  */
+enum
+{
+  BUS_ADRALN = 1,		/* Invalid address alignment.  */
+# define BUS_ADRALN	BUS_ADRALN
+  BUS_ADRERR,			/* Non-existant physical address.  */
+# define BUS_ADRERR	BUS_ADRERR
+  BUS_OBJERR			/* Object specific hardware error.  */
+# define BUS_OBJERR	BUS_OBJERR
+};
+
+/* `si_code' values for SIGTRAP signal.  */
+enum
+{
+  TRAP_BRKPT = 1,		/* Process breakpoint.  */
+# define TRAP_BRKPT	TRAP_BRKPT
+  TRAP_TRACE			/* Process trace trap.  */
+# define TRAP_TRACE	TRAP_TRACE
+};
+
+/* `si_code' values for SIGCHLD signal.  */
+enum
+{
+  CLD_EXITED = 1,		/* Child has exited.  */
+# define CLD_EXITED	CLD_EXITED
+  CLD_KILLED,			/* Child was killed.  */
+# define CLD_KILLED	CLD_KILLED
+  CLD_DUMPED,			/* Child terminated abnormally.  */
+# define CLD_DUMPED	CLD_DUMPED
+  CLD_TRAPPED,			/* Traced child has trapped.  */
+# define CLD_TRAPPED	CLD_TRAPPED
+  CLD_STOPPED,			/* Child has stopped.  */
+# define CLD_STOPPED	CLD_STOPPED
+  CLD_CONTINUED			/* Stopped child has continued.  */
+# define CLD_CONTINUED	CLD_CONTINUED
+};
+
+/* `si_code' values for SIGPOLL signal.  */
+enum
+{
+  POLL_IN = 1,			/* Data input available.  */
+# define POLL_IN	POLL_IN
+  POLL_OUT,			/* Output buffers available.  */
+# define POLL_OUT	POLL_OUT
+  POLL_MSG,			/* Input message available.   */
+# define POLL_MSG	POLL_MSG
+  POLL_ERR,			/* I/O error.  */
+# define POLL_ERR	POLL_ERR
+  POLL_PRI,			/* High priority input available.  */
+# define POLL_PRI	POLL_PRI
+  POLL_HUP			/* Device disconnected.  */
+# define POLL_HUP	POLL_HUP
+};
+
+# undef __need_siginfo_t
+#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
+
+
+#if (defined _SIGNAL_H || defined __need_sigevent_t) \
+    && !defined __have_sigevent_t
+# define __have_sigevent_t	1
+
+/* Structure to transport application-defined values with signals.  */
+# define __SIGEV_MAX_SIZE	64
+# define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 3)
+
+/* Forward declaration of the `pthread_attr_t' type.  */
+struct __pthread_attr_s;
+
+/* XXX This one might need to change!!!  */
+typedef struct sigevent
+  {
+    sigval_t sigev_value;
+    int sigev_signo;
+    int sigev_notify;
+
+    union
+      {
+	int _pad[__SIGEV_PAD_SIZE];
+
+	struct
+	  {
+	    void (*_function) (sigval_t);	  /* Function to start.  */
+	    struct __pthread_attr_s *_attribute;  /* Really pthread_attr_t.  */
+	  } _sigev_thread;
+      } _sigev_un;
+  } sigevent_t;
+
+/* POSIX names to access some of the members.  */
+# define sigev_notify_function   _sigev_un._sigev_thread._function
+# define sigev_notify_attributes _sigev_un._sigev_thread._attribute
+
+/* `sigev_notify' values.  */
+enum
+{
+  SIGEV_SIGNAL = 0,		/* Notify via signal.  */
+# define SIGEV_SIGNAL	SIGEV_SIGNAL
+  SIGEV_NONE,			/* Other notification: meaningless.  */
+# define SIGEV_NONE	SIGEV_NONE
+  SIGEV_CALLBACK,		/* Deliver via thread creation.  */
+# define SIGEV_CALLBACK	SIGEV_CALLBACK
+  SIGEV_THREAD			/* Deliver via thread creation.  */
+# define SIGEV_THREAD	SIGEV_THREAD
+};
+
+#endif	/* have _SIGNAL_H.  */
diff -pruwN busybox-1.01/include2/bits/signum.h busybox-1.01-livebox/include2/bits/signum.h
--- busybox-1.01/include2/bits/signum.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/signum.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,79 @@
+/* Signal number definitions.  Linux version.
+   Copyright (C) 1995, 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef	_SIGNAL_H
+
+/* Fake signal functions.  */
+#define SIG_ERR ((__sighandler_t) -1)		/* Error return.  */
+#define SIG_DFL ((__sighandler_t) 0)		/* Default action.  */
+#define SIG_IGN ((__sighandler_t) 1)		/* Ignore signal.  */
+
+#ifdef __USE_UNIX98
+# define SIG_HOLD	((__sighandler_t) 2)	/* Add signal to hold mask.  */
+#endif
+
+
+#define SIGHUP		 1	/* Hangup (POSIX).  */
+#define SIGINT		 2	/* Interrupt (ANSI).  */
+#define SIGQUIT		 3	/* Quit (POSIX).  */
+#define SIGILL		 4	/* Illegal instruction (ANSI).  */
+#define SIGTRAP		 5	/* Trace trap (POSIX).  */
+#define SIGIOT		 6	/* IOT trap (4.2 BSD).  */
+#define SIGABRT		 SIGIOT	/* Abort (ANSI).  */
+#define SIGEMT		 7
+#define SIGFPE		 8	/* Floating-point exception (ANSI).  */
+#define SIGKILL		 9	/* Kill, unblockable (POSIX).  */
+#define SIGBUS		10	/* BUS error (4.2 BSD).  */
+#define SIGSEGV		11	/* Segmentation violation (ANSI).  */
+#define SIGSYS		12
+#define SIGPIPE		13	/* Broken pipe (POSIX).  */
+#define SIGALRM		14	/* Alarm clock (POSIX).  */
+#define SIGTERM		15	/* Termination (ANSI).  */
+#define SIGUSR1		16	/* User-defined signal 1 (POSIX).  */
+#define SIGUSR2		17	/* User-defined signal 2 (POSIX).  */
+#define SIGCHLD		18	/* Child status has changed (POSIX).  */
+#define SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
+#define SIGPWR		19	/* Power failure restart (System V).  */
+#define SIGWINCH	20	/* Window size change (4.3 BSD, Sun).  */
+#define SIGURG		21	/* Urgent condition on socket (4.2 BSD).  */
+#define SIGIO		22	/* I/O now possible (4.2 BSD).  */
+#define SIGPOLL		SIGIO	/* Pollable event occurred (System V).  */
+#define SIGSTOP		23	/* Stop, unblockable (POSIX).  */
+#define SIGTSTP		24	/* Keyboard stop (POSIX).  */
+#define SIGCONT		25	/* Continue (POSIX).  */
+#define SIGTTIN		26	/* Background read from tty (POSIX).  */
+#define SIGTTOU		27	/* Background write to tty (POSIX).  */
+#define SIGVTALRM	28	/* Virtual alarm clock (4.2 BSD).  */
+#define SIGPROF		29	/* Profiling alarm clock (4.2 BSD).  */
+#define SIGXCPU		30	/* CPU limit exceeded (4.2 BSD).  */
+#define SIGXFSZ		31	/* File size limit exceeded (4.2 BSD).  */
+
+
+#define _NSIG		128	/* Biggest signal number + 1
+				   (including real-time signals).  */
+
+#define SIGRTMIN	(__libc_current_sigrtmin ())
+#define SIGRTMAX	(__libc_current_sigrtmax ())
+
+/* These are the hard limits of the kernel.  These values should not be
+   used directly at user level.  */
+#define __SIGRTMIN	32
+#define __SIGRTMAX	(_NSIG - 1)
+
+#endif	/* <signal.h> included.  */
diff -pruwN busybox-1.01/include2/bits/sigset.h busybox-1.01-livebox/include2/bits/sigset.h
--- busybox-1.01/include2/bits/sigset.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/sigset.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,125 @@
+/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
+   Copyright (C) 1991, 1992, 1994, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SIGSET_H_types
+# define _SIGSET_H_types	1
+
+typedef int __sig_atomic_t;
+
+/* A `sigset_t' has a bit for each signal.  */
+
+# define _SIGSET_NWORDS	(1024 / (8 * sizeof (unsigned long int)))
+typedef struct
+  {
+    unsigned long int __val[_SIGSET_NWORDS];
+  } __sigset_t;
+
+#endif
+
+
+/* We only want to define these functions if <signal.h> was actually
+   included; otherwise we were included just to define the types.  Since we
+   are namespace-clean, it wouldn't hurt to define extra macros.  But
+   trouble can be caused by functions being defined (e.g., any global
+   register vars declared later will cause compilation errors).  */
+
+#if !defined _SIGSET_H_fns && defined _SIGNAL_H
+# define _SIGSET_H_fns 1
+
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE extern __inline
+# endif
+
+/* Return a mask that includes the bit for SIG only.  */
+# define __sigmask(sig) \
+  (((unsigned long int) 1) << (((sig) - 1) % (8 * sizeof (unsigned long int))))
+
+/* Return the word index for SIG.  */
+# define __sigword(sig)	(((sig) - 1) / (8 * sizeof (unsigned long int)))
+
+# if defined __GNUC__ && __GNUC__ >= 2
+#  define __sigemptyset(set) \
+  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
+		    sigset_t *__set = (set);				      \
+		    while (--__cnt >= 0) __set->__val[__cnt] = 0;	      \
+		    0; }))
+#  define __sigfillset(set) \
+  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
+		    sigset_t *__set = (set);				      \
+		    while (--__cnt >= 0) __set->__val[__cnt] = ~0UL;	      \
+		    0; }))
+
+#  ifdef __USE_GNU
+/* The POSIX does not specify for handling the whole signal set in one
+   command.  This is often wanted and so we define three more functions
+   here.  */
+#   define __sigisemptyset(set) \
+  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
+		    const sigset_t *__set = (set);			      \
+		    int __ret = __set->__val[--__cnt];			      \
+		    while (!__ret && --__cnt >= 0)			      \
+			__ret = __set->__val[__cnt];			      \
+		    __ret == 0; }))
+#   define __sigandset(dest, left, right) \
+  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
+		    sigset_t *__dest = (dest);				      \
+		    const sigset_t *__left = (left);			      \
+		    const sigset_t *__right = (right);			      \
+		    while (--__cnt >= 0)				      \
+		      __dest->__val[__cnt] = (__left->__val[__cnt]	      \
+					      & __right->__val[__cnt]);	      \
+		    0; }))
+#   define __sigorset(dest, left, right) \
+  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
+		    sigset_t *__dest = (dest);				      \
+		    const sigset_t *__left = (left);			      \
+		    const sigset_t *__right = (right);			      \
+		    while (--__cnt >= 0)				      \
+		      __dest->__val[__cnt] = (__left->__val[__cnt]	      \
+					      | __right->__val[__cnt]);	      \
+		    0; }))
+#  endif
+# endif
+
+/* These functions needn't check for a bogus signal number -- error
+   checking is done in the non __ versions.  */
+
+extern int __sigismember (__const __sigset_t *, int);
+extern int __sigaddset (__sigset_t *, int);
+extern int __sigdelset (__sigset_t *, int);
+
+# ifdef __USE_EXTERN_INLINES
+#  define __SIGSETFN(NAME, BODY, CONST)					      \
+  _EXTERN_INLINE int							      \
+  NAME (CONST __sigset_t *__set, int __sig)				      \
+  {									      \
+    unsigned long int __mask = __sigmask (__sig);			      \
+    unsigned long int __word = __sigword (__sig);			      \
+    return BODY;							      \
+  }
+
+__SIGSETFN (__sigismember, (__set->__val[__word] & __mask) ? 1 : 0, __const)
+__SIGSETFN (__sigaddset, ((__set->__val[__word] |= __mask), 0), )
+__SIGSETFN (__sigdelset, ((__set->__val[__word] &= ~__mask), 0), )
+
+#  undef __SIGSETFN
+# endif
+
+
+#endif /* ! _SIGSET_H_fns.  */
diff -pruwN busybox-1.01/include2/bits/sigstack.h busybox-1.01-livebox/include2/bits/sigstack.h
--- busybox-1.01/include2/bits/sigstack.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/sigstack.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,55 @@
+/* sigstack, sigaltstack definitions.
+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SIGNAL_H
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+
+/* Structure describing a signal stack (obsolete).  */
+struct sigstack
+  {
+    void *ss_sp;		/* Signal stack pointer.  */
+    int ss_onstack;		/* Nonzero if executing on this stack.  */
+  };
+
+
+/* Possible values for `ss_flags.'.  */
+enum
+{
+  SS_ONSTACK = 1,
+#define SS_ONSTACK	SS_ONSTACK
+  SS_DISABLE
+#define SS_DISABLE	SS_DISABLE
+};
+
+/* Minimum stack size for a signal handler.  */
+#define MINSIGSTKSZ	2048
+
+/* System default stack size.  */
+#define SIGSTKSZ	8192
+
+
+/* Alternate, preferred interface.  */
+typedef struct sigaltstack
+  {
+    void *ss_sp;
+    size_t ss_size;
+    int ss_flags;
+  } stack_t;
diff -pruwN busybox-1.01/include2/bits/sigthread.h busybox-1.01-livebox/include2/bits/sigthread.h
--- busybox-1.01/include2/bits/sigthread.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/sigthread.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,38 @@
+/* Signal handling function for threaded programs.
+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_SIGTHREAD_H
+#define _BITS_SIGTHREAD_H	1
+
+#if !defined _SIGNAL_H && !defined _PTHREAD_H
+# error "Never include this file directly.  Use <pthread.h> instead"
+#endif
+
+/* Functions for handling signals. */
+
+/* Modify the signal mask for the calling thread.  The arguments have
+   the same meaning as for sigprocmask(2). */
+extern int pthread_sigmask (int __how,
+			    __const __sigset_t *__restrict __newmask,
+			    __sigset_t *__restrict __oldmask)__THROW;
+
+/* Send signal SIGNO to the given thread. */
+extern int pthread_kill (pthread_t __thread_id, int __signo) __THROW;
+
+#endif	/* bits/sigthread.h */
diff -pruwN busybox-1.01/include2/bits/sockaddr.h busybox-1.01-livebox/include2/bits/sockaddr.h
--- busybox-1.01/include2/bits/sockaddr.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/sockaddr.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,40 @@
+/* Definition of `struct sockaddr_*' common members.  Generic/4.2 BSD version.
+   Copyright (C) 1995,1996,1997,1998,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <sys/socket.h> instead.
+ */
+
+#ifndef _BITS_SOCKADDR_H
+#define _BITS_SOCKADDR_H	1
+
+
+/* POSIX.1g specifies this type name for the `sa_family' member.  */
+typedef unsigned short int sa_family_t;
+
+/* This macro is used to declare the initial common members
+   of the data types used for socket addresses, `struct sockaddr',
+   `struct sockaddr_in', `struct sockaddr_un', etc.  */
+
+#define	__SOCKADDR_COMMON(sa_prefix) \
+  sa_family_t sa_prefix##family
+
+#define __SOCKADDR_COMMON_SIZE	(sizeof (unsigned short int))
+
+#endif	/* bits/sockaddr.h */
diff -pruwN busybox-1.01/include2/bits/socket.h busybox-1.01-livebox/include2/bits/socket.h
--- busybox-1.01/include2/bits/socket.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/socket.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,315 @@
+/* System-specific socket constants and types.  Linux/MIPS version.
+   Copyright (C) 1991,92,1994-1999,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __BITS_SOCKET_H
+#define __BITS_SOCKET_H
+
+#if !defined _SYS_SOCKET_H && !defined _NETINET_IN_H
+# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
+#endif
+
+#define	__need_size_t
+#define __need_NULL
+#include <stddef.h>
+
+#include <limits.h>
+#include <sys/types.h>
+
+/* Type for length arguments in socket calls.  */
+#ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+# define __socklen_t_defined
+#endif
+
+/* Types of sockets.  */
+enum __socket_type
+{
+  SOCK_DGRAM = 1,		/* Connectionless, unreliable datagrams
+				   of fixed maximum length.  */
+#define SOCK_DGRAM SOCK_DGRAM
+  SOCK_STREAM = 2,		/* Sequenced, reliable, connection-based
+				   byte streams.  */
+#define SOCK_STREAM SOCK_STREAM
+  SOCK_RAW = 3,			/* Raw protocol interface.  */
+#define SOCK_RAW SOCK_RAW
+  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
+#define SOCK_RDM SOCK_RDM
+  SOCK_SEQPACKET = 5,		/* Sequenced, reliable, connection-based,
+				   datagrams of fixed maximum length.  */
+#define SOCK_SEQPACKET SOCK_SEQPACKET
+  SOCK_PACKET = 10		/* Linux specific way of getting packets
+				   at the dev level.  For writing rarp and
+				   other similar things on the user level. */
+#define SOCK_PACKET SOCK_PACKET
+};
+
+/* Protocol families.  */
+#define	PF_UNSPEC	0	/* Unspecified.  */
+#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
+#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
+#define	PF_FILE		PF_LOCAL /* Another non-standard name for PF_LOCAL.  */
+#define	PF_INET		2	/* IP protocol family.  */
+#define	PF_AX25		3	/* Amateur Radio AX.25.  */
+#define	PF_IPX		4	/* Novell Internet Protocol.  */
+#define	PF_APPLETALK	5	/* Appletalk DDP.  */
+#define	PF_NETROM	6	/* Amateur radio NetROM.  */
+#define	PF_BRIDGE	7	/* Multiprotocol bridge.  */
+#define	PF_ATMPVC	8	/* ATM PVCs.  */
+#define	PF_X25		9	/* Reserved for X.25 project.  */
+#define	PF_INET6	10	/* IP version 6.  */
+#define	PF_ROSE		11	/* Amateur Radio X.25 PLP.  */
+#define	PF_DECnet	12	/* Reserved for DECnet project.  */
+#define	PF_NETBEUI	13	/* Reserved for 802.2LLC project.  */
+#define	PF_SECURITY	14	/* Security callback pseudo AF.  */
+#define	PF_KEY		15	/* PF_KEY key management API.  */
+#define	PF_NETLINK	16
+#define	PF_ROUTE	PF_NETLINK /* Alias to emulate 4.4BSD.  */
+#define	PF_PACKET	17	/* Packet family.  */
+#define	PF_ASH		18	/* Ash.  */
+#define	PF_ECONET	19	/* Acorn Econet.  */
+#define	PF_ATMSVC	20	/* ATM SVCs.  */
+#define	PF_SNA		22	/* Linux SNA Project */
+#define	PF_IRDA		23	/* IRDA sockets.  */
+#define	PF_PPPOX	24	/* PPPoX sockets.  */
+#define	PF_WANPIPE	25	/* Wanpipe API sockets.  */
+#define	PF_BLUETOOTH	31	/* Bluetooth sockets.  */
+#define	PF_MAX		32	/* For now..  */
+
+/* Address families.  */
+#define	AF_UNSPEC	PF_UNSPEC
+#define	AF_LOCAL	PF_LOCAL
+#define	AF_UNIX		PF_UNIX
+#define	AF_FILE		PF_FILE
+#define	AF_INET		PF_INET
+#define	AF_AX25		PF_AX25
+#define	AF_IPX		PF_IPX
+#define	AF_APPLETALK	PF_APPLETALK
+#define	AF_NETROM	PF_NETROM
+#define	AF_BRIDGE	PF_BRIDGE
+#define	AF_ATMPVC	PF_ATMPVC
+#define	AF_X25		PF_X25
+#define	AF_INET6	PF_INET6
+#define	AF_ROSE		PF_ROSE
+#define	AF_DECnet	PF_DECnet
+#define	AF_NETBEUI	PF_NETBEUI
+#define	AF_SECURITY	PF_SECURITY
+#define	AF_KEY		PF_KEY
+#define	AF_NETLINK	PF_NETLINK
+#define	AF_ROUTE	PF_ROUTE
+#define	AF_PACKET	PF_PACKET
+#define	AF_ASH		PF_ASH
+#define	AF_ECONET	PF_ECONET
+#define	AF_ATMSVC	PF_ATMSVC
+#define	AF_SNA		PF_SNA
+#define	AF_IRDA		PF_IRDA
+#define	AF_PPPOX	PF_PPPOX
+#define	AF_WANPIPE	PF_WANPIPE
+#define	AF_BLUETOOTH	PF_BLUETOOTH
+#define	AF_MAX		PF_MAX
+
+/* Socket level values.  Others are defined in the appropriate headers.
+
+   XXX These definitions also should go into the appropriate headers as
+   far as they are available.  */
+#define SOL_RAW		255
+#define SOL_DECNET      261
+#define SOL_X25         262
+#define SOL_PACKET	263
+#define SOL_ATM		264	/* ATM layer (cell level).  */
+#define SOL_AAL		265	/* ATM Adaption Layer (packet level).  */
+#define SOL_IRDA	266
+
+/* Maximum queue length specifiable by listen.  */
+#define SOMAXCONN	128
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/sockaddr.h>
+
+/* Structure describing a generic socket address.  */
+struct sockaddr
+  {
+    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
+    char sa_data[14];		/* Address data.  */
+  };
+
+
+/* Structure large enough to hold any socket address (with the historical
+   exception of AF_UNIX).  We reserve 128 bytes.  */
+#if ULONG_MAX > 0xffffffff
+# define __ss_aligntype	__uint64_t
+#else
+# define __ss_aligntype	__uint32_t
+#endif
+#define _SS_SIZE	128
+#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
+
+struct sockaddr_storage
+  {
+    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
+    __ss_aligntype __ss_align;	/* Force desired alignment.  */
+    char __ss_padding[_SS_PADSIZE];
+  };
+
+
+/* Bits in the FLAGS argument to `send', `recv', et al.  */
+enum
+  {
+    MSG_OOB		= 0x01,	/* Process out-of-band data.  */
+#define MSG_OOB		MSG_OOB
+    MSG_PEEK		= 0x02,	/* Peek at incoming messages.  */
+#define MSG_PEEK	MSG_PEEK
+    MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
+#define MSG_DONTROUTE	MSG_DONTROUTE
+#ifdef __USE_GNU
+    /* DECnet uses a different name.  */
+    MSG_TRYHARD		= MSG_DONTROUTE,
+# define MSG_TRYHARD	MSG_DONTROUTE
+#endif
+    MSG_CTRUNC		= 0x08,	/* Control data lost before delivery.  */
+#define MSG_CTRUNC	MSG_CTRUNC
+    MSG_PROXY		= 0x10,	/* Supply or ask second address.  */
+#define MSG_PROXY	MSG_PROXY
+    MSG_TRUNC		= 0x20,
+#define	MSG_TRUNC	MSG_TRUNC
+    MSG_DONTWAIT	= 0x40, /* Nonblocking IO.  */
+#define	MSG_DONTWAIT	MSG_DONTWAIT
+    MSG_EOR		= 0x80, /* End of record.  */
+#define	MSG_EOR		MSG_EOR
+    MSG_WAITALL		= 0x100, /* Wait for a full request.  */
+#define	MSG_WAITALL	MSG_WAITALL
+    MSG_FIN		= 0x200,
+#define	MSG_FIN		MSG_FIN
+    MSG_SYN		= 0x400,
+#define	MSG_SYN		MSG_SYN
+    MSG_CONFIRM		= 0x800, /* Confirm path validity.  */
+#define	MSG_CONFIRM	MSG_CONFIRM
+    MSG_RST		= 0x1000,
+#define	MSG_RST		MSG_RST
+    MSG_ERRQUEUE	= 0x2000, /* Fetch message from error queue.  */
+#define	MSG_ERRQUEUE	MSG_ERRQUEUE
+    MSG_NOSIGNAL	= 0x4000, /* Do not generate SIGPIPE.  */
+#define	MSG_NOSIGNAL	MSG_NOSIGNAL
+    MSG_MORE		= 0x8000  /* Sender will send more.  */
+#define	MSG_MORE	MSG_MORE
+  };
+
+
+/* Structure describing messages sent by
+   `sendmsg' and received by `recvmsg'.  */
+struct msghdr
+  {
+    void *msg_name;		/* Address to send to/receive from.  */
+    socklen_t msg_namelen;	/* Length of address data.  */
+
+    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
+    int msg_iovlen;		/* Number of elements in the vector.  */
+
+    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
+    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
+
+    int msg_flags;		/* Flags on received message.  */
+  };
+
+/* Structure used for storage of ancillary data object information.  */
+struct cmsghdr
+  {
+    size_t cmsg_len;		/* Length of data in cmsg_data plus length
+				   of cmsghdr structure.  */
+    int cmsg_level;		/* Originating protocol.  */
+    int cmsg_type;		/* Protocol specific type.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+    __extension__ unsigned char __cmsg_data __flexarr; /* Ancillary data.  */
+#endif
+  };
+
+/* Ancillary data object manipulation macros.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
+#else
+# define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
+#endif
+#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
+#define CMSG_FIRSTHDR(mhdr) \
+  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
+   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
+			 & (size_t) ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
+			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+
+extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
+				      struct cmsghdr *__cmsg) __THROW;
+#ifdef __USE_EXTERN_INLINES
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE extern __inline
+# endif
+_EXTERN_INLINE struct cmsghdr *
+__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) __THROW
+{
+  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
+    /* The kernel header does this so there may be a reason.  */
+    return 0;
+
+  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
+			       + CMSG_ALIGN (__cmsg->cmsg_len));
+  if ((unsigned char *) (__cmsg + 1) >= ((unsigned char *) __mhdr->msg_control
+					 + __mhdr->msg_controllen)
+      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
+	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
+    /* No more entries.  */
+    return 0;
+  return __cmsg;
+}
+#endif	/* Use `extern inline'.  */
+
+/* Socket level message types.  This must match the definitions in
+   <linux/socket.h>.  */
+enum
+  {
+    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
+#define SCM_RIGHTS SCM_RIGHTS
+#ifdef __USE_BSD
+    SCM_CREDENTIALS = 0x02,     /* Credentials passing.  */
+# define SCM_CREDENTIALS SCM_CREDENTIALS
+#endif
+    __SCM_CONNECT = 0x03	/* Data array is `struct scm_connect'.  */
+  };
+
+/* User visible structure for SCM_CREDENTIALS message */
+
+struct ucred
+{
+  pid_t pid;			/* PID of sending process.  */
+  uid_t uid;			/* UID of sending process.  */
+  gid_t gid;			/* GID of sending process.  */
+};
+
+/* Get socket manipulation related informations from kernel headers.  */
+#include <asm/socket.h>
+
+
+/* Structure used to manipulate the SO_LINGER option.  */
+struct linger
+  {
+    int l_onoff;		/* Nonzero to linger on close.  */
+    int l_linger;		/* Time to linger.  */
+  };
+
+#endif	/* bits/socket.h */
diff -pruwN busybox-1.01/include2/bits/statfs.h busybox-1.01-livebox/include2/bits/statfs.h
--- busybox-1.01/include2/bits/statfs.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/statfs.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,72 @@
+/* Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STATFS_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <bits/types.h>  /* for __fsid_t and __fsblkcnt_t*/
+
+struct statfs
+  {
+    long int f_type;
+#define f_fstyp f_type
+    long int f_bsize;
+    long int f_frsize;	/* Fragment size - unsupported */
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_files;
+    __fsblkcnt_t f_ffree;
+    __fsblkcnt_t f_bavail;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_files;
+    __fsblkcnt64_t f_ffree;
+    __fsblkcnt64_t f_bavail;
+#endif
+
+	/* Linux specials */
+    __fsid_t f_fsid;
+    long int f_namelen;
+    long int f_spare[6];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+    long int f_type;
+#define f_fstyp f_type
+    long int f_bsize;
+    long int f_frsize;	/* Fragment size - unsupported */
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_files;
+    __fsblkcnt64_t f_ffree;
+    __fsblkcnt64_t f_bavail;
+
+	/* Linux specials */
+    __fsid_t f_fsid;
+    long int f_namelen;
+    long int f_spare[6];
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define _STATFS_F_NAMELEN
diff -pruwN busybox-1.01/include2/bits/stat.h busybox-1.01-livebox/include2/bits/stat.h
--- busybox-1.01/include2/bits/stat.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/stat.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,140 @@
+/* Copyright (C) 1992,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STAT_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+/* Versions of the `struct stat' data structure.  */
+#define _STAT_VER_LINUX_OLD	1
+#define _STAT_VER_KERNEL	1
+#define _STAT_VER_SVR4		2
+#define _STAT_VER_LINUX		3
+#define _STAT_VER		_STAT_VER_LINUX /* The one defined below.  */
+
+/* Versions of the `xmknod' interface.  */
+#define _MKNOD_VER_LINUX	1
+#define _MKNOD_VER_SVR4		2
+#define _MKNOD_VER		_MKNOD_VER_LINUX /* The bits defined below.  */
+
+
+/* Structure describing file characteristics.  */
+struct stat
+  {
+	__dev_t st_dev;
+    long int st_pad1[3];
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;		/* File serial number.		*/
+#else
+    __ino64_t st_ino;		/* File serial number.		*/
+#endif
+    __mode_t st_mode;		/* File mode.  */
+    __nlink_t st_nlink;		/* Link count.  */
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+    __dev_t st_rdev;	/* Device number, if device.  */
+#ifndef __USE_FILE_OFFSET64
+    long int st_pad2[2];
+    __off_t st_size;		/* Size of file, in bytes.  */
+    /* SVR4 added this extra long to allow for expansion of off_t.  */
+    long int st_pad3;
+#else
+    long int st_pad2[3];
+    __off64_t st_size;		/* Size of file, in bytes.  */
+#endif
+    /*
+     * Actually this should be timestruc_t st_atime, st_mtime and
+     * st_ctime but we don't have it under Linux.
+     */
+    __time_t st_atime;		/* Time of last access.  */
+    long int __reserved0;
+    __time_t st_mtime;		/* Time of last modification.  */
+    long int __reserved1;
+    __time_t st_ctime;		/* Time of last status change.  */
+    long int __reserved2;
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+#ifndef __USE_FILE_OFFSET64
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+#else
+    long int st_pad4;
+    __blkcnt64_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+#endif
+    long int st_pad5[14];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    __dev_t st_dev;
+    long int st_pad1[3];
+    __ino64_t st_ino;		/* File serial number.		*/
+    __mode_t st_mode;		/* File mode.  */
+    __nlink_t st_nlink;		/* Link count.  */
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+    __dev_t st_rdev;	/* Device number, if device.  */
+    long int st_pad2[3];
+    __off64_t st_size;		/* Size of file, in bytes.  */
+    /*
+     * Actually this should be timestruc_t st_atime, st_mtime and
+     * st_ctime but we don't have it under Linux.
+     */
+    __time_t st_atime;		/* Time of last access.  */
+    long int __reserved0;
+    __time_t st_mtime;		/* Time of last modification.  */
+    long int __reserved1;
+    __time_t st_ctime;		/* Time of last status change.  */
+    long int __reserved2;
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+    long int st_pad3;
+    __blkcnt64_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+    long int st_pad4[14];
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define	_STATBUF_ST_BLKSIZE
+#define	_STATBUF_ST_RDEV
+
+/* Encoding of the file mode.  */
+
+#define	__S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define	__S_IFDIR	0040000	/* Directory.  */
+#define	__S_IFCHR	0020000	/* Character device.  */
+#define	__S_IFBLK	0060000	/* Block device.  */
+#define	__S_IFREG	0100000	/* Regular file.  */
+#define	__S_IFIFO	0010000	/* FIFO.  */
+#define	__S_IFLNK	0120000	/* Symbolic link.  */
+#define	__S_IFSOCK	0140000	/* Socket.  */
+
+/* POSIX.1b objects.  Note that these macros always evaluate to zero.  But
+   they do it by enforcing the correct use of the macros.  */
+#define __S_TYPEISMQ(buf)  ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSEM(buf) ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSHM(buf) ((buf)->st_mode - (buf)->st_mode)
+
+/* Protection bits.  */
+
+#define	__S_ISUID	04000	/* Set user ID on execution.  */
+#define	__S_ISGID	02000	/* Set group ID on execution.  */
+#define	__S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define	__S_IREAD	0400	/* Read by owner.  */
+#define	__S_IWRITE	0200	/* Write by owner.  */
+#define	__S_IEXEC	0100	/* Execute by owner.  */
diff -pruwN busybox-1.01/include2/bits/stdio_lim.h busybox-1.01-livebox/include2/bits/stdio_lim.h
--- busybox-1.01/include2/bits/stdio_lim.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/stdio_lim.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,41 @@
+/* Copyright (C) 1994, 1997, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _STDIO_H && !defined __need_FOPEN_MAX && !defined __need_IOV_MAX
+# error "Never include <bits/stdio_lim.h> directly; use <stdio.h> instead."
+#endif
+
+#ifdef _STDIO_H
+# define L_tmpnam 20
+# define TMP_MAX 238328
+# define FILENAME_MAX 4095 
+
+# ifdef __USE_POSIX
+#  define L_ctermid 9
+#  define L_cuserid 9
+# endif
+#endif
+
+#if defined __need_FOPEN_MAX || defined _STDIO_H
+# undef  FOPEN_MAX
+# define FOPEN_MAX 16
+#endif
+
+#if defined __need_IOV_MAX && !defined IOV_MAX
+# define IOV_MAX 1024 
+#endif
diff -pruwN busybox-1.01/include2/bits/syscalls.h busybox-1.01-livebox/include2/bits/syscalls.h
--- busybox-1.01/include2/bits/syscalls.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/syscalls.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,275 @@
+#ifndef _BITS_SYSCALLS_H
+#define _BITS_SYSCALLS_H
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
+#endif
+
+/* This includes the `__NR_<name>' syscall numbers taken from the Linux kernel
+ * header files.  It also defines the traditional `SYS_<name>' macros for older
+ * programs.  */
+#include <bits/sysnum.h>
+
+#ifndef __set_errno
+# define __set_errno(val) (*__errno_location ()) = (val)
+#endif
+#ifndef SYS_ify
+# define SYS_ify(syscall_name)  (__NR_##syscall_name)
+#endif
+
+#ifndef __ASSEMBLER__
+
+#define _syscall0(type,name) \
+type name(void) \
+{ 									\
+	long err;							\
+	long sys_result;						\
+	{								\
+	register unsigned long __v0 asm("$2"); 				\
+	register unsigned long __a3 asm("$7"); 				\
+	__asm__ volatile ( 						\
+	".set	noreorder\n\t" 						\
+	"li	$2, %2	# " #name "\n\t"				\
+	"syscall\n\t" 							\
+	".set reorder" 							\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "i" (SYS_ify(name))						\
+	: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",		\
+		"$14", "$15", "$24", "$25", "memory");			\
+	err = __a3;							\
+	sys_result = __v0;						\
+	}								\
+	if (err == 0)							\
+		return (type) sys_result;				\
+	__set_errno(sys_result);					\
+	return (type)-1;						\
+}
+
+#define _syscall1(type,name,atype,a) \
+type name(atype a) \
+{ 									\
+	long err;							\
+	long sys_result;						\
+	{								\
+	register unsigned long __v0 asm("$2"); 				\
+	register unsigned long __a0 asm("$4") = (unsigned long) a; 	\
+	register unsigned long __a3 asm("$7"); 				\
+	__asm__ volatile ( 						\
+	".set	noreorder\n\t" 						\
+	"li	$2, %3\t\t\t# " #name "\n\t"				\
+	"syscall\n\t" 							\
+	".set reorder" 							\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "i" (SYS_ify(name)) 				\
+	: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",		\
+		"$14", "$15", "$24", "$25", "memory");			\
+	err = __a3;							\
+	sys_result = __v0;						\
+	}								\
+	if (err == 0)							\
+		return (type) sys_result;				\
+	__set_errno(sys_result);					\
+	return (type)-1;						\
+}
+
+#define _syscall2(type,name,atype,a,btype,b) \
+type name(atype a,btype b) \
+{ 									\
+	long err;							\
+	long sys_result;						\
+	{								\
+	register unsigned long __v0 asm("$2"); 				\
+	register unsigned long __a0 asm("$4") = (unsigned long) a; 	\
+	register unsigned long __a1 asm("$5") = (unsigned long) b; 	\
+	register unsigned long __a3 asm("$7"); 				\
+	__asm__ volatile ( 						\
+	".set	noreorder\n\t" 						\
+	"li	$2, %4\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set	reorder" 						\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "i" (SYS_ify(name))			\
+	: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",		\
+		"$14", "$15", "$24", "$25", "memory");			\
+	err = __a3;							\
+	sys_result = __v0;						\
+	}								\
+	if (err == 0)							\
+		return (type) sys_result;				\
+	__set_errno(sys_result);					\
+	return (type)-1;						\
+}
+
+#define _syscall3(type,name,atype,a,btype,b,ctype,c) \
+type name (atype a, btype b, ctype c) \
+{ 									\
+	long err;							\
+	long sys_result;						\
+	{								\
+	register unsigned long __v0 asm("$2"); 				\
+	register unsigned long __a0 asm("$4") = (unsigned long) a; 	\
+	register unsigned long __a1 asm("$5") = (unsigned long) b; 	\
+	register unsigned long __a2 asm("$6") = (unsigned long) c; 	\
+	register unsigned long __a3 asm("$7"); 				\
+	__asm__ volatile ( 						\
+	".set	noreorder\n\t" 						\
+	"li	$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set	reorder" 						\
+	: "=r" (__v0), "=r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",		\
+		"$14", "$15", "$24", "$25", "memory");			\
+	err = __a3;							\
+	sys_result = __v0;						\
+	}								\
+	if (err == 0)							\
+		return (type) sys_result;				\
+	__set_errno(sys_result);					\
+	return (type)-1;						\
+}
+
+#define _syscall4(type,name,atype,a,btype,b,ctype,c,dtype,d) \
+type name (atype a, btype b, ctype c, dtype d) \
+{ 									\
+	long err;							\
+	long sys_result;						\
+	{								\
+	register unsigned long __v0 asm("$2"); 				\
+	register unsigned long __a0 asm("$4") = (unsigned long) a; 	\
+	register unsigned long __a1 asm("$5") = (unsigned long) b; 	\
+	register unsigned long __a2 asm("$6") = (unsigned long) c; 	\
+	register unsigned long __a3 asm("$7") = (unsigned long) d; 	\
+	__asm__ volatile ( 						\
+	".set	noreorder\n\t" 						\
+	"li	$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	".set	reorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",		\
+		"$14", "$15", "$24", "$25", "memory");			\
+	err = __a3;							\
+	sys_result = __v0;						\
+	}								\
+	if (err == 0)							\
+		return (type) sys_result;				\
+	__set_errno(sys_result);					\
+	return (type)-1;						\
+}
+
+#define _syscall5(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e) \
+type name (atype a,btype b,ctype c,dtype d,etype e) \
+{ 									\
+	long err;							\
+	long sys_result;						\
+	const unsigned long *constE = (void*)(unsigned long) e;		\
+	{								\
+	register unsigned long __v0 asm("$2"); 				\
+	register unsigned long __a0 asm("$4") = (unsigned long) a; 	\
+	register unsigned long __a1 asm("$5") = (unsigned long) b; 	\
+	register unsigned long __a2 asm("$6") = (unsigned long) c; 	\
+	register unsigned long __a3 asm("$7") = (unsigned long) d; 	\
+	__asm__ volatile ( 						\
+	".set	noreorder\n\t" 						\
+	"lw	$2, %6\n\t" 						\
+	"subu	$29, 32\n\t" 						\
+	"sw	$2, 16($29)\n\t" 					\
+	"li	$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	"addiu	$29, 32\n\t" 						\
+	".set	reorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
+	  "m" (constE)							\
+	: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",		\
+		"$14", "$15", "$24", "$25", "memory");			\
+	err = __a3;							\
+	sys_result = __v0;						\
+	}								\
+	if (err == 0)							\
+		return (type) sys_result;				\
+	__set_errno(sys_result);					\
+	return (type)-1;						\
+}
+
+#define _syscall6(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f) \
+type name (atype a,btype b,ctype c,dtype d,etype e,ftype f) \
+{ 									\
+	long err;							\
+	long sys_result;						\
+	const unsigned long *constE = (void*)(unsigned long) e;		\
+	const unsigned long *constF = (void*)(unsigned long) f;		\
+	{								\
+	register unsigned long __v0 asm("$2"); 				\
+	register unsigned long __a0 asm("$4") = (unsigned long) a; 	\
+	register unsigned long __a1 asm("$5") = (unsigned long) b; 	\
+	register unsigned long __a2 asm("$6") = (unsigned long) c; 	\
+	register unsigned long __a3 asm("$7") = (unsigned long) d;	\
+	__asm__ volatile ( 						\
+	".set	noreorder\n\t" 						\
+	"lw	$2, %6\n\t" 						\
+	"lw	$8, %7\n\t" 						\
+	"subu	$29, 32\n\t" 						\
+	"sw	$2, 16($29)\n\t" 					\
+	"sw	$8, 20($29)\n\t" 					\
+	"li	$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	"addiu	$29, 32\n\t" 						\
+	".set	reorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
+	  "m" (constE), "m" (constF)					\
+	: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",		\
+		"$14", "$15", "$24", "$25", "memory");			\
+	err = __a3;							\
+	sys_result = __v0;						\
+	}								\
+	if (err == 0)							\
+		return (type) sys_result;				\
+	__set_errno(sys_result);					\
+	return (type)-1;						\
+}
+
+#define _syscall7(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f,gtype,g) \
+type name (atype a,btype b,ctype c,dtype d,etype e,ftype f,gtype g) \
+{ 									\
+	long err;							\
+	long sys_result;						\
+	const unsigned long *constE = (void*)(unsigned long) e;		\
+	const unsigned long *constF = (void*)(unsigned long) f;		\
+	const unsigned long *constG = (void*)(unsigned long) g;		\
+	{								\
+	register unsigned long __v0 asm("$2"); 				\
+	register unsigned long __a0 asm("$4") = (unsigned long) a; 	\
+	register unsigned long __a1 asm("$5") = (unsigned long) b; 	\
+	register unsigned long __a2 asm("$6") = (unsigned long) c; 	\
+	register unsigned long __a3 asm("$7") = (unsigned long) d;	\
+	__asm__ volatile ( 						\
+	".set	noreorder\n\t" 						\
+	"lw	$2, %6\n\t" 						\
+	"lw	$8, %7\n\t" 						\
+	"lw	$9, %8\n\t" 						\
+	"subu	$29, 32\n\t" 						\
+	"sw	$2, 16($29)\n\t" 					\
+	"sw	$8, 20($29)\n\t" 					\
+	"sw	$9, 24($29)\n\t" 					\
+	"li	$2, %5\t\t\t# " #name "\n\t" 				\
+	"syscall\n\t" 							\
+	"addiu	$29, 32\n\t" 						\
+	".set	reorder" 						\
+	: "=r" (__v0), "+r" (__a3) 					\
+	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
+	  "m" (constE), "m" (constF), "m" (constG)			\
+	: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",		\
+		"$14", "$15", "$24", "$25", "memory");			\
+	err = __a3;							\
+	sys_result = __v0;						\
+	}								\
+	if (err == 0)							\
+		return (type) sys_result;				\
+	__set_errno(sys_result);					\
+	return (type)-1;						\
+}
+
+#endif /* __ASSEMBLER__ */
+#endif /* _BITS_SYSCALLS_H */
diff -pruwN busybox-1.01/include2/bits/sysnum.h busybox-1.01-livebox/include2/bits/sysnum.h
--- busybox-1.01/include2/bits/sysnum.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/sysnum.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,881 @@
+/* WARNING!!! AUTO-GENERATED FILE!!! DO NOT EDIT!!! */
+
+#ifndef _BITS_SYSNUM_H
+#define _BITS_SYSNUM_H
+
+#ifndef _SYSCALL_H
+# error "Never use <bits/sysnum.h> directly; include <sys/syscall.h> instead."
+#endif
+
+#undef __NR_Linux
+#define __NR_Linux 4000
+#define SYS_Linux __NR_Linux
+#undef __NR_syscall
+#define __NR_syscall (4000 + 0)
+#define SYS_syscall __NR_syscall
+#undef __NR_exit
+#define __NR_exit (4000 + 1)
+#define SYS_exit __NR_exit
+#undef __NR_fork
+#define __NR_fork (4000 + 2)
+#define SYS_fork __NR_fork
+#undef __NR_read
+#define __NR_read (4000 + 3)
+#define SYS_read __NR_read
+#undef __NR_write
+#define __NR_write (4000 + 4)
+#define SYS_write __NR_write
+#undef __NR_open
+#define __NR_open (4000 + 5)
+#define SYS_open __NR_open
+#undef __NR_close
+#define __NR_close (4000 + 6)
+#define SYS_close __NR_close
+#undef __NR_waitpid
+#define __NR_waitpid (4000 + 7)
+#define SYS_waitpid __NR_waitpid
+#undef __NR_creat
+#define __NR_creat (4000 + 8)
+#define SYS_creat __NR_creat
+#undef __NR_link
+#define __NR_link (4000 + 9)
+#define SYS_link __NR_link
+#undef __NR_unlink
+#define __NR_unlink (4000 + 10)
+#define SYS_unlink __NR_unlink
+#undef __NR_execve
+#define __NR_execve (4000 + 11)
+#define SYS_execve __NR_execve
+#undef __NR_chdir
+#define __NR_chdir (4000 + 12)
+#define SYS_chdir __NR_chdir
+#undef __NR_time
+#define __NR_time (4000 + 13)
+#define SYS_time __NR_time
+#undef __NR_mknod
+#define __NR_mknod (4000 + 14)
+#define SYS_mknod __NR_mknod
+#undef __NR_chmod
+#define __NR_chmod (4000 + 15)
+#define SYS_chmod __NR_chmod
+#undef __NR_lchown
+#define __NR_lchown (4000 + 16)
+#define SYS_lchown __NR_lchown
+#undef __NR_break
+#define __NR_break (4000 + 17)
+#define SYS_break __NR_break
+#undef __NR_unused18
+#define __NR_unused18 (4000 + 18)
+#define SYS_unused18 __NR_unused18
+#undef __NR_lseek
+#define __NR_lseek (4000 + 19)
+#define SYS_lseek __NR_lseek
+#undef __NR_getpid
+#define __NR_getpid (4000 + 20)
+#define SYS_getpid __NR_getpid
+#undef __NR_mount
+#define __NR_mount (4000 + 21)
+#define SYS_mount __NR_mount
+#undef __NR_umount
+#define __NR_umount (4000 + 22)
+#define SYS_umount __NR_umount
+#undef __NR_setuid
+#define __NR_setuid (4000 + 23)
+#define SYS_setuid __NR_setuid
+#undef __NR_getuid
+#define __NR_getuid (4000 + 24)
+#define SYS_getuid __NR_getuid
+#undef __NR_stime
+#define __NR_stime (4000 + 25)
+#define SYS_stime __NR_stime
+#undef __NR_ptrace
+#define __NR_ptrace (4000 + 26)
+#define SYS_ptrace __NR_ptrace
+#undef __NR_alarm
+#define __NR_alarm (4000 + 27)
+#define SYS_alarm __NR_alarm
+#undef __NR_unused28
+#define __NR_unused28 (4000 + 28)
+#define SYS_unused28 __NR_unused28
+#undef __NR_pause
+#define __NR_pause (4000 + 29)
+#define SYS_pause __NR_pause
+#undef __NR_utime
+#define __NR_utime (4000 + 30)
+#define SYS_utime __NR_utime
+#undef __NR_stty
+#define __NR_stty (4000 + 31)
+#define SYS_stty __NR_stty
+#undef __NR_gtty
+#define __NR_gtty (4000 + 32)
+#define SYS_gtty __NR_gtty
+#undef __NR_access
+#define __NR_access (4000 + 33)
+#define SYS_access __NR_access
+#undef __NR_nice
+#define __NR_nice (4000 + 34)
+#define SYS_nice __NR_nice
+#undef __NR_ftime
+#define __NR_ftime (4000 + 35)
+#define SYS_ftime __NR_ftime
+#undef __NR_sync
+#define __NR_sync (4000 + 36)
+#define SYS_sync __NR_sync
+#undef __NR_kill
+#define __NR_kill (4000 + 37)
+#define SYS_kill __NR_kill
+#undef __NR_rename
+#define __NR_rename (4000 + 38)
+#define SYS_rename __NR_rename
+#undef __NR_mkdir
+#define __NR_mkdir (4000 + 39)
+#define SYS_mkdir __NR_mkdir
+#undef __NR_rmdir
+#define __NR_rmdir (4000 + 40)
+#define SYS_rmdir __NR_rmdir
+#undef __NR_dup
+#define __NR_dup (4000 + 41)
+#define SYS_dup __NR_dup
+#undef __NR_pipe
+#define __NR_pipe (4000 + 42)
+#define SYS_pipe __NR_pipe
+#undef __NR_times
+#define __NR_times (4000 + 43)
+#define SYS_times __NR_times
+#undef __NR_prof
+#define __NR_prof (4000 + 44)
+#define SYS_prof __NR_prof
+#undef __NR_brk
+#define __NR_brk (4000 + 45)
+#define SYS_brk __NR_brk
+#undef __NR_setgid
+#define __NR_setgid (4000 + 46)
+#define SYS_setgid __NR_setgid
+#undef __NR_getgid
+#define __NR_getgid (4000 + 47)
+#define SYS_getgid __NR_getgid
+#undef __NR_signal
+#define __NR_signal (4000 + 48)
+#define SYS_signal __NR_signal
+#undef __NR_geteuid
+#define __NR_geteuid (4000 + 49)
+#define SYS_geteuid __NR_geteuid
+#undef __NR_getegid
+#define __NR_getegid (4000 + 50)
+#define SYS_getegid __NR_getegid
+#undef __NR_acct
+#define __NR_acct (4000 + 51)
+#define SYS_acct __NR_acct
+#undef __NR_umount2
+#define __NR_umount2 (4000 + 52)
+#define SYS_umount2 __NR_umount2
+#undef __NR_lock
+#define __NR_lock (4000 + 53)
+#define SYS_lock __NR_lock
+#undef __NR_ioctl
+#define __NR_ioctl (4000 + 54)
+#define SYS_ioctl __NR_ioctl
+#undef __NR_fcntl
+#define __NR_fcntl (4000 + 55)
+#define SYS_fcntl __NR_fcntl
+#undef __NR_mpx
+#define __NR_mpx (4000 + 56)
+#define SYS_mpx __NR_mpx
+#undef __NR_setpgid
+#define __NR_setpgid (4000 + 57)
+#define SYS_setpgid __NR_setpgid
+#undef __NR_ulimit
+#define __NR_ulimit (4000 + 58)
+#define SYS_ulimit __NR_ulimit
+#undef __NR_unused59
+#define __NR_unused59 (4000 + 59)
+#define SYS_unused59 __NR_unused59
+#undef __NR_umask
+#define __NR_umask (4000 + 60)
+#define SYS_umask __NR_umask
+#undef __NR_chroot
+#define __NR_chroot (4000 + 61)
+#define SYS_chroot __NR_chroot
+#undef __NR_ustat
+#define __NR_ustat (4000 + 62)
+#define SYS_ustat __NR_ustat
+#undef __NR_dup2
+#define __NR_dup2 (4000 + 63)
+#define SYS_dup2 __NR_dup2
+#undef __NR_getppid
+#define __NR_getppid (4000 + 64)
+#define SYS_getppid __NR_getppid
+#undef __NR_getpgrp
+#define __NR_getpgrp (4000 + 65)
+#define SYS_getpgrp __NR_getpgrp
+#undef __NR_setsid
+#define __NR_setsid (4000 + 66)
+#define SYS_setsid __NR_setsid
+#undef __NR_sigaction
+#define __NR_sigaction (4000 + 67)
+#define SYS_sigaction __NR_sigaction
+#undef __NR_sgetmask
+#define __NR_sgetmask (4000 + 68)
+#define SYS_sgetmask __NR_sgetmask
+#undef __NR_ssetmask
+#define __NR_ssetmask (4000 + 69)
+#define SYS_ssetmask __NR_ssetmask
+#undef __NR_setreuid
+#define __NR_setreuid (4000 + 70)
+#define SYS_setreuid __NR_setreuid
+#undef __NR_setregid
+#define __NR_setregid (4000 + 71)
+#define SYS_setregid __NR_setregid
+#undef __NR_sigsuspend
+#define __NR_sigsuspend (4000 + 72)
+#define SYS_sigsuspend __NR_sigsuspend
+#undef __NR_sigpending
+#define __NR_sigpending (4000 + 73)
+#define SYS_sigpending __NR_sigpending
+#undef __NR_sethostname
+#define __NR_sethostname (4000 + 74)
+#define SYS_sethostname __NR_sethostname
+#undef __NR_setrlimit
+#define __NR_setrlimit (4000 + 75)
+#define SYS_setrlimit __NR_setrlimit
+#undef __NR_getrlimit
+#define __NR_getrlimit (4000 + 76)
+#define SYS_getrlimit __NR_getrlimit
+#undef __NR_getrusage
+#define __NR_getrusage (4000 + 77)
+#define SYS_getrusage __NR_getrusage
+#undef __NR_gettimeofday
+#define __NR_gettimeofday (4000 + 78)
+#define SYS_gettimeofday __NR_gettimeofday
+#undef __NR_settimeofday
+#define __NR_settimeofday (4000 + 79)
+#define SYS_settimeofday __NR_settimeofday
+#undef __NR_getgroups
+#define __NR_getgroups (4000 + 80)
+#define SYS_getgroups __NR_getgroups
+#undef __NR_setgroups
+#define __NR_setgroups (4000 + 81)
+#define SYS_setgroups __NR_setgroups
+#undef __NR_reserved82
+#define __NR_reserved82 (4000 + 82)
+#define SYS_reserved82 __NR_reserved82
+#undef __NR_symlink
+#define __NR_symlink (4000 + 83)
+#define SYS_symlink __NR_symlink
+#undef __NR_unused84
+#define __NR_unused84 (4000 + 84)
+#define SYS_unused84 __NR_unused84
+#undef __NR_readlink
+#define __NR_readlink (4000 + 85)
+#define SYS_readlink __NR_readlink
+#undef __NR_uselib
+#define __NR_uselib (4000 + 86)
+#define SYS_uselib __NR_uselib
+#undef __NR_swapon
+#define __NR_swapon (4000 + 87)
+#define SYS_swapon __NR_swapon
+#undef __NR_reboot
+#define __NR_reboot (4000 + 88)
+#define SYS_reboot __NR_reboot
+#undef __NR_readdir
+#define __NR_readdir (4000 + 89)
+#define SYS_readdir __NR_readdir
+#undef __NR_mmap
+#define __NR_mmap (4000 + 90)
+#define SYS_mmap __NR_mmap
+#undef __NR_munmap
+#define __NR_munmap (4000 + 91)
+#define SYS_munmap __NR_munmap
+#undef __NR_truncate
+#define __NR_truncate (4000 + 92)
+#define SYS_truncate __NR_truncate
+#undef __NR_ftruncate
+#define __NR_ftruncate (4000 + 93)
+#define SYS_ftruncate __NR_ftruncate
+#undef __NR_fchmod
+#define __NR_fchmod (4000 + 94)
+#define SYS_fchmod __NR_fchmod
+#undef __NR_fchown
+#define __NR_fchown (4000 + 95)
+#define SYS_fchown __NR_fchown
+#undef __NR_getpriority
+#define __NR_getpriority (4000 + 96)
+#define SYS_getpriority __NR_getpriority
+#undef __NR_setpriority
+#define __NR_setpriority (4000 + 97)
+#define SYS_setpriority __NR_setpriority
+#undef __NR_profil
+#define __NR_profil (4000 + 98)
+#define SYS_profil __NR_profil
+#undef __NR_statfs
+#define __NR_statfs (4000 + 99)
+#define SYS_statfs __NR_statfs
+#undef __NR_fstatfs
+#define __NR_fstatfs (4000 + 100)
+#define SYS_fstatfs __NR_fstatfs
+#undef __NR_ioperm
+#define __NR_ioperm (4000 + 101)
+#define SYS_ioperm __NR_ioperm
+#undef __NR_socketcall
+#define __NR_socketcall (4000 + 102)
+#define SYS_socketcall __NR_socketcall
+#undef __NR_syslog
+#define __NR_syslog (4000 + 103)
+#define SYS_syslog __NR_syslog
+#undef __NR_setitimer
+#define __NR_setitimer (4000 + 104)
+#define SYS_setitimer __NR_setitimer
+#undef __NR_getitimer
+#define __NR_getitimer (4000 + 105)
+#define SYS_getitimer __NR_getitimer
+#undef __NR_stat
+#define __NR_stat (4000 + 106)
+#define SYS_stat __NR_stat
+#undef __NR_lstat
+#define __NR_lstat (4000 + 107)
+#define SYS_lstat __NR_lstat
+#undef __NR_fstat
+#define __NR_fstat (4000 + 108)
+#define SYS_fstat __NR_fstat
+#undef __NR_unused109
+#define __NR_unused109 (4000 + 109)
+#define SYS_unused109 __NR_unused109
+#undef __NR_iopl
+#define __NR_iopl (4000 + 110)
+#define SYS_iopl __NR_iopl
+#undef __NR_vhangup
+#define __NR_vhangup (4000 + 111)
+#define SYS_vhangup __NR_vhangup
+#undef __NR_idle
+#define __NR_idle (4000 + 112)
+#define SYS_idle __NR_idle
+#undef __NR_vm86
+#define __NR_vm86 (4000 + 113)
+#define SYS_vm86 __NR_vm86
+#undef __NR_wait4
+#define __NR_wait4 (4000 + 114)
+#define SYS_wait4 __NR_wait4
+#undef __NR_swapoff
+#define __NR_swapoff (4000 + 115)
+#define SYS_swapoff __NR_swapoff
+#undef __NR_sysinfo
+#define __NR_sysinfo (4000 + 116)
+#define SYS_sysinfo __NR_sysinfo
+#undef __NR_ipc
+#define __NR_ipc (4000 + 117)
+#define SYS_ipc __NR_ipc
+#undef __NR_fsync
+#define __NR_fsync (4000 + 118)
+#define SYS_fsync __NR_fsync
+#undef __NR_sigreturn
+#define __NR_sigreturn (4000 + 119)
+#define SYS_sigreturn __NR_sigreturn
+#undef __NR_clone
+#define __NR_clone (4000 + 120)
+#define SYS_clone __NR_clone
+#undef __NR_setdomainname
+#define __NR_setdomainname (4000 + 121)
+#define SYS_setdomainname __NR_setdomainname
+#undef __NR_uname
+#define __NR_uname (4000 + 122)
+#define SYS_uname __NR_uname
+#undef __NR_modify_ldt
+#define __NR_modify_ldt (4000 + 123)
+#define SYS_modify_ldt __NR_modify_ldt
+#undef __NR_adjtimex
+#define __NR_adjtimex (4000 + 124)
+#define SYS_adjtimex __NR_adjtimex
+#undef __NR_mprotect
+#define __NR_mprotect (4000 + 125)
+#define SYS_mprotect __NR_mprotect
+#undef __NR_sigprocmask
+#define __NR_sigprocmask (4000 + 126)
+#define SYS_sigprocmask __NR_sigprocmask
+#undef __NR_create_module
+#define __NR_create_module (4000 + 127)
+#define SYS_create_module __NR_create_module
+#undef __NR_init_module
+#define __NR_init_module (4000 + 128)
+#define SYS_init_module __NR_init_module
+#undef __NR_delete_module
+#define __NR_delete_module (4000 + 129)
+#define SYS_delete_module __NR_delete_module
+#undef __NR_get_kernel_syms
+#define __NR_get_kernel_syms (4000 + 130)
+#define SYS_get_kernel_syms __NR_get_kernel_syms
+#undef __NR_quotactl
+#define __NR_quotactl (4000 + 131)
+#define SYS_quotactl __NR_quotactl
+#undef __NR_getpgid
+#define __NR_getpgid (4000 + 132)
+#define SYS_getpgid __NR_getpgid
+#undef __NR_fchdir
+#define __NR_fchdir (4000 + 133)
+#define SYS_fchdir __NR_fchdir
+#undef __NR_bdflush
+#define __NR_bdflush (4000 + 134)
+#define SYS_bdflush __NR_bdflush
+#undef __NR_sysfs
+#define __NR_sysfs (4000 + 135)
+#define SYS_sysfs __NR_sysfs
+#undef __NR_personality
+#define __NR_personality (4000 + 136)
+#define SYS_personality __NR_personality
+#undef __NR_afs_syscall
+#define __NR_afs_syscall (4000 + 137)
+#define SYS_afs_syscall __NR_afs_syscall
+#undef __NR_setfsuid
+#define __NR_setfsuid (4000 + 138)
+#define SYS_setfsuid __NR_setfsuid
+#undef __NR_setfsgid
+#define __NR_setfsgid (4000 + 139)
+#define SYS_setfsgid __NR_setfsgid
+#undef __NR__llseek
+#define __NR__llseek (4000 + 140)
+#define SYS__llseek __NR__llseek
+#undef __NR_getdents
+#define __NR_getdents (4000 + 141)
+#define SYS_getdents __NR_getdents
+#undef __NR__newselect
+#define __NR__newselect (4000 + 142)
+#define SYS__newselect __NR__newselect
+#undef __NR_flock
+#define __NR_flock (4000 + 143)
+#define SYS_flock __NR_flock
+#undef __NR_msync
+#define __NR_msync (4000 + 144)
+#define SYS_msync __NR_msync
+#undef __NR_readv
+#define __NR_readv (4000 + 145)
+#define SYS_readv __NR_readv
+#undef __NR_writev
+#define __NR_writev (4000 + 146)
+#define SYS_writev __NR_writev
+#undef __NR_cacheflush
+#define __NR_cacheflush (4000 + 147)
+#define SYS_cacheflush __NR_cacheflush
+#undef __NR_cachectl
+#define __NR_cachectl (4000 + 148)
+#define SYS_cachectl __NR_cachectl
+#undef __NR_sysmips
+#define __NR_sysmips (4000 + 149)
+#define SYS_sysmips __NR_sysmips
+#undef __NR_unused150
+#define __NR_unused150 (4000 + 150)
+#define SYS_unused150 __NR_unused150
+#undef __NR_getsid
+#define __NR_getsid (4000 + 151)
+#define SYS_getsid __NR_getsid
+#undef __NR_fdatasync
+#define __NR_fdatasync (4000 + 152)
+#define SYS_fdatasync __NR_fdatasync
+#undef __NR__sysctl
+#define __NR__sysctl (4000 + 153)
+#define SYS__sysctl __NR__sysctl
+#undef __NR_mlock
+#define __NR_mlock (4000 + 154)
+#define SYS_mlock __NR_mlock
+#undef __NR_munlock
+#define __NR_munlock (4000 + 155)
+#define SYS_munlock __NR_munlock
+#undef __NR_mlockall
+#define __NR_mlockall (4000 + 156)
+#define SYS_mlockall __NR_mlockall
+#undef __NR_munlockall
+#define __NR_munlockall (4000 + 157)
+#define SYS_munlockall __NR_munlockall
+#undef __NR_sched_setparam
+#define __NR_sched_setparam (4000 + 158)
+#define SYS_sched_setparam __NR_sched_setparam
+#undef __NR_sched_getparam
+#define __NR_sched_getparam (4000 + 159)
+#define SYS_sched_getparam __NR_sched_getparam
+#undef __NR_sched_setscheduler
+#define __NR_sched_setscheduler (4000 + 160)
+#define SYS_sched_setscheduler __NR_sched_setscheduler
+#undef __NR_sched_getscheduler
+#define __NR_sched_getscheduler (4000 + 161)
+#define SYS_sched_getscheduler __NR_sched_getscheduler
+#undef __NR_sched_yield
+#define __NR_sched_yield (4000 + 162)
+#define SYS_sched_yield __NR_sched_yield
+#undef __NR_sched_get_priority_max
+#define __NR_sched_get_priority_max (4000 + 163)
+#define SYS_sched_get_priority_max __NR_sched_get_priority_max
+#undef __NR_sched_get_priority_min
+#define __NR_sched_get_priority_min (4000 + 164)
+#define SYS_sched_get_priority_min __NR_sched_get_priority_min
+#undef __NR_sched_rr_get_interval
+#define __NR_sched_rr_get_interval (4000 + 165)
+#define SYS_sched_rr_get_interval __NR_sched_rr_get_interval
+#undef __NR_nanosleep
+#define __NR_nanosleep (4000 + 166)
+#define SYS_nanosleep __NR_nanosleep
+#undef __NR_mremap
+#define __NR_mremap (4000 + 167)
+#define SYS_mremap __NR_mremap
+#undef __NR_accept
+#define __NR_accept (4000 + 168)
+#define SYS_accept __NR_accept
+#undef __NR_bind
+#define __NR_bind (4000 + 169)
+#define SYS_bind __NR_bind
+#undef __NR_connect
+#define __NR_connect (4000 + 170)
+#define SYS_connect __NR_connect
+#undef __NR_getpeername
+#define __NR_getpeername (4000 + 171)
+#define SYS_getpeername __NR_getpeername
+#undef __NR_getsockname
+#define __NR_getsockname (4000 + 172)
+#define SYS_getsockname __NR_getsockname
+#undef __NR_getsockopt
+#define __NR_getsockopt (4000 + 173)
+#define SYS_getsockopt __NR_getsockopt
+#undef __NR_listen
+#define __NR_listen (4000 + 174)
+#define SYS_listen __NR_listen
+#undef __NR_recv
+#define __NR_recv (4000 + 175)
+#define SYS_recv __NR_recv
+#undef __NR_recvfrom
+#define __NR_recvfrom (4000 + 176)
+#define SYS_recvfrom __NR_recvfrom
+#undef __NR_recvmsg
+#define __NR_recvmsg (4000 + 177)
+#define SYS_recvmsg __NR_recvmsg
+#undef __NR_send
+#define __NR_send (4000 + 178)
+#define SYS_send __NR_send
+#undef __NR_sendmsg
+#define __NR_sendmsg (4000 + 179)
+#define SYS_sendmsg __NR_sendmsg
+#undef __NR_sendto
+#define __NR_sendto (4000 + 180)
+#define SYS_sendto __NR_sendto
+#undef __NR_setsockopt
+#define __NR_setsockopt (4000 + 181)
+#define SYS_setsockopt __NR_setsockopt
+#undef __NR_shutdown
+#define __NR_shutdown (4000 + 182)
+#define SYS_shutdown __NR_shutdown
+#undef __NR_socket
+#define __NR_socket (4000 + 183)
+#define SYS_socket __NR_socket
+#undef __NR_socketpair
+#define __NR_socketpair (4000 + 184)
+#define SYS_socketpair __NR_socketpair
+#undef __NR_setresuid
+#define __NR_setresuid (4000 + 185)
+#define SYS_setresuid __NR_setresuid
+#undef __NR_getresuid
+#define __NR_getresuid (4000 + 186)
+#define SYS_getresuid __NR_getresuid
+#undef __NR_query_module
+#define __NR_query_module (4000 + 187)
+#define SYS_query_module __NR_query_module
+#undef __NR_poll
+#define __NR_poll (4000 + 188)
+#define SYS_poll __NR_poll
+#undef __NR_nfsservctl
+#define __NR_nfsservctl (4000 + 189)
+#define SYS_nfsservctl __NR_nfsservctl
+#undef __NR_setresgid
+#define __NR_setresgid (4000 + 190)
+#define SYS_setresgid __NR_setresgid
+#undef __NR_getresgid
+#define __NR_getresgid (4000 + 191)
+#define SYS_getresgid __NR_getresgid
+#undef __NR_prctl
+#define __NR_prctl (4000 + 192)
+#define SYS_prctl __NR_prctl
+#undef __NR_rt_sigreturn
+#define __NR_rt_sigreturn (4000 + 193)
+#define SYS_rt_sigreturn __NR_rt_sigreturn
+#undef __NR_rt_sigaction
+#define __NR_rt_sigaction (4000 + 194)
+#define SYS_rt_sigaction __NR_rt_sigaction
+#undef __NR_rt_sigprocmask
+#define __NR_rt_sigprocmask (4000 + 195)
+#define SYS_rt_sigprocmask __NR_rt_sigprocmask
+#undef __NR_rt_sigpending
+#define __NR_rt_sigpending (4000 + 196)
+#define SYS_rt_sigpending __NR_rt_sigpending
+#undef __NR_rt_sigtimedwait
+#define __NR_rt_sigtimedwait (4000 + 197)
+#define SYS_rt_sigtimedwait __NR_rt_sigtimedwait
+#undef __NR_rt_sigqueueinfo
+#define __NR_rt_sigqueueinfo (4000 + 198)
+#define SYS_rt_sigqueueinfo __NR_rt_sigqueueinfo
+#undef __NR_rt_sigsuspend
+#define __NR_rt_sigsuspend (4000 + 199)
+#define SYS_rt_sigsuspend __NR_rt_sigsuspend
+#undef __NR_pread64
+#define __NR_pread64 (4000 + 200)
+#define SYS_pread64 __NR_pread64
+#undef __NR_pwrite64
+#define __NR_pwrite64 (4000 + 201)
+#define SYS_pwrite64 __NR_pwrite64
+#undef __NR_chown
+#define __NR_chown (4000 + 202)
+#define SYS_chown __NR_chown
+#undef __NR_getcwd
+#define __NR_getcwd (4000 + 203)
+#define SYS_getcwd __NR_getcwd
+#undef __NR_capget
+#define __NR_capget (4000 + 204)
+#define SYS_capget __NR_capget
+#undef __NR_capset
+#define __NR_capset (4000 + 205)
+#define SYS_capset __NR_capset
+#undef __NR_sigaltstack
+#define __NR_sigaltstack (4000 + 206)
+#define SYS_sigaltstack __NR_sigaltstack
+#undef __NR_sendfile
+#define __NR_sendfile (4000 + 207)
+#define SYS_sendfile __NR_sendfile
+#undef __NR_getpmsg
+#define __NR_getpmsg (4000 + 208)
+#define SYS_getpmsg __NR_getpmsg
+#undef __NR_putpmsg
+#define __NR_putpmsg (4000 + 209)
+#define SYS_putpmsg __NR_putpmsg
+#undef __NR_mmap2
+#define __NR_mmap2 (4000 + 210)
+#define SYS_mmap2 __NR_mmap2
+#undef __NR_truncate64
+#define __NR_truncate64 (4000 + 211)
+#define SYS_truncate64 __NR_truncate64
+#undef __NR_ftruncate64
+#define __NR_ftruncate64 (4000 + 212)
+#define SYS_ftruncate64 __NR_ftruncate64
+#undef __NR_stat64
+#define __NR_stat64 (4000 + 213)
+#define SYS_stat64 __NR_stat64
+#undef __NR_lstat64
+#define __NR_lstat64 (4000 + 214)
+#define SYS_lstat64 __NR_lstat64
+#undef __NR_fstat64
+#define __NR_fstat64 (4000 + 215)
+#define SYS_fstat64 __NR_fstat64
+#undef __NR_pivot_root
+#define __NR_pivot_root (4000 + 216)
+#define SYS_pivot_root __NR_pivot_root
+#undef __NR_mincore
+#define __NR_mincore (4000 + 217)
+#define SYS_mincore __NR_mincore
+#undef __NR_madvise
+#define __NR_madvise (4000 + 218)
+#define SYS_madvise __NR_madvise
+#undef __NR_getdents64
+#define __NR_getdents64 (4000 + 219)
+#define SYS_getdents64 __NR_getdents64
+#undef __NR_fcntl64
+#define __NR_fcntl64 (4000 + 220)
+#define SYS_fcntl64 __NR_fcntl64
+#undef __NR_reserved221
+#define __NR_reserved221 (4000 + 221)
+#define SYS_reserved221 __NR_reserved221
+#undef __NR_gettid
+#define __NR_gettid (4000 + 222)
+#define SYS_gettid __NR_gettid
+#undef __NR_readahead
+#define __NR_readahead (4000 + 223)
+#define SYS_readahead __NR_readahead
+#undef __NR_setxattr
+#define __NR_setxattr (4000 + 224)
+#define SYS_setxattr __NR_setxattr
+#undef __NR_lsetxattr
+#define __NR_lsetxattr (4000 + 225)
+#define SYS_lsetxattr __NR_lsetxattr
+#undef __NR_fsetxattr
+#define __NR_fsetxattr (4000 + 226)
+#define SYS_fsetxattr __NR_fsetxattr
+#undef __NR_getxattr
+#define __NR_getxattr (4000 + 227)
+#define SYS_getxattr __NR_getxattr
+#undef __NR_lgetxattr
+#define __NR_lgetxattr (4000 + 228)
+#define SYS_lgetxattr __NR_lgetxattr
+#undef __NR_fgetxattr
+#define __NR_fgetxattr (4000 + 229)
+#define SYS_fgetxattr __NR_fgetxattr
+#undef __NR_listxattr
+#define __NR_listxattr (4000 + 230)
+#define SYS_listxattr __NR_listxattr
+#undef __NR_llistxattr
+#define __NR_llistxattr (4000 + 231)
+#define SYS_llistxattr __NR_llistxattr
+#undef __NR_flistxattr
+#define __NR_flistxattr (4000 + 232)
+#define SYS_flistxattr __NR_flistxattr
+#undef __NR_removexattr
+#define __NR_removexattr (4000 + 233)
+#define SYS_removexattr __NR_removexattr
+#undef __NR_lremovexattr
+#define __NR_lremovexattr (4000 + 234)
+#define SYS_lremovexattr __NR_lremovexattr
+#undef __NR_fremovexattr
+#define __NR_fremovexattr (4000 + 235)
+#define SYS_fremovexattr __NR_fremovexattr
+#undef __NR_tkill
+#define __NR_tkill (4000 + 236)
+#define SYS_tkill __NR_tkill
+#undef __NR_sendfile64
+#define __NR_sendfile64 (4000 + 237)
+#define SYS_sendfile64 __NR_sendfile64
+#undef __NR_futex
+#define __NR_futex (4000 + 238)
+#define SYS_futex __NR_futex
+#undef __NR_sched_setaffinity
+#define __NR_sched_setaffinity (4000 + 239)
+#define SYS_sched_setaffinity __NR_sched_setaffinity
+#undef __NR_sched_getaffinity
+#define __NR_sched_getaffinity (4000 + 240)
+#define SYS_sched_getaffinity __NR_sched_getaffinity
+#undef __NR_io_setup
+#define __NR_io_setup (4000 + 241)
+#define SYS_io_setup __NR_io_setup
+#undef __NR_io_destroy
+#define __NR_io_destroy (4000 + 242)
+#define SYS_io_destroy __NR_io_destroy
+#undef __NR_io_getevents
+#define __NR_io_getevents (4000 + 243)
+#define SYS_io_getevents __NR_io_getevents
+#undef __NR_io_submit
+#define __NR_io_submit (4000 + 244)
+#define SYS_io_submit __NR_io_submit
+#undef __NR_io_cancel
+#define __NR_io_cancel (4000 + 245)
+#define SYS_io_cancel __NR_io_cancel
+#undef __NR_exit_group
+#define __NR_exit_group (4000 + 246)
+#define SYS_exit_group __NR_exit_group
+#undef __NR_lookup_dcookie
+#define __NR_lookup_dcookie (4000 + 247)
+#define SYS_lookup_dcookie __NR_lookup_dcookie
+#undef __NR_epoll_create
+#define __NR_epoll_create (4000 + 248)
+#define SYS_epoll_create __NR_epoll_create
+#undef __NR_epoll_ctl
+#define __NR_epoll_ctl (4000 + 249)
+#define SYS_epoll_ctl __NR_epoll_ctl
+#undef __NR_epoll_wait
+#define __NR_epoll_wait (4000 + 250)
+#define SYS_epoll_wait __NR_epoll_wait
+#undef __NR_remap_file_pages
+#define __NR_remap_file_pages (4000 + 251)
+#define SYS_remap_file_pages __NR_remap_file_pages
+#undef __NR_set_tid_address
+#define __NR_set_tid_address (4000 + 252)
+#define SYS_set_tid_address __NR_set_tid_address
+#undef __NR_restart_syscall
+#define __NR_restart_syscall (4000 + 253)
+#define SYS_restart_syscall __NR_restart_syscall
+#undef __NR_fadvise64
+#define __NR_fadvise64 (4000 + 254)
+#define SYS_fadvise64 __NR_fadvise64
+#undef __NR_statfs64
+#define __NR_statfs64 (4000 + 255)
+#define SYS_statfs64 __NR_statfs64
+#undef __NR_fstatfs64
+#define __NR_fstatfs64 (4000 + 256)
+#define SYS_fstatfs64 __NR_fstatfs64
+#undef __NR_timer_create
+#define __NR_timer_create (4000 + 257)
+#define SYS_timer_create __NR_timer_create
+#undef __NR_timer_settime
+#define __NR_timer_settime (4000 + 258)
+#define SYS_timer_settime __NR_timer_settime
+#undef __NR_timer_gettime
+#define __NR_timer_gettime (4000 + 259)
+#define SYS_timer_gettime __NR_timer_gettime
+#undef __NR_timer_getoverrun
+#define __NR_timer_getoverrun (4000 + 260)
+#define SYS_timer_getoverrun __NR_timer_getoverrun
+#undef __NR_timer_delete
+#define __NR_timer_delete (4000 + 261)
+#define SYS_timer_delete __NR_timer_delete
+#undef __NR_clock_settime
+#define __NR_clock_settime (4000 + 262)
+#define SYS_clock_settime __NR_clock_settime
+#undef __NR_clock_gettime
+#define __NR_clock_gettime (4000 + 263)
+#define SYS_clock_gettime __NR_clock_gettime
+#undef __NR_clock_getres
+#define __NR_clock_getres (4000 + 264)
+#define SYS_clock_getres __NR_clock_getres
+#undef __NR_clock_nanosleep
+#define __NR_clock_nanosleep (4000 + 265)
+#define SYS_clock_nanosleep __NR_clock_nanosleep
+#undef __NR_tgkill
+#define __NR_tgkill (4000 + 266)
+#define SYS_tgkill __NR_tgkill
+#undef __NR_utimes
+#define __NR_utimes (4000 + 267)
+#define SYS_utimes __NR_utimes
+#undef __NR_mbind
+#define __NR_mbind (4000 + 268)
+#define SYS_mbind __NR_mbind
+#undef __NR_get_mempolicy
+#define __NR_get_mempolicy (4000 + 269)
+#define SYS_get_mempolicy __NR_get_mempolicy
+#undef __NR_set_mempolicy
+#define __NR_set_mempolicy (4000 + 270)
+#define SYS_set_mempolicy __NR_set_mempolicy
+#undef __NR_mq_open
+#define __NR_mq_open (4000 + 271)
+#define SYS_mq_open __NR_mq_open
+#undef __NR_mq_unlink
+#define __NR_mq_unlink (4000 + 272)
+#define SYS_mq_unlink __NR_mq_unlink
+#undef __NR_mq_timedsend
+#define __NR_mq_timedsend (4000 + 273)
+#define SYS_mq_timedsend __NR_mq_timedsend
+#undef __NR_mq_timedreceive
+#define __NR_mq_timedreceive (4000 + 274)
+#define SYS_mq_timedreceive __NR_mq_timedreceive
+#undef __NR_mq_notify
+#define __NR_mq_notify (4000 + 275)
+#define SYS_mq_notify __NR_mq_notify
+#undef __NR_mq_getsetattr
+#define __NR_mq_getsetattr (4000 + 276)
+#define SYS_mq_getsetattr __NR_mq_getsetattr
+#undef __NR_vserver
+#define __NR_vserver (4000 + 277)
+#define SYS_vserver __NR_vserver
+#undef __NR_waitid
+#define __NR_waitid (4000 + 278)
+#define SYS_waitid __NR_waitid
+#undef __NR_add_key
+#define __NR_add_key (4000 + 280)
+#define SYS_add_key __NR_add_key
+#undef __NR_request_key
+#define __NR_request_key (4000 + 281)
+#define SYS_request_key __NR_request_key
+#undef __NR_keyctl
+#define __NR_keyctl (4000 + 282)
+#define SYS_keyctl __NR_keyctl
+#undef __NR_Linux_syscalls
+#define __NR_Linux_syscalls 282
+#define SYS_Linux_syscalls __NR_Linux_syscalls
+#undef __NR_O32_Linux
+#define __NR_O32_Linux 4000
+#define SYS_O32_Linux __NR_O32_Linux
+#undef __NR_O32_Linux_syscalls
+#define __NR_O32_Linux_syscalls 282
+#define SYS_O32_Linux_syscalls __NR_O32_Linux_syscalls
+#undef __NR_64_Linux
+#define __NR_64_Linux 5000
+#define SYS_64_Linux __NR_64_Linux
+#undef __NR_64_Linux_syscalls
+#define __NR_64_Linux_syscalls 241
+#define SYS_64_Linux_syscalls __NR_64_Linux_syscalls
+#undef __NR_N32_Linux
+#define __NR_N32_Linux 6000
+#define SYS_N32_Linux __NR_N32_Linux
+#undef __NR_N32_Linux_syscalls
+#define __NR_N32_Linux_syscalls 245
+#define SYS_N32_Linux_syscalls __NR_N32_Linux_syscalls
+
+#endif
diff -pruwN busybox-1.01/include2/bits/termios.h busybox-1.01-livebox/include2/bits/termios.h
--- busybox-1.01/include2/bits/termios.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/termios.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,217 @@
+/* termios type and macro definitions.  Linux/MIPS version.
+   Copyright (C) 1993, 94, 95, 96, 97, 99 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios.h> directly; use <termios.h> instead."
+#endif
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 32
+struct termios
+  {
+    tcflag_t c_iflag;		/* input mode flags */
+    tcflag_t c_oflag;		/* output mode flags */
+    tcflag_t c_cflag;		/* control mode flags */
+    tcflag_t c_lflag;		/* local mode flags */
+    cc_t c_line;		/* line discipline */
+    cc_t c_cc[NCCS];		/* control characters */
+  };
+
+/* c_cc characters */
+#define VINTR		0	/* Interrupt character [ISIG].  */
+#define VQUIT		1	/* Quit character [ISIG].  */
+#define VERASE		2	/* Erase character [ICANON].  */
+#define VKILL		3	/* Kill-line character [ICANON].  */
+#define VMIN		4	/* Minimum number of bytes read at once [!ICANON].  */
+#define VTIME		5	/* Time-out value (tenths of a second) [!ICANON].  */
+#define VEOL2		6	/* Second EOL character [ICANON].  */
+#define VSWTC		7
+#define VSWTCH		VSWTC
+#define VSTART		8	/* Start (X-ON) character [IXON, IXOFF].  */
+#define VSTOP		9	/* Stop (X-OFF) character [IXON, IXOFF].  */
+#define VSUSP		10	/* Suspend character [ISIG].  */
+				/* VDSUSP is not supported on Linux. */
+/* #define VDSUSP	11	/ * Delayed suspend character [ISIG].  */
+#define VREPRINT	12	/* Reprint-line character [ICANON].  */
+#define VDISCARD	13	/* Discard character [IEXTEN].  */
+#define VWERASE		14	/* Word-erase character [ICANON].  */
+#define VLNEXT		15	/* Literal-next character [IEXTEN].  */
+#define VEOF		16	/* End-of-file character [ICANON].  */
+#define VEOL		17	/* End-of-line character [ICANON].  */
+
+/* c_iflag bits */
+#define IGNBRK	0000001		/* Ignore break condition.  */
+#define BRKINT	0000002		/* Signal interrupt on break.  */
+#define IGNPAR	0000004		/* Ignore characters with parity errors.  */
+#define PARMRK	0000010		/* Mark parity and framing errors.  */
+#define INPCK	0000020		/* Enable input parity check.  */
+#define ISTRIP	0000040		/* Strip 8th bit off characters.  */
+#define INLCR	0000100		/* Map NL to CR on input.  */
+#define IGNCR	0000200		/* Ignore CR.  */
+#define ICRNL	0000400		/* Map CR to NL on input.  */
+#define IUCLC	0001000		/* Map upper case to lower case on input.  */
+#define IXON	0002000		/* Enable start/stop output control.  */
+#define IXANY	0004000		/* Any character will restart after stop.  */
+#define IXOFF	0010000		/* Enable start/stop input control.  */
+#define IMAXBEL 0020000		/* Ring bell when input queue is full.  */
+
+/* c_oflag bits */
+#define OPOST	0000001		/* Perform output processing.  */
+#define OLCUC	0000002		/* Map lower case to upper case on output.  */
+#define ONLCR	0000004		/* Map NL to CR-NL on output.  */
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#if defined __USE_MISC || defined __USE_XOPEN
+# define NLDLY	0000400
+# define   NL0	0000000
+# define   NL1	0000400
+# define CRDLY	0003000
+# define   CR0	0000000
+# define   CR1	0001000
+# define   CR2	0002000
+# define   CR3	0003000
+# define TABDLY	0014000
+# define   TAB0	0000000
+# define   TAB1	0004000
+# define   TAB2	0010000
+# define   TAB3	0014000
+# define BSDLY	0020000
+# define   BS0	0000000
+# define   BS1	0020000
+# define FFDLY	0100000
+# define   FF0	0000000
+# define   FF1	0100000
+#endif
+
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+
+#ifdef __USE_MISC
+# define XTABS  0014000
+#endif
+
+/* c_cflag bit meaning */
+#ifdef __USE_MISC
+# define CBAUD	0010017
+#endif
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#ifdef __USE_MISC
+# define EXTA B19200
+# define EXTB B38400
+#endif
+#define CSIZE	0000060		/* Number of bits per byte (mask).  */
+#define   CS5	0000000		/* 5 bits per byte.  */
+#define   CS6	0000020		/* 6 bits per byte.  */
+#define   CS7	0000040		/* 7 bits per byte.  */
+#define   CS8	0000060		/* 8 bits per byte.  */
+#define CSTOPB	0000100		/* Two stop bits instead of one.  */
+#define CREAD	0000200		/* Enable receiver.  */
+#define PARENB	0000400		/* Parity enable.  */
+#define PARODD	0001000		/* Odd parity instead of even.  */
+#define HUPCL	0002000		/* Hang up on last close.  */
+#define CLOCAL	0004000		/* Ignore modem status lines.  */
+#ifdef __USE_MISC
+# define CBAUDEX   0010000
+#endif
+#define  B57600   0010001
+#define  B115200  0010002
+#define  B230400  0010003
+#define  B460800  0010004
+#define  B500000  0010005
+#define  B576000  0010006
+#define  B921600  0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define __MAX_BAUD B4000000
+#ifdef __USE_MISC
+# define CIBAUD	  002003600000	/* input baud rate (not used) */
+# define CRTSCTS  020000000000		/* flow control */
+#endif
+
+/* c_lflag bits */
+#define ISIG	0000001		/* Enable signals.  */
+#define ICANON	0000002		/* Do erase and kill processing.  */
+#if defined __USE_MISC || defined __USE_XOPEN
+# define XCASE	0000004
+#endif
+#define ECHO	0000010		/* Enable echo.  */
+#define ECHOE	0000020		/* Visual erase for ERASE.  */
+#define ECHOK	0000040		/* Echo NL after KILL.  */
+#define ECHONL	0000100		/* Echo NL even if ECHO is off.  */
+#define NOFLSH	0000200		/* Disable flush after interrupt.  */
+#define IEXTEN	0000400		/* Enable DISCARD and LNEXT.  */
+#ifdef __USE_MISC
+# define ECHOCTL 0001000	/* Echo control characters as ^X.  */
+# define ECHOPRT 0002000	/* Hardcopy visual erase.  */
+# define ECHOKE	 0004000	/* Visual erase for KILL.  */
+# define FLUSHO	0020000
+# define PENDIN	0040000		/* Retype pending input (state).  */
+#endif
+#define TOSTOP	0100000		/* Send SIGTTOU for background output.  */
+#define ITOSTOP	TOSTOP
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+#define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0	/* Suspend output.  */
+#define	TCOON		1	/* Restart suspended output.  */
+#define	TCIOFF		2	/* Send a STOP character.  */
+#define	TCION		3	/* Send a START character.  */
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0	/* Discard data received but not yet read.  */
+#define	TCOFLUSH	1	/* Discard data written but not yet sent.  */
+#define	TCIOFLUSH	2	/* Discard all pending data.  */
+
+/* tcsetattr uses these */
+#define	TCSANOW		0x540e	/* Same as TCSETS; change immediately.  */
+#define	TCSADRAIN	0x540f	/* Same as TCSETSW; change when pending output is written.  */
+#define	TCSAFLUSH	0x5410	/* Same as TCSETSF; flush pending input before changing.  */
+
+#define _IOT_termios /* Hurd ioctl type field.  */ \
+  _IOT (_IOTS (cflag_t), 4, _IOTS (cc_t), NCCS, _IOTS (speed_t), 2)
diff -pruwN busybox-1.01/include2/bits/time.h busybox-1.01-livebox/include2/bits/time.h
--- busybox-1.01/include2/bits/time.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/time.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,79 @@
+/* System-dependent timing definitions.  Generic version.
+   Copyright (C) 1996,1997,1999-2002,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <time.h> instead.
+ */
+
+#ifndef __need_timeval
+# ifndef _BITS_TIME_H
+#  define _BITS_TIME_H	1
+
+/* ISO/IEC 9899:1990 7.12.1: <time.h>
+   The macro `CLOCKS_PER_SEC' is the number per second of the value
+   returned by the `clock' function. */
+/* CAE XSH, Issue 4, Version 2: <time.h>
+   The value of CLOCKS_PER_SEC is required to be 1 million on all
+   XSI-conformant systems. */
+#  define CLOCKS_PER_SEC  1000000l
+
+/* Get the arch-specific value of __UCLIBC_CLK_TCK_CONST used for CLK_TCK
+ * in sysconf() and clock(). */
+#include <bits/uClibc_clk_tck.h>
+
+#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
+/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
+   presents the real value for clock ticks per second for the system.  */
+#   include <bits/types.h>
+/* Note (uClibc): glibc #defines CLK_TCK as a sysconf() call. */
+#   define CLK_TCK ((__clock_t) __UCLIBC_CLK_TCK_CONST)
+#  endif
+
+#  ifdef __USE_POSIX199309
+/* Identifier for system-wide realtime clock.  */
+#   define CLOCK_REALTIME		0
+/* Monotonic system-wide clock.  */
+#   define CLOCK_MONOTONIC		1
+/* High-resolution timer from the CPU.  */
+#   define CLOCK_PROCESS_CPUTIME_ID	2
+/* Thread-specific CPU-time clock.  */
+#   define CLOCK_THREAD_CPUTIME_ID	3
+
+/* Flag to indicate time is absolute.  */
+#   define TIMER_ABSTIME		1
+#  endif
+
+# endif	/* bits/time.h */
+#endif
+
+#ifdef __need_timeval
+# undef __need_timeval
+# ifndef _STRUCT_TIMEVAL
+#  define _STRUCT_TIMEVAL	1
+#  include <bits/types.h>
+
+/* A time value that is accurate to the nearest
+   microsecond but also has a range of years.  */
+struct timeval
+  {
+    __time_t tv_sec;		/* Seconds.  */
+    __suseconds_t tv_usec;	/* Microseconds.  */
+  };
+# endif	/* struct timeval */
+#endif	/* need timeval */
diff -pruwN busybox-1.01/include2/bits/types.h busybox-1.01-livebox/include2/bits/types.h
--- busybox-1.01/include2/bits/types.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/types.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,146 @@
+/* Copyright (C) 1991,92,1994-1999,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <sys/types.h> instead.
+ */
+
+#ifndef	_BITS_TYPES_H
+#define	_BITS_TYPES_H	1
+
+#include <features.h>
+
+#define __need_size_t
+#include <stddef.h>
+#include <bits/kernel_types.h>
+
+/* Convenience types.  */
+typedef unsigned char __u_char;
+typedef unsigned short __u_short;
+typedef unsigned int __u_int;
+typedef unsigned long __u_long;
+#ifdef __GNUC__
+__extension__ typedef unsigned long long int __u_quad_t;
+__extension__ typedef long long int __quad_t;
+#else
+typedef struct
+  {
+    long int __val[2];
+  } __quad_t;
+typedef struct
+  {
+    __u_long __val[2];
+  } __u_quad_t;
+#endif
+typedef signed char __int8_t;
+typedef unsigned char __uint8_t;
+typedef signed short int __int16_t;
+typedef unsigned short int __uint16_t;
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+#ifdef __GNUC__
+__extension__ typedef signed long long int __int64_t;
+__extension__ typedef unsigned long long int __uint64_t;
+#endif
+typedef __quad_t *__qaddr_t;
+
+typedef __u_quad_t __dev_t;		/* Type of device numbers.  */
+typedef __u_int __uid_t;		/* Type of user identifications.  */
+typedef __u_int __gid_t;		/* Type of group identifications.  */
+typedef __u_long __ino_t;		/* Type of file serial numbers.  */
+typedef __u_int __mode_t;		/* Type of file attribute bitmasks.  */
+typedef __u_int __nlink_t; 		/* Type of file link counts.  */
+typedef long int __off_t;		/* Type of file sizes and offsets.  */
+typedef __quad_t __loff_t;		/* Type of file sizes and offsets.  */
+typedef int __pid_t;			/* Type of process identifications.  */
+typedef int __ssize_t;			/* Type of a byte count, or error.  */
+typedef __u_long __rlim_t;		/* Type of resource counts.  */
+typedef __u_quad_t __rlim64_t;		/* Type of resource counts (LFS).  */
+typedef __u_int __id_t;			/* General type for ID.  */
+
+typedef struct
+  {
+    int __val[2];
+  } __fsid_t;				/* Type of file system IDs.  */
+
+/* Everythin' else.  */
+typedef int __daddr_t;			/* The type of a disk address.  */
+typedef char *__caddr_t;
+typedef long int __time_t;
+typedef unsigned int __useconds_t;
+typedef long int __suseconds_t;
+typedef long int __swblk_t;		/* Type of a swap block maybe?  */
+
+typedef long int __clock_t;
+
+/* Clock ID used in clock and timer functions.  */
+typedef int __clockid_t;
+
+/* Timer ID returned by `timer_create'.  */
+typedef int __timer_t;
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define __FD_SETSIZE	1024
+
+
+typedef int __key_t;
+
+/* Used in `struct shmid_ds'.  */
+typedef long int __ipc_pid_t;
+
+
+/* Type to represent block size.  */
+typedef long int __blksize_t;
+
+/* Types from the Large File Support interface.  */
+
+/* Type to count number os disk blocks.  */
+typedef long int __blkcnt_t;
+typedef __quad_t __blkcnt64_t;
+
+/* Type to count file system blocks.  */
+typedef __u_long __fsblkcnt_t;
+typedef __u_quad_t __fsblkcnt64_t;
+
+/* Type to count file system inodes.  */
+typedef __u_long __fsfilcnt_t;
+typedef __u_quad_t __fsfilcnt64_t;
+
+/* Type of file serial numbers.  */
+typedef __u_quad_t __ino64_t;
+
+/* Type of file sizes and offsets.  */
+typedef __loff_t __off64_t;
+
+/* Used in XTI.  */
+typedef long int __t_scalar_t;
+typedef unsigned long int __t_uscalar_t;
+
+/* Duplicates info from stdint.h but this is used in unistd.h.  */
+typedef int __intptr_t;
+
+/* Duplicate info from sys/socket.h.  */
+typedef unsigned int __socklen_t;
+
+
+/* Now add the thread types.  */
+#if defined __UCLIBC_HAS_THREADS__ && (defined __USE_POSIX199506 || defined __USE_UNIX98)
+# include <bits/pthreadtypes.h>
+#endif
+
+#endif /* bits/types.h */
diff -pruwN busybox-1.01/include2/bits/uClibc_clk_tck.h busybox-1.01-livebox/include2/bits/uClibc_clk_tck.h
--- busybox-1.01/include2/bits/uClibc_clk_tck.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/uClibc_clk_tck.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,8 @@
+/* Use a default of 100 for CLK_TCK to implement sysconf() and clock().
+ * Override this by supplying an arch-specific version of this header file.
+ *
+ * WARNING: It is assumed that this is a constant integer value usable in
+ * preprocessor conditionals!!!
+ */
+
+#define __UCLIBC_CLK_TCK_CONST		100
diff -pruwN busybox-1.01/include2/bits/uClibc_config.h busybox-1.01-livebox/include2/bits/uClibc_config.h
--- busybox-1.01/include2/bits/uClibc_config.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/uClibc_config.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,174 @@
+/*
+ * Automatically generated C config: don't edit
+ */
+#if !defined __FEATURES_H && !defined __need_uClibc_config_h
+#error Never include <bits/uClibc_config.h> directly; use <features.h> instead
+#endif
+
+/*
+ * Version Number
+ */
+#define __UCLIBC_MAJOR__ 0
+#define __UCLIBC_MINOR__ 9
+#define __UCLIBC_SUBLEVEL__ 28
+#undef __TARGET_alpha__
+#undef __TARGET_arm__
+#undef __TARGET_bfin__
+#undef __TARGET_cris__
+#undef __TARGET_e1__
+#undef __TARGET_frv__
+#undef __TARGET_h8300__
+#undef __TARGET_i386__
+#undef __TARGET_i960__
+#undef __TARGET_m68k__
+#undef __TARGET_microblaze__
+#define __TARGET_mips__ 1
+#undef __TARGET_nios__
+#undef __TARGET_nios2__
+#undef __TARGET_powerpc__
+#undef __TARGET_sh__
+#undef __TARGET_sh64__
+#undef __TARGET_sparc__
+#undef __TARGET_v850__
+#undef __TARGET_x86_64__
+
+/*
+ * Target Architecture Features and Options
+ */
+#define __HAVE_ELF__ 1
+#define __ARCH_SUPPORTS_LITTLE_ENDIAN__ 1
+#define __TARGET_ARCH__ "mips"
+#define __ARCH_CFLAGS__ "-mno-split-addresses"
+#define __ARCH_SUPPORTS_BIG_ENDIAN__ 1
+#define __CONFIG_MIPS_ISA_1__ 1
+#undef __CONFIG_MIPS_ISA_2__
+#undef __CONFIG_MIPS_ISA_3__
+#undef __CONFIG_MIPS_ISA_4__
+#undef __CONFIG_MIPS_ISA_MIPS32__
+#undef __CONFIG_MIPS_ISA_MIPS64__
+#undef __ARCH_LITTLE_ENDIAN__
+#define __ARCH_BIG_ENDIAN__ 1
+#undef __ARCH_HAS_NO_MMU__
+#define __ARCH_HAS_MMU__ 1
+#define __UCLIBC_HAS_FLOATS__ 1
+#undef __HAS_FPU__
+#define __UCLIBC_HAS_SOFT_FLOAT__ 1
+#define __DO_C99_MATH__ 1
+#define __KERNEL_SOURCE__ "/filer1/dev_projets/rg_v2/dev/delizy/sdk/toolchain/relative/fusiv_linux-2.6_v1.0/buildroot/toolchain_build_mips_nofpu/linux"
+#define __C_SYMBOL_PREFIX__ ""
+#define __HAVE_DOT_CONFIG__ 1
+
+/*
+ * General Library Settings
+ */
+#undef __HAVE_NO_PIC__
+#define __DOPIC__ 1
+#undef __HAVE_NO_SHARED__
+#define __HAVE_SHARED__ 1
+#undef __ARCH_HAS_NO_LDSO__
+#define __BUILD_UCLIBC_LDSO__ 1
+#undef __FORCE_SHAREABLE_TEXT_SEGMENTS__
+#define __LDSO_LDD_SUPPORT__ 1
+#define __LDSO_CACHE_SUPPORT__ 1
+#undef __LDSO_PRELOAD_FILE_SUPPORT__
+#define __LDSO_BASE_FILENAME__ "ld.so"
+#define __LDSO_RUNPATH__ 1
+#undef __DL_FINI_CRT_COMPAT__
+#define __UCLIBC_CTOR_DTOR__ 1
+#undef __HAS_NO_THREADS__
+#define __UCLIBC_HAS_THREADS__ 1
+#define __PTHREADS_DEBUG_SUPPORT__ 1
+#define __UCLIBC_HAS_LFS__ 1
+#undef __UCLIBC_STATIC_LDCONFIG__
+#undef __MALLOC__
+#undef __MALLOC_SIMPLE__
+#define __MALLOC_STANDARD__ 1
+#define __MALLOC_GLIBC_COMPAT__ 1
+#define __UCLIBC_DYNAMIC_ATEXIT__ 1
+#define __HAS_SHADOW__ 1
+#undef __UNIX98PTY_ONLY__
+#define __ASSUME_DEVPTS__ 1
+#define __UCLIBC_HAS_TM_EXTENSIONS__ 1
+#define __UCLIBC_HAS_TZ_CACHING__ 1
+#define __UCLIBC_HAS_TZ_FILE__ 1
+#define __UCLIBC_HAS_TZ_FILE_READ_MANY__ 1
+#define __UCLIBC_TZ_FILE_PATH__ "/etc/TZ"
+
+/*
+ * Networking Support
+ */
+#define __UCLIBC_HAS_IPV6__ 1
+#define __UCLIBC_HAS_RPC__ 1
+#define __UCLIBC_HAS_FULL_RPC__ 1
+
+/*
+ * String and Stdio Support
+ */
+#define __UCLIBC_HAS_STRING_GENERIC_OPT__ 1
+#define __UCLIBC_HAS_STRING_ARCH_OPT__ 1
+#define __UCLIBC_HAS_CTYPE_TABLES__ 1
+#define __UCLIBC_HAS_CTYPE_SIGNED__ 1
+#undef __UCLIBC_HAS_CTYPE_UNSAFE__
+#define __UCLIBC_HAS_CTYPE_CHECKED__ 1
+#undef __UCLIBC_HAS_CTYPE_ENFORCED__
+#define __UCLIBC_HAS_WCHAR__ 1
+#undef __UCLIBC_HAS_LOCALE__
+#define __UCLIBC_HAS_HEXADECIMAL_FLOATS__ 1
+#define __UCLIBC_HAS_GLIBC_CUSTOM_PRINTF__ 1
+#define __UCLIBC_PRINTF_SCANF_POSITIONAL_ARGS__ 9
+#define __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__ 1
+#undef __UCLIBC_HAS_STDIO_BUFSIZ_NONE__
+#undef __UCLIBC_HAS_STDIO_BUFSIZ_256__
+#undef __UCLIBC_HAS_STDIO_BUFSIZ_512__
+#undef __UCLIBC_HAS_STDIO_BUFSIZ_1024__
+#undef __UCLIBC_HAS_STDIO_BUFSIZ_2048__
+#define __UCLIBC_HAS_STDIO_BUFSIZ_4096__ 1
+#undef __UCLIBC_HAS_STDIO_BUFSIZ_8192__
+#define __UCLIBC_HAS_STDIO_BUILTIN_BUFFER_NONE__ 1
+#undef __UCLIBC_HAS_STDIO_BUILTIN_BUFFER_4__
+#undef __UCLIBC_HAS_STDIO_BUILTIN_BUFFER_8__
+#undef __UCLIBC_HAS_STDIO_SHUTDOWN_ON_ABORT__
+#define __UCLIBC_HAS_STDIO_GETC_MACRO__ 1
+#define __UCLIBC_HAS_STDIO_PUTC_MACRO__ 1
+#define __UCLIBC_HAS_STDIO_AUTO_RW_TRANSITION__ 1
+#undef __UCLIBC_HAS_FOPEN_LARGEFILE_MODE__
+#define __UCLIBC_HAS_FOPEN_EXCLUSIVE_MODE__ 1
+#define __UCLIBC_HAS_GLIBC_CUSTOM_STREAMS__ 1
+#define __UCLIBC_HAS_PRINTF_M_SPEC__ 1
+#define __UCLIBC_HAS_ERRNO_MESSAGES__ 1
+#undef __UCLIBC_HAS_SYS_ERRLIST__
+#define __UCLIBC_HAS_SIGNUM_MESSAGES__ 1
+#undef __UCLIBC_HAS_SYS_SIGLIST__
+#define __UCLIBC_HAS_GNU_GETOPT__ 1
+
+/*
+ * Big and Tall
+ */
+#define __UCLIBC_HAS_REGEX__ 1
+#undef __UCLIBC_HAS_WORDEXP__
+#define __UCLIBC_HAS_FTW__ 1
+#define __UCLIBC_HAS_GLOB__ 1
+
+/*
+ * Library Installation Options
+ */
+#define __SHARED_LIB_LOADER_PREFIX__ "/lib"
+#define __RUNTIME_PREFIX__ "/"
+#define __DEVEL_PREFIX__ "/usr/"
+
+/*
+ * uClibc security related options
+ */
+#undef __UCLIBC_SECURITY__
+
+/*
+ * uClibc development/debugging options
+ */
+#define __CROSS_COMPILER_PREFIX__ "/filer1/dev_projets/rg_v2/dev/delizy/sdk/toolchain/relative/fusiv_linux-2.6_v1.0/buildroot/build_mips_nofpu/staging_dir/bin/mips-linux-uclibc-"
+#undef __DODEBUG__
+#undef __DODEBUG_PT__
+#undef __DOASSERTS__
+#undef __SUPPORT_LD_DEBUG__
+#undef __SUPPORT_LD_DEBUG_EARLY__
+#define __WARNINGS__ "-Wall"
+#undef __UCLIBC_MJN3_ONLY__
diff -pruwN busybox-1.01/include2/bits/uClibc_stdio.h busybox-1.01-livebox/include2/bits/uClibc_stdio.h
--- busybox-1.01/include2/bits/uClibc_stdio.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/uClibc_stdio.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,519 @@
+/* Copyright (C) 2002-2004   Manuel Novoa III    <mjn3@codepoet.org>
+ *
+ * GNU Library General Public License (LGPL) version 2 or later.
+ *
+ * Dedicated to Toni.  See uClibc/DEDICATION.mjn3 for details.
+ */
+
+#ifndef _STDIO_H
+#error Always include <stdio.h> rather than <bits/uClibc_stdio.h>
+#endif
+
+/**********************************************************************/
+
+#define __STDIO_BUFFERS
+/* ANSI/ISO mandate at least 256. */
+#if defined(__UCLIBC_HAS_STDIO_BUFSIZ_NONE__)
+/* Fake this because some apps use stdio.h BUFSIZ. */
+#define __STDIO_BUFSIZ			256
+#undef __STDIO_BUFFERS
+#elif defined(__UCLIBC_HAS_STDIO_BUFSIZ_256__)
+#define __STDIO_BUFSIZ			256
+#elif defined(__UCLIBC_HAS_STDIO_BUFSIZ_512__)
+#define __STDIO_BUFSIZ			512
+#elif defined(__UCLIBC_HAS_STDIO_BUFSIZ_1024__)
+#define __STDIO_BUFSIZ		   1024
+#elif defined(__UCLIBC_HAS_STDIO_BUFSIZ_2048__)
+#define __STDIO_BUFSIZ		   2048
+#elif defined(__UCLIBC_HAS_STDIO_BUFSIZ_4096__)
+#define __STDIO_BUFSIZ		   4096
+#elif defined(__UCLIBC_HAS_STDIO_BUFSIZ_8192__)
+#define __STDIO_BUFSIZ		   8192
+#else
+#error config seems to be out of sync regarding bufsiz options
+#endif
+
+#ifdef __UCLIBC_HAS_STDIO_BUFSIZ_NONE__
+#define __STDIO_BUILTIN_BUF_SIZE		0
+#else  /* __UCLIBC_HAS_STDIO_BUFSIZ_NONE__ */
+#if defined(__UCLIBC_HAS_STDIO_BUILTIN_BUFFER_NONE__)
+#define __STDIO_BUILTIN_BUF_SIZE		0
+#elif defined(__UCLIBC_HAS_STDIO_BUILTIN_BUFFER_4__)
+#define __STDIO_BUILTIN_BUF_SIZE		4
+#elif defined(__UCLIBC_HAS_STDIO_BUILTIN_BUFFER_8__)
+#define __STDIO_BUILTIN_BUF_SIZE		8
+#else
+#error config seems to be out of sync regarding builtin buffer size
+#endif
+#endif
+
+#if defined(__STDIO_BUFFERS) || defined(__UCLIBC_HAS_GLIBC_CUSTOM_STREAMS__) || defined(__UCLIBC_HAS_THREADS__)
+#define __STDIO_HAS_OPENLIST 1
+#else
+#undef __STDIO_HAS_OPENLIST
+#endif
+
+/**********************************************************************/
+/* Make sure defines related to large files are consistent. */
+#ifdef _LIBC
+
+#ifdef __UCLIBC_HAS_LFS__
+#undef __USE_LARGEFILE
+#undef __USE_LARGEFILE64
+#undef __USE_FILE_OFFSET64
+/* If we're actually building uClibc with large file support, only define... */
+#define __USE_LARGEFILE64	1
+#endif /* __UCLIBC_HAS_LFS__ */
+
+#else  /* not _LIBC */
+
+#ifndef __UCLIBC_HAS_LFS__
+#if defined(__LARGEFILE64_SOURCE) || defined(__USE_LARGEFILE64) || defined(__USE_FILE_OFFSET64)
+#error Sorry... uClibc was built without large file support!
+#endif
+#endif /* __UCLIBC_HAS_LFS__ */
+
+#endif /* _LIBC */
+/**********************************************************************/
+#ifdef __UCLIBC_HAS_WCHAR__
+
+#define __need_wchar_t
+#include <stddef.h>
+
+/* Note: we don't really need mbstate for 8-bit locales.  We do for UTF-8.
+ * For now, always use it. */
+#define __STDIO_MBSTATE
+#define __need_mbstate_t
+#include <wchar.h>
+
+#endif
+/**********************************************************************/
+/* Currently unimplemented/untested */
+/* #define __STDIO_FLEXIBLE_SETVBUF */
+
+#ifdef __UCLIBC_HAS_STDIO_GETC_MACRO__
+#define __STDIO_GETC_MACRO
+#endif
+
+#ifdef __UCLIBC_HAS_STDIO_PUTC_MACRO__
+#define __STDIO_PUTC_MACRO
+#endif
+
+
+/* These are consistency checks on the different options */
+
+#ifndef __STDIO_BUFFERS
+#undef __STDIO_GETC_MACRO
+#undef __STDIO_PUTC_MACRO
+#endif
+
+#ifdef __BCC__
+#undef __UCLIBC_HAS_LFS__
+#endif
+
+#ifndef __UCLIBC_HAS_LFS__
+#undef __UCLIBC_HAS_FOPEN_LARGEFILE_MODE__
+#endif
+
+/**********************************************************************/
+#ifdef __UCLIBC_HAS_THREADS__
+/* Need this for pthread_mutex_t. */
+#include <bits/pthreadtypes.h>
+
+/* user_locking
+ * 0 : do auto locking/unlocking
+ * 1 : user does locking/unlocking
+ * 2 : initial state prior to thread initialization
+ *     with no auto locking/unlocking
+ *
+ * When threading is initialized, walk the stdio open stream list
+ * and do  "if (user_locking == 2) user_locking = 0;".
+ *
+ * This way, we avoid calling the weak lock/unlock functions.
+ */
+
+#define __STDIO_AUTO_THREADLOCK_VAR			int __infunc_user_locking
+
+#define __STDIO_AUTO_THREADLOCK(__stream)								\
+	if ((__infunc_user_locking = (__stream)->__user_locking) == 0) {	\
+		__pthread_mutex_lock(&(__stream)->__lock);						\
+	}
+
+#define __STDIO_AUTO_THREADUNLOCK(__stream)				\
+	if (__infunc_user_locking == 0) {					\
+		__pthread_mutex_unlock(&(__stream)->__lock);		\
+	}
+
+#define __STDIO_SET_USER_LOCKING(__stream)	((__stream)->__user_locking = 1)
+
+#define __STDIO_ALWAYS_THREADLOCK(__stream)	\
+		__pthread_mutex_lock(&(__stream)->__lock)
+
+#define __STDIO_ALWAYS_THREADTRYLOCK(__stream)	\
+		__pthread_mutex_trylock(&(__stream)->__lock)
+
+#define __STDIO_ALWAYS_THREADUNLOCK(__stream) \
+		__pthread_mutex_unlock(&(__stream)->__lock)
+
+#else  /* __UCLIBC_HAS_THREADS__ */
+
+#define __STDIO_AUTO_THREADLOCK_VAR				((void)0)
+
+#define __STDIO_AUTO_THREADLOCK(__stream)		((void)0)
+#define __STDIO_AUTO_THREADUNLOCK(__stream)		((void)0)
+
+#define __STDIO_SET_USER_LOCKING(__stream)		((void)0)
+
+#define __STDIO_ALWAYS_THREADLOCK(__stream)		((void)0)
+#define __STDIO_ALWAYS_THREADTRYLOCK(__stream)	(0)	/* Always succeed. */
+#define __STDIO_ALWAYS_THREADUNLOCK(__stream)	((void)0)
+
+#endif /* __UCLIBC_HAS_THREADS__ */
+/**********************************************************************/
+
+#define __STDIO_IOFBF 0		/* Fully buffered.  */
+#define __STDIO_IOLBF 1		/* Line buffered.  */
+#define __STDIO_IONBF 2		/* No buffering.  */
+
+typedef struct {
+	__off_t __pos;
+#ifdef __STDIO_MBSTATE
+	__mbstate_t __mbstate;
+#endif
+#ifdef __UCLIBC_HAS_WCHAR__
+	int __mblen_pending;
+#endif
+} __STDIO_fpos_t;
+
+#ifdef __UCLIBC_HAS_LFS__
+typedef struct {
+	__off64_t __pos;
+#ifdef __STDIO_MBSTATE
+	__mbstate_t __mbstate;
+#endif
+#ifdef __UCLIBC_HAS_WCHAR__
+	int __mblen_pending;
+#endif
+} __STDIO_fpos64_t;
+#endif
+
+/**********************************************************************/
+#ifdef __UCLIBC_HAS_LFS__
+typedef __off64_t __offmax_t;	/* TODO -- rename this? */
+#else
+typedef __off_t __offmax_t;		/* TODO -- rename this? */
+#endif
+
+/**********************************************************************/
+#ifdef __UCLIBC_HAS_GLIBC_CUSTOM_STREAMS__
+
+typedef __ssize_t __io_read_fn(void *__cookie, char *__buf, size_t __bufsize);
+typedef __ssize_t __io_write_fn(void *__cookie,
+								__const char *__buf, size_t __bufsize);
+/* NOTE: GLIBC difference!!! -- fopencookie seek function
+ * For glibc, the type of pos is always (__off64_t *) but in our case
+ * it is type (__off_t *) when the lib is built without large file support.
+ */
+typedef int __io_seek_fn(void *__cookie, __offmax_t *__pos, int __whence);
+typedef int __io_close_fn(void *__cookie);
+
+typedef struct {
+	__io_read_fn  *read;
+	__io_write_fn *write;
+	__io_seek_fn  *seek;
+	__io_close_fn *close;
+} _IO_cookie_io_functions_t;
+
+#if defined(_LIBC) || defined(_GNU_SOURCE)
+
+typedef __io_read_fn cookie_read_function_t;
+typedef __io_write_fn cookie_write_function_t;
+typedef __io_seek_fn cookie_seek_function_t;
+typedef __io_close_fn cookie_close_function_t;
+
+typedef _IO_cookie_io_functions_t cookie_io_functions_t;
+
+#endif
+
+#endif
+/**********************************************************************/
+
+struct __STDIO_FILE_STRUCT {
+	unsigned short __modeflags;
+	/* There could be a hole here, but modeflags is used most.*/
+#ifdef __UCLIBC_HAS_WCHAR__
+	unsigned char __ungot_width[2]; /* 0: current (building) char; 1: scanf */
+	/* Move the following futher down to avoid problems with getc/putc
+	 * macros breaking shared apps when wchar config support is changed. */
+	/* wchar_t ungot[2]; */
+#else  /* __UCLIBC_HAS_WCHAR__ */
+	unsigned char __ungot[2];
+#endif /* __UCLIBC_HAS_WCHAR__ */
+	int __filedes;
+#ifdef __STDIO_BUFFERS
+	unsigned char *__bufstart;	/* pointer to buffer */
+	unsigned char *__bufend;	/* pointer to 1 past end of buffer */
+	unsigned char *__bufpos;
+	unsigned char *__bufread; /* pointer to 1 past last buffered read char */
+
+#ifdef __STDIO_GETC_MACRO
+	unsigned char *__bufgetc_u;	/* 1 past last readable by getc_unlocked */
+#endif /* __STDIO_GETC_MACRO */
+#ifdef __STDIO_PUTC_MACRO
+	unsigned char *__bufputc_u;	/* 1 past last writeable by putc_unlocked */
+#endif /* __STDIO_PUTC_MACRO */
+
+#endif /* __STDIO_BUFFERS */
+
+#ifdef __STDIO_HAS_OPENLIST
+	struct __STDIO_FILE_STRUCT *__nextopen;
+#endif
+#ifdef __UCLIBC_HAS_GLIBC_CUSTOM_STREAMS__
+	void *__cookie;
+	_IO_cookie_io_functions_t __gcs;
+#endif
+#ifdef __UCLIBC_HAS_WCHAR__
+	wchar_t __ungot[2];
+#endif
+#ifdef __STDIO_MBSTATE
+	__mbstate_t __state;
+#endif
+#ifdef __UCLIBC_HAS_XLOCALE__
+	void *__unused;				/* Placeholder for codeset binding. */
+#endif
+#ifdef __UCLIBC_HAS_THREADS__
+	int __user_locking;
+	pthread_mutex_t __lock;
+#endif
+/* Everything after this is unimplemented... and may be trashed. */
+#if __STDIO_BUILTIN_BUF_SIZE > 0
+	unsigned char __builtinbuf[__STDIO_BUILTIN_BUF_SIZE];
+#endif /* __STDIO_BUILTIN_BUF_SIZE > 0 */
+};
+
+
+/***********************************************************************/
+/* Having ungotten characters implies the stream is reading.
+ * The scheme used here treats the least significant 2 bits of
+ * the stream's modeflags member as follows:
+ *   0 0   Not currently reading.
+ *   0 1   Reading, but no ungetc() or scanf() push back chars.
+ *   1 0   Reading with one ungetc() char (ungot[1] is 1)
+ *         or one scanf() pushed back char (ungot[1] is 0).
+ *   1 1   Reading with both an ungetc() char and a scanf()
+ *         pushed back char.  Note that this must be the result
+ *         of a scanf() push back (in ungot[0]) _followed_ by
+ *         an ungetc() call (in ungot[1]).
+ *
+ * Notes:
+ *   scanf() can NOT use ungetc() to push back characters.
+ *     (See section 7.19.6.2 of the C9X rationale -- WG14/N897.)
+ */
+
+#define __MASK_READING		0x0003U /* (0x0001 | 0x0002) */
+#define __FLAG_READING		0x0001U
+#define __FLAG_UNGOT    	0x0002U
+#define __FLAG_EOF			0x0004U
+#define __FLAG_ERROR		0x0008U
+#define __FLAG_WRITEONLY  	0x0010U
+#define __FLAG_READONLY  	0x0020U /* (__FLAG_WRITEONLY << 1) */
+#define __FLAG_WRITING		0x0040U
+#define __FLAG_NARROW       0x0080U
+
+#define __FLAG_FBF          0x0000U /* must be 0 */
+#define __FLAG_LBF          0x0100U
+#define __FLAG_NBF          0x0200U /* (__FLAG_LBF << 1) */
+#define __MASK_BUFMODE      0x0300U /* (__FLAG_LBF|__FLAG_NBF) */
+#define __FLAG_APPEND       0x0400U /* fixed! == O_APPEND for linux */
+#define __FLAG_WIDE			0x0800U
+/* available slot           0x1000U */
+#define __FLAG_FREEFILE		0x2000U
+#define __FLAG_FREEBUF		0x4000U
+#define __FLAG_LARGEFILE    0x8000U /* fixed! == 0_LARGEFILE for linux */
+
+/* Note: In no-buffer mode, it would be possible to pack the necessary
+ * flags into one byte.  Since we wouldn't be buffering and there would
+ * be no support for wchar, the only flags we would need would be:
+ *   2 bits : ungot count
+ *   2 bits : eof + error
+ *   2 bits : readonly + writeonly
+ *   1 bit  : freefile
+ *   1 bit  : appending
+ * So, for a very small system (< 128 files) we might have a
+ * 4-byte FILE struct of:
+ *   unsigned char flags;
+ *   signed char filedes;
+ *   unsigned char ungot[2];
+ */
+/**********************************************************************
+ * PROTOTYPES OF INTERNAL FUNCTIONS
+ **********************************************************************/
+#ifdef _LIBC
+
+extern void _stdio_init(void);
+extern void _stdio_term(void);
+
+#ifdef __STDIO_HAS_OPENLIST
+
+extern struct __STDIO_FILE_STRUCT *_stdio_openlist;
+
+#ifdef __UCLIBC_HAS_THREADS__
+extern pthread_mutex_t _stdio_openlist_lock;
+extern int _stdio_openlist_delflag;
+extern int _stdio_user_locking;
+extern void __stdio_init_mutex(pthread_mutex_t *m);
+#endif
+
+#endif
+
+#endif
+/**********************************************************************/
+
+#define __CLEARERR_UNLOCKED(__stream) \
+	((void)((__stream)->__modeflags &= ~(__FLAG_EOF|__FLAG_ERROR)))
+#define __FEOF_UNLOCKED(__stream)	((__stream)->__modeflags & __FLAG_EOF)
+#define __FERROR_UNLOCKED(__stream)	((__stream)->__modeflags & __FLAG_ERROR)
+
+#ifdef __UCLIBC_HAS_THREADS__
+# define __CLEARERR(__stream)	(clearerr)(__stream)
+# define __FERROR(__stream)		(ferror)(__stream)
+# define __FEOF(__stream)		(feof)(__stream)
+#else
+# define __CLEARERR(__stream)	__CLEARERR_UNLOCKED(__stream)
+# define __FERROR(__stream)		__FERROR_UNLOCKED(__stream)
+# define __FEOF(__stream)		__FEOF_UNLOCKED(__stream)
+#endif
+
+extern int __fgetc_unlocked(FILE *__stream);
+extern int __fputc_unlocked(int __c, FILE *__stream);
+
+/* First define the default definitions.  They overriden below as necessary. */
+#define __FGETC_UNLOCKED(__stream)		(__fgetc_unlocked)((__stream))
+#define __FGETC(__stream)				(fgetc)((__stream))
+#define __GETC_UNLOCKED_MACRO(__stream)	(__fgetc_unlocked)((__stream))
+#define __GETC_UNLOCKED(__stream)		(__fgetc_unlocked)((__stream))
+#define __GETC(__stream)				(fgetc)((__stream))
+
+#define __FPUTC_UNLOCKED(__c, __stream)	(__fputc_unlocked)((__c),(__stream))
+#define __FPUTC(__c, __stream)			(fputc)((__c),(__stream))
+#define __PUTC_UNLOCKED_MACRO(__c, __stream) (__fputc_unlocked)((__c),(__stream))
+#define __PUTC_UNLOCKED(__c, __stream)	(__fputc_unlocked)((__c),(__stream))
+#define __PUTC(__c, __stream)			(fputc)((__c),(__stream))
+
+
+#ifdef __STDIO_GETC_MACRO
+
+extern FILE *__stdin;			/* For getchar() macro. */
+
+# undef  __GETC_UNLOCKED_MACRO
+# define __GETC_UNLOCKED_MACRO(__stream)					\
+		( ((__stream)->__bufpos < (__stream)->__bufgetc_u)	\
+		  ? (*(__stream)->__bufpos++)						\
+		  : __fgetc_unlocked(__stream) )
+
+# if 0
+	/* Classic macro approach.  getc{_unlocked} can have side effects. */
+#  undef  __GETC_UNLOCKED
+#  define __GETC_UNLOCKED(__stream)		__GETC_UNLOCKED_MACRO((__stream))
+#  ifndef __UCLIBC_HAS_THREADS__
+#   undef  __GETC
+#   define __GETC(__stream)				__GETC_UNLOCKED_MACRO((__stream))
+#  endif
+
+# else
+	/* Using gcc extension for safety and additional inlining. */
+#  undef  __FGETC_UNLOCKED
+#  define __FGETC_UNLOCKED(__stream)		\
+		(__extension__ ({					\
+			FILE *__S = (__stream);			\
+			__GETC_UNLOCKED_MACRO(__S);		\
+		}) )
+
+#  undef  __GETC_UNLOCKED
+#  define __GETC_UNLOCKED(__stream)		__FGETC_UNLOCKED((__stream))
+
+#  ifdef __UCLIBC_HAS_THREADS__
+#   undef  __FGETC
+#   define __FGETC(__stream)				\
+		(__extension__ ({					\
+			FILE *__S = (__stream);			\
+			((__S->__user_locking )			\
+			 ? __GETC_UNLOCKED_MACRO(__S)	\
+			 : (fgetc)(__S));				\
+		}) )
+
+#   undef  __GETC
+#   define __GETC(__stream)				__FGETC((__stream))
+
+#  else 
+
+#   undef  __FGETC
+#   define __FGETC(__stream)			__FGETC_UNLOCKED((__stream))
+#   undef  __GETC
+#   define __GETC(__stream)				__FGETC_UNLOCKED((__stream))
+
+#  endif
+# endif
+
+#else
+
+#endif /* __STDIO_GETC_MACRO */
+
+
+#ifdef __STDIO_PUTC_MACRO
+
+extern FILE *__stdout;			/* For putchar() macro. */
+
+# undef  __PUTC_UNLOCKED_MACRO
+# define __PUTC_UNLOCKED_MACRO(__c, __stream)						\
+		( ((__stream)->__bufpos < (__stream)->__bufputc_u)	\
+		  ? (*(__stream)->__bufpos++) = (__c)				\
+		  : __fputc_unlocked((__c),(__stream)) )
+
+# if 0
+	/* Classic macro approach.  putc{_unlocked} can have side effects.*/
+#  undef  __PUTC_UNLOCKED
+#  define __PUTC_UNLOCKED(__c, __stream) \
+									__PUTC_UNLOCKED_MACRO((__c), (__stream))
+#  ifndef __UCLIBC_HAS_THREADS__
+#   undef  __PUTC
+#   define __PUTC(__c, __stream)	__PUTC_UNLOCKED_MACRO((__c), (__stream))
+#  endif
+
+# else
+	/* Using gcc extension for safety and additional inlining. */
+
+#  undef  __FPUTC_UNLOCKED
+#  define __FPUTC_UNLOCKED(__c, __stream)		\
+		(__extension__ ({						\
+			FILE *__S = (__stream);				\
+			__PUTC_UNLOCKED_MACRO((__c),__S);	\
+		}) )
+
+#  undef  __PUTC_UNLOCKED
+#  define __PUTC_UNLOCKED(__c, __stream)	__FPUTC_UNLOCKED((__c), (__stream))
+
+#  ifdef __UCLIBC_HAS_THREADS__
+#   undef  __FPUTC
+#   define __FPUTC(__c, __stream)				\
+		(__extension__ ({						\
+			FILE *__S = (__stream);				\
+			((__S->__user_locking)				\
+			 ? __PUTC_UNLOCKED_MACRO((__c),__S)	\
+			 : (fputc)((__c),__S));				\
+		}) )
+
+#   undef  __PUTC
+#   define __PUTC(__c, __stream)		__FPUTC((__c), (__stream))
+
+#  else
+
+#   undef  __FPUTC
+#   define __FPUTC(__c, __stream) 		__FPUTC_UNLOCKED((__c),(__stream))
+#   undef  __PUTC
+#   define __PUTC(__c, __stream) 		__FPUTC_UNLOCKED((__c),(__stream))
+
+#  endif
+# endif
+
+#endif /* __STDIO_PUTC_MACRO */
diff -pruwN busybox-1.01/include2/bits/uClibc_touplow.h busybox-1.01-livebox/include2/bits/uClibc_touplow.h
--- busybox-1.01/include2/bits/uClibc_touplow.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/uClibc_touplow.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,54 @@
+/*  Copyright (C) 2003     Manuel Novoa III
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*  ATTENTION!   ATTENTION!   ATTENTION!   ATTENTION!   ATTENTION!
+ *
+ *  Besides uClibc, I'm using this code in my libc for elks, which is
+ *  a 16-bit environment with a fairly limited compiler.  It would make
+ *  things much easier for me if this file isn't modified unnecessarily.
+ *  In particular, please put any new or replacement functions somewhere
+ *  else, and modify the makefile to use your version instead.
+ *  Thanks.  Manuel
+ *
+ *  ATTENTION!   ATTENTION!   ATTENTION!   ATTENTION!   ATTENTION! */
+
+#ifndef _UCLIBC_TOUPLOW_H
+#define _UCLIBC_TOUPLOW_H
+
+#include <features.h>
+#include <bits/types.h>
+
+/* glibc uses the equivalent of - typedef __int32_t __ctype_touplow_t; */
+
+typedef __uint16_t __ctype_mask_t;
+
+#ifdef __UCLIBC_HAS_CTYPE_SIGNED__
+
+typedef __int16_t __ctype_touplow_t;
+#define __UCLIBC_CTYPE_B_TBL_OFFSET       128
+#define __UCLIBC_CTYPE_TO_TBL_OFFSET      128
+
+#else  /* __UCLIBC_HAS_CTYPE_SIGNED__ */
+
+typedef unsigned char __ctype_touplow_t;
+#define __UCLIBC_CTYPE_B_TBL_OFFSET       1
+#define __UCLIBC_CTYPE_TO_TBL_OFFSET      0
+
+#endif /* __UCLIBC_HAS_CTYPE_SIGNED__ */
+
+#endif /* _UCLIBC_TOUPLOW_H */
+
diff -pruwN busybox-1.01/include2/bits/uio.h busybox-1.01-livebox/include2/bits/uio.h
--- busybox-1.01/include2/bits/uio.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/uio.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,46 @@
+/* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UIO_H
+# error "Never include <bits/uio.h> directly; use <sys/uio.h> instead."
+#endif
+
+
+#include <sys/types.h>
+
+
+/* We should normally use the Linux kernel header file to define this
+   type and macros but this calls for trouble because of the header
+   includes other kernel headers.  */
+
+/* Size of object which can be written atomically.
+
+   This macro has different values in different kernel versions.  The
+   latest versions of ther kernel use 1024 and this is good choice.  Since
+   the C library implementation of readv/writev is able to emulate the
+   functionality even if the currently running kernel does not support
+   this large value the readv/writev call will not fail because of this.  */
+#define UIO_MAXIOV	1024
+
+
+/* Structure for scatter/gather I/O.  */
+struct iovec
+  {
+    void *iov_base;	/* Pointer to data.  */
+    size_t iov_len;	/* Length of data.  */
+  };
diff -pruwN busybox-1.01/include2/bits/utsname.h busybox-1.01-livebox/include2/bits/utsname.h
--- busybox-1.01/include2/bits/utsname.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/utsname.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,29 @@
+/* Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UTSNAME_H
+# error "Never include <bits/utsname.h> directly; use <sys/utsname.h> instead."
+#endif
+
+/* Length of the entries in `struct utsname' is 65.  */
+#define _UTSNAME_LENGTH 65
+
+/* Linux provides as additional information in the `struct utsname'
+   the name of the current domain.  Define _UTSNAME_DOMAIN_LENGTH
+   to a value != 0 to activate this entry.  */
+#define _UTSNAME_DOMAIN_LENGTH _UTSNAME_LENGTH
diff -pruwN busybox-1.01/include2/bits/waitflags.h busybox-1.01-livebox/include2/bits/waitflags.h
--- busybox-1.01/include2/bits/waitflags.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/waitflags.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,30 @@
+/* Definitions of flag bits for `waitpid' et al.
+   Copyright (C) 1992, 1996, 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_WAIT_H && !defined _STDLIB_H
+# error "Never include <bits/waitflags.h> directly; use <sys/wait.h> instead."
+#endif
+
+
+/* Bits in the third argument to `waitpid'.  */
+#define	WNOHANG		1	/* Don't block waiting.  */
+#define	WUNTRACED	2	/* Report status of stopped children.  */
+
+#define __WALL		0x40000000 /* Wait for any child.  */
+#define __WCLONE	0x80000000 /* Wait for cloned process.  */
diff -pruwN busybox-1.01/include2/bits/waitstatus.h busybox-1.01-livebox/include2/bits/waitstatus.h
--- busybox-1.01/include2/bits/waitstatus.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/waitstatus.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,104 @@
+/* Definitions of status bits for `wait' et al.
+   Copyright (C) 1992, 1994, 1996, 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_WAIT_H && !defined _STDLIB_H
+# error "Never include <bits/waitstatus.h> directly; use <sys/wait.h> instead."
+#endif
+
+
+/* Everything extant so far uses these same bits.  */
+
+
+/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
+#define	__WEXITSTATUS(status)	(((status) & 0xff00) >> 8)
+
+/* If WIFSIGNALED(STATUS), the terminating signal.  */
+#define	__WTERMSIG(status)	((status) & 0x7f)
+
+/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
+#define	__WSTOPSIG(status)	__WEXITSTATUS(status)
+
+/* Nonzero if STATUS indicates normal termination.  */
+#define	__WIFEXITED(status)	(__WTERMSIG(status) == 0)
+
+/* Nonzero if STATUS indicates termination by a signal.  */
+#ifdef	__GNUC__
+# define __WIFSIGNALED(status) \
+  (__extension__ ({ int __status = (status);				      \
+		    !__WIFSTOPPED(__status) && !__WIFEXITED(__status); }))
+#else	/* Not GCC.  */
+# define __WIFSIGNALED(status)	(!__WIFSTOPPED(status) && !__WIFEXITED(status))
+#endif	/* GCC.  */
+
+/* Nonzero if STATUS indicates the child is stopped.  */
+#define	__WIFSTOPPED(status)	(((status) & 0xff) == 0x7f)
+
+/* Nonzero if STATUS indicates the child dumped core.  */
+#define	__WCOREDUMP(status)	((status) & __WCOREFLAG)
+
+/* Macros for constructing status values.  */
+#define	__W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
+#define	__W_STOPCODE(sig)	((sig) << 8 | 0x7f)
+#define	__WCOREFLAG		0x80
+
+
+#ifdef	__USE_BSD
+
+# include <endian.h>
+
+union wait
+  {
+    int w_status;
+    struct
+      {
+# if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int __w_termsig:7; /* Terminating signal.  */
+	unsigned int __w_coredump:1; /* Set if dumped core.  */
+	unsigned int __w_retcode:8; /* Return code if exited normally.  */
+	unsigned int:16;
+# endif				/* Little endian.  */
+# if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int:16;
+	unsigned int __w_retcode:8;
+	unsigned int __w_coredump:1;
+	unsigned int __w_termsig:7;
+# endif				/* Big endian.  */
+      } __wait_terminated;
+    struct
+      {
+# if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
+	unsigned int __w_stopsig:8; /* Stopping signal.  */
+	unsigned int:16;
+# endif				/* Little endian.  */
+# if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int:16;
+	unsigned int __w_stopsig:8; /* Stopping signal.  */
+	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
+# endif				/* Big endian.  */
+      } __wait_stopped;
+  };
+
+# define w_termsig	__wait_terminated.__w_termsig
+# define w_coredump	__wait_terminated.__w_coredump
+# define w_retcode	__wait_terminated.__w_retcode
+# define w_stopsig	__wait_stopped.__w_stopsig
+# define w_stopval	__wait_stopped.__w_stopval
+
+#endif	/* Use BSD.  */
diff -pruwN busybox-1.01/include2/bits/wchar.h busybox-1.01-livebox/include2/bits/wchar.h
--- busybox-1.01/include2/bits/wchar.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/wchar.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,26 @@
+/* wchar_t type related definitions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_WCHAR_H
+#define _BITS_WCHAR_H	1
+
+#define __WCHAR_MIN	(-2147483647 - 1)
+#define __WCHAR_MAX	(2147483647)
+
+#endif	/* bits/wchar.h */
diff -pruwN busybox-1.01/include2/bits/wordsize.h busybox-1.01-livebox/include2/bits/wordsize.h
--- busybox-1.01/include2/bits/wordsize.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/wordsize.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,19 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __WORDSIZE	32
diff -pruwN busybox-1.01/include2/bits/xopen_lim.h busybox-1.01-livebox/include2/bits/xopen_lim.h
--- busybox-1.01/include2/bits/xopen_lim.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/bits/xopen_lim.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,150 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <limits.h> instead.
+ */
+
+/* Additional definitions from X/Open Portability Guide, Issue 4, Version 2
+   System Interfaces and Headers, 4.16 <limits.h>
+
+   Please note only the values which are not greater than the minimum
+   stated in the standard document are listed.  The `sysconf' functions
+   should be used to obtain the actual value.  */
+
+#ifndef _XOPEN_LIM_H
+#define _XOPEN_LIM_H	1
+
+#define __need_IOV_MAX
+#include <bits/stdio_lim.h>
+
+/* We do not provide fixed values for
+
+   ARG_MAX	Maximum length of argument to the `exec' function
+		including environment data.
+
+   ATEXIT_MAX	Maximum number of functions that may be registered
+		with `atexit'.
+
+   CHILD_MAX	Maximum number of simultaneous processes per real
+		user ID.
+
+   OPEN_MAX	Maximum number of files that one process can have open
+		at anyone time.
+
+   PAGESIZE
+   PAGE_SIZE	Size of bytes of a page.
+
+   PASS_MAX	Maximum number of significant bytes in a password.
+
+   We only provide a fixed limit for
+
+   IOV_MAX	Maximum number of `iovec' structures that one process has
+		available for use with `readv' or writev'.
+
+   if this is indeed fixed by the underlying system.
+*/
+
+
+/* Maximum number of `iovec' structures that one process has available
+   for use with `readv' or writev'.  */
+#define	_XOPEN_IOV_MAX	_POSIX_UIO_MAXIOV
+
+
+/* Maximum value of `digit' in calls to the `printf' and `scanf'
+   functions.  Posix dictates this should be a minimum of 9 */
+#if !defined(__UCLIBC_PRINTF_SCANF_POSITIONAL_ARGS__) || (__UCLIBC_PRINTF_SCANF_POSITIONAL_ARGS__ <= 1)
+#undef NL_ARGMAX
+#elif __UCLIBC_PRINTF_SCANF_POSITIONAL_ARGS__ < 9
+#define NL_ARGMAX	9
+#else
+#define NL_ARGMAX	__UCLIBC_PRINTF_SCANF_POSITIONAL_ARGS__
+#endif
+
+/* Maximum number of bytes in a `LANG' name.  We have no limit.  */
+#define NL_LANGMAX	_POSIX2_LINE_MAX
+
+/* Maximum message number.  We have no limit.  */
+#define NL_MSGMAX	INT_MAX
+
+/* Maximum number of bytes in N-to-1 collation mapping.  We have no
+   limit.  */
+#define NL_NMAX		INT_MAX
+
+/* Maximum set number.  We have no limit.  */
+#define NL_SETMAX	INT_MAX
+
+/* Maximum number of bytes in a message.  We have no limit.  */
+#define NL_TEXTMAX	INT_MAX
+
+/* Default process priority.  */
+#define NZERO		20
+
+
+/* Number of bits in a word of type `int'.  */
+#ifdef INT_MAX
+# if INT_MAX == 32767
+#  define WORD_BIT	16
+# else
+#  if INT_MAX == 2147483647
+#   define WORD_BIT	32
+#  else
+/* Safe assumption.  */
+#   define WORD_BIT	64
+#  endif
+# endif
+#elif defined __INT_MAX__
+# if __INT_MAX__ == 32767
+#  define WORD_BIT	16
+# else
+#  if __INT_MAX__ == 2147483647
+#   define WORD_BIT	32
+#  else
+/* Safe assumption.  */
+#   define WORD_BIT	64
+#  endif
+# endif
+#else
+# define WORD_BIT	32
+#endif
+
+/* Number of bits in a word of type `long int'.  */
+#ifdef LONG_MAX
+# if LONG_MAX == 2147483647
+#  define LONG_BIT	32
+# else
+/* Safe assumption.  */
+#  define LONG_BIT	64
+# endif
+#elif defined __LONG_MAX__
+# if __LONG_MAX__ == 2147483647
+#  define LONG_BIT	32
+# else
+/* Safe assumption.  */
+#  define LONG_BIT	64
+# endif
+#else
+# include <bits/wordsize.h>
+# if __WORDSIZE == 64
+#  define LONG_BIT	64
+# else
+#  define LONG_BIT	32
+# endif
+#endif
+
+#endif /* bits/xopen_lim.h */
diff -pruwN busybox-1.01/include2/byteswap.h busybox-1.01-livebox/include2/byteswap.h
--- busybox-1.01/include2/byteswap.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/byteswap.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,40 @@
+/* Copyright (C) 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BYTESWAP_H
+#define _BYTESWAP_H	1
+
+/* Get the machine specific, optimized definitions.  */
+#include <bits/byteswap.h>
+
+
+/* The following definitions must all be macros since otherwise some
+   of the possible optimizations are not possible.  */
+
+/* Return a value with all bytes in the 16 bit argument swapped.  */
+#define bswap_16(x) __bswap_16 (x)
+
+/* Return a value with all bytes in the 32 bit argument swapped.  */
+#define bswap_32(x) __bswap_32 (x)
+
+#if defined __GNUC__ && __GNUC__ >= 2
+/* Return a value with all bytes in the 64 bit argument swapped.  */
+# define bswap_64(x) __bswap_64 (x)
+#endif
+
+#endif /* byteswap.h */
diff -pruwN busybox-1.01/include2/crypt.h busybox-1.01-livebox/include2/crypt.h
--- busybox-1.01/include2/crypt.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/crypt.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+ * crypt(3) implementation for uClibc
+ *
+ * The uClibc Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * The GNU C Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the GNU C Library; if not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307 USA.
+ *
+ */
+
+#ifndef _CRYPT_H
+#define _CRYPT_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Encrypt characters from KEY using salt to perturb the encryption method.
+ * If salt begins with "$1$", MD5 hashing is used instead of DES. */
+extern char *crypt (const char *__key, const char *__salt);
+
+/* Setup DES tables according KEY.  */
+extern void setkey (const char *__key);
+
+/* Encrypt data in BLOCK in place if EDFLAG is zero; otherwise decrypt
+   block in place.  */
+extern void encrypt (char *__block, int __edflag);
+
+__END_DECLS
+
+#endif	/* crypt.h */
diff -pruwN busybox-1.01/include2/ctype.h busybox-1.01-livebox/include2/ctype.h
--- busybox-1.01/include2/ctype.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/ctype.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,390 @@
+/* Copyright (C) 1991,92,93,95,96,97,98,99,2001,02
+   	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99 Standard 7.4: Character handling	<ctype.h>
+ */
+
+#ifndef	_CTYPE_H
+#define	_CTYPE_H	1
+
+#include <features.h>
+#include <bits/types.h>
+
+#ifdef __UCLIBC_HAS_CTYPE_TABLES__
+
+__BEGIN_DECLS
+
+#ifndef _ISbit
+/* These are all the characteristics of characters.
+   If there get to be more than 16 distinct characteristics,
+   __ctype_mask_t will need to be adjusted. */
+
+# define _ISbit(bit)	(1 << (bit))
+
+enum
+{
+  _ISupper = _ISbit (0),	/* UPPERCASE.  */
+  _ISlower = _ISbit (1),	/* lowercase.  */
+  _ISalpha = _ISbit (2),	/* Alphabetic.  */
+  _ISdigit = _ISbit (3),	/* Numeric.  */
+  _ISxdigit = _ISbit (4),	/* Hexadecimal numeric.  */
+  _ISspace = _ISbit (5),	/* Whitespace.  */
+  _ISprint = _ISbit (6),	/* Printing.  */
+  _ISgraph = _ISbit (7),	/* Graphical.  */
+  _ISblank = _ISbit (8),	/* Blank (usually SPC and TAB).  */
+  _IScntrl = _ISbit (9),	/* Control character.  */
+  _ISpunct = _ISbit (10),	/* Punctuation.  */
+  _ISalnum = _ISbit (11)	/* Alphanumeric.  */
+};
+#else
+#error _ISbit already defined!
+#endif /* ! _ISbit  */
+
+#include <bits/uClibc_touplow.h>
+
+#ifdef __UCLIBC_HAS_CTYPE_SIGNED__
+# define __UCLIBC_CTYPE_IN_TO_DOMAIN(c) (((unsigned int)((c) + 128)) < 384)
+
+#else  /* __UCLIBC_HAS_CTYPE_SIGNED__ */
+# define __UCLIBC_CTYPE_IN_TO_DOMAIN(c) (((unsigned int)(c)) < 256)
+
+#endif /* __UCLIBC_HAS_CTYPE_SIGNED__ */
+
+/* In the thread-specific locale model (see `uselocale' in <locale.h>)
+   we cannot use global variables for these as was done in the past.
+   Instead, the following accessor functions return the address of
+   each variable, which is local to the current thread if multithreaded.
+
+   These point into arrays of 384, so they can be indexed by any `unsigned
+   char' value [0,255]; by EOF (-1); or by any `signed char' value
+   [-128,-1).  ISO C requires that the ctype functions work for `unsigned
+   char' values and for EOF; we also support negative `signed char' values
+   for broken old programs.  The case conversion arrays are of `int's
+   rather than `unsigned char's because tolower (EOF) must be EOF, which
+   doesn't fit into an `unsigned char'.  But today more important is that
+   the arrays are also used for multi-byte character sets.  */
+
+/* uClibc differences:
+ *
+ * When __UCLIBC_HAS_CTYPE_SIGNED is defined,
+ *
+ *    The upper and lower mapping arrays are type int16_t, so that
+ *    they may store all char values plus EOF.  The glibc reasoning
+ *    given above for these being type int is questionable, as the
+ *    ctype mapping functions map from the set of (unsigned) char
+ *    and EOF back into the set.  They have no awareness of multi-byte
+ *    or wide characters.
+ *
+ * Otherwise,
+ *
+ *    The ctype array is defined for -1..255.
+ *    The upper and lower mapping arrays are defined for 0..255.
+ *    The upper and lower mapping arrays are type unsigned char.
+ */
+
+/* Pointers to the default C-locale data. */
+extern const __ctype_mask_t *__C_ctype_b;
+extern const __ctype_touplow_t *__C_ctype_toupper;
+extern const __ctype_touplow_t *__C_ctype_tolower;
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+
+extern __const __ctype_mask_t **__ctype_b_loc (void)
+     __attribute__ ((__const));
+extern __const __ctype_touplow_t **__ctype_tolower_loc (void)
+     __attribute__ ((__const));
+extern __const __ctype_touplow_t **__ctype_toupper_loc (void)
+     __attribute__ ((__const));
+
+#define __UCLIBC_CTYPE_B	(*__ctype_b_loc())
+#define __UCLIBC_CTYPE_TOLOWER	(*__ctype_tolower_loc())
+#define __UCLIBC_CTYPE_TOUPPER	(*__ctype_toupper_loc())
+
+#else  /* __UCLIBC_HAS_XLOCALE__ */
+
+/* Pointers to the current global locale data in use. */
+extern const __ctype_mask_t *__ctype_b;
+extern const __ctype_touplow_t *__ctype_toupper;
+extern const __ctype_touplow_t *__ctype_tolower;
+
+#define __UCLIBC_CTYPE_B	(__ctype_b)
+#define __UCLIBC_CTYPE_TOLOWER	(__ctype_tolower)
+#define __UCLIBC_CTYPE_TOUPPER	(__ctype_toupper)
+
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+
+#define __isctype(c, type) \
+  ((__UCLIBC_CTYPE_B)[(int) (c)] & (__ctype_mask_t) type)
+
+#define	__isascii(c)	(((c) & ~0x7f) == 0)	/* If C is a 7 bit value.  */
+#define	__toascii(c)	((c) & 0x7f)		/* Mask off high bits.  */
+
+#ifdef __USE_MISC
+
+/* The following are included for compatibility with older versions of
+ * uClibc; but now they're only visible if MISC funcctionality is requested. */
+extern int isxlower(int c) __THROW;
+extern int isxupper(int c) __THROW;
+
+/* isdigit() is really locale-invariant, so provide some small fast macros.
+ * These are uClibc-specific. */
+#define __isdigit_char(C)    (((unsigned char)((C) - '0')) <= 9)
+#define __isdigit_int(C)     (((unsigned int)((C) - '0')) <= 9)
+
+#endif
+
+#define	__exctype(name)	extern int name (int) __THROW
+
+__BEGIN_NAMESPACE_STD
+
+/* The following names are all functions:
+     int isCHARACTERISTIC(int c);
+   which return nonzero iff C has CHARACTERISTIC.
+   For the meaning of the characteristic names, see the `enum' above.  */
+__exctype (isalnum);
+__exctype (isalpha);
+__exctype (iscntrl);
+__exctype (isdigit);
+__exctype (islower);
+__exctype (isgraph);
+__exctype (isprint);
+__exctype (ispunct);
+__exctype (isspace);
+__exctype (isupper);
+__exctype (isxdigit);
+
+
+/* Return the lowercase version of C.  */
+extern int tolower (int __c) __THROW;
+
+/* Return the uppercase version of C.  */
+extern int toupper (int __c) __THROW;
+
+__END_NAMESPACE_STD
+
+
+/* ISO C99 introduced one new function.  */
+#ifdef	__USE_ISOC99
+__BEGIN_NAMESPACE_C99
+
+__exctype (isblank);
+
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_GNU
+/* Test C for a set of character classes according to MASK.  */
+extern int isctype (int __c, int __mask) __THROW;
+#endif
+
+#if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN
+
+/* Return nonzero iff C is in the ASCII set
+   (i.e., is no more than 7 bits wide).  */
+extern int isascii (int __c) __THROW;
+
+/* Return the part of C that is in the ASCII set
+   (i.e., the low-order 7 bits of C).  */
+extern int toascii (int __c) __THROW;
+
+/* These are the same as `toupper' and `tolower' except that they do not
+   check the argument for being in the range of a `char'.  */
+__exctype (_toupper);
+__exctype (_tolower);
+#endif /* Use SVID or use misc.  */
+
+/* This code is needed for the optimized mapping functions.  */
+#define __tobody(c, f, a, args) \
+  (__extension__							      \
+   ({ int __res;							      \
+      if (sizeof (c) > 1)						      \
+	{								      \
+	  if (__builtin_constant_p (c))					      \
+	    {								      \
+	      int __c = (c);						      \
+	      __res = __UCLIBC_CTYPE_IN_TO_DOMAIN(__c) ? (a)[__c] : __c;      \
+	    }								      \
+	  else								      \
+	    __res = f args;						      \
+	}								      \
+      else								      \
+	__res = (a)[(int) (c)];						      \
+      __res; }))
+
+#if !defined __NO_CTYPE && !defined __cplusplus
+# define isalnum(c)	__isctype((c), _ISalnum)
+# define isalpha(c)	__isctype((c), _ISalpha)
+# define iscntrl(c)	__isctype((c), _IScntrl)
+# define isdigit(c)	__isctype((c), _ISdigit)
+# define islower(c)	__isctype((c), _ISlower)
+# define isgraph(c)	__isctype((c), _ISgraph)
+# define isprint(c)	__isctype((c), _ISprint)
+# define ispunct(c)	__isctype((c), _ISpunct)
+# define isspace(c)	__isctype((c), _ISspace)
+# define isupper(c)	__isctype((c), _ISupper)
+# define isxdigit(c)	__isctype((c), _ISxdigit)
+
+# ifdef __USE_ISOC99
+#  define isblank(c)	__isctype((c), _ISblank)
+# endif
+
+# ifdef __USE_EXTERN_INLINES
+extern __inline int
+tolower (int __c) __THROW
+{
+  return __UCLIBC_CTYPE_IN_TO_DOMAIN(__c) ? (__UCLIBC_CTYPE_TOLOWER)[__c] : __c;
+}
+
+extern __inline int
+toupper (int __c) __THROW
+{
+  return __UCLIBC_CTYPE_IN_TO_DOMAIN(__c) ? (__UCLIBC_CTYPE_TOUPPER)[__c] : __c;
+}
+# endif
+
+# if __GNUC__ >= 2 && defined __OPTIMIZE__ && !defined __cplusplus
+#  define tolower(c)	__tobody (c, tolower, __UCLIBC_CTYPE_TOLOWER, (c))
+#  define toupper(c)	__tobody (c, toupper, __UCLIBC_CTYPE_TOUPPER, (c))
+# endif /* Optimizing gcc */
+
+# if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN
+#  define isascii(c)	__isascii (c)
+#  define toascii(c)	__toascii (c)
+
+#  define _tolower(c)	((int) (__UCLIBC_CTYPE_TOLOWER)[(int) (c)])
+#  define _toupper(c)	((int) (__UCLIBC_CTYPE_TOUPPER)[(int) (c)])
+# endif
+
+#endif /* Not __NO_CTYPE.  */
+
+
+#if defined(__USE_GNU) && defined(__UCLIBC_HAS_XLOCALE__)
+/* The concept of one static locale per category is not very well
+   thought out.  Many applications will need to process its data using
+   information from several different locales.  Another application is
+   the implementation of the internationalization handling in the
+   upcoming ISO C++ standard library.  To support this another set of
+   the functions using locale data exist which have an additional
+   argument.
+
+   Attention: all these functions are *not* standardized in any form.
+   This is a proof-of-concept implementation.  */
+
+/* Structure for reentrant locale using functions.  This is an
+   (almost) opaque type for the user level programs.  */
+# include <xlocale.h>
+
+/* These definitions are similar to the ones above but all functions
+   take as an argument a handle for the locale which shall be used.  */
+#  define __isctype_l(c, type, locale) \
+  ((locale)->__ctype_b[(int) (c)] & (__ctype_mask_t) type)
+
+# define __exctype_l(name) 						      \
+  extern int name (int, __locale_t) __THROW
+
+/* The following names are all functions:
+     int isCHARACTERISTIC(int c, locale_t *locale);
+   which return nonzero iff C has CHARACTERISTIC.
+   For the meaning of the characteristic names, see the `enum' above.  */
+__exctype_l (isalnum_l);
+__exctype_l (isalpha_l);
+__exctype_l (iscntrl_l);
+__exctype_l (isdigit_l);
+__exctype_l (islower_l);
+__exctype_l (isgraph_l);
+__exctype_l (isprint_l);
+__exctype_l (ispunct_l);
+__exctype_l (isspace_l);
+__exctype_l (isupper_l);
+__exctype_l (isxdigit_l);
+
+__exctype_l (isblank_l);
+
+
+/* Return the lowercase version of C in locale L.  */
+extern int __tolower_l (int __c, __locale_t __l) __THROW;
+extern int tolower_l (int __c, __locale_t __l) __THROW;
+
+/* Return the uppercase version of C.  */
+extern int __toupper_l (int __c, __locale_t __l) __THROW;
+extern int toupper_l (int __c, __locale_t __l) __THROW;
+
+# if __GNUC__ >= 2 && defined __OPTIMIZE__ && !defined __cplusplus
+#  define __tolower_l(c, locale) \
+  __tobody (c, __tolower_l, (locale)->__ctype_tolower, (c, locale))
+#  define __toupper_l(c, locale) \
+  __tobody (c, __toupper_l, (locale)->__ctype_toupper, (c, locale))
+#  define tolower_l(c, locale)	__tolower_l ((c), (locale))
+#  define toupper_l(c, locale)	__toupper_l ((c), (locale))
+# endif	/* Optimizing gcc */
+
+
+# ifndef __NO_CTYPE
+#  define __isalnum_l(c,l)	__isctype_l((c), _ISalnum, (l))
+#  define __isalpha_l(c,l)	__isctype_l((c), _ISalpha, (l))
+#  define __iscntrl_l(c,l)	__isctype_l((c), _IScntrl, (l))
+#  define __isdigit_l(c,l)	__isctype_l((c), _ISdigit, (l))
+#  define __islower_l(c,l)	__isctype_l((c), _ISlower, (l))
+#  define __isgraph_l(c,l)	__isctype_l((c), _ISgraph, (l))
+#  define __isprint_l(c,l)	__isctype_l((c), _ISprint, (l))
+#  define __ispunct_l(c,l)	__isctype_l((c), _ISpunct, (l))
+#  define __isspace_l(c,l)	__isctype_l((c), _ISspace, (l))
+#  define __isupper_l(c,l)	__isctype_l((c), _ISupper, (l))
+#  define __isxdigit_l(c,l)	__isctype_l((c), _ISxdigit, (l))
+
+#  define __isblank_l(c,l)	__isctype_l((c), _ISblank, (l))
+
+#  if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN
+#   define __isascii_l(c,l)	((l), __isascii (c))
+#   define __toascii_l(c,l)	((l), __toascii (c))
+#  endif
+
+#  define isalnum_l(c,l)	__isalnum_l ((c), (l))
+#  define isalpha_l(c,l)	__isalpha_l ((c), (l))
+#  define iscntrl_l(c,l)	__iscntrl_l ((c), (l))
+#  define isdigit_l(c,l)	__isdigit_l ((c), (l))
+#  define islower_l(c,l)	__islower_l ((c), (l))
+#  define isgraph_l(c,l)	__isgraph_l ((c), (l))
+#  define isprint_l(c,l)	__isprint_l ((c), (l))
+#  define ispunct_l(c,l)	__ispunct_l ((c), (l))
+#  define isspace_l(c,l)	__isspace_l ((c), (l))
+#  define isupper_l(c,l)	__isupper_l ((c), (l))
+#  define isxdigit_l(c,l)	__isxdigit_l ((c), (l))
+
+#  define isblank_l(c,l)	__isblank_l ((c), (l))
+
+#  if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN
+#   define isascii_l(c,l)	__isascii_l ((c), (l))
+#   define toascii_l(c,l)	__toascii_l ((c), (l))
+#  endif
+
+# endif /* Not __NO_CTYPE.  */
+
+#endif /* Use GNU.  */
+
+__END_DECLS
+
+#else  /* __UCLIBC_HAS_CTYPE_TABLES__ */
+
+#include <bits/uClibc_ctype.h>
+
+#endif
+
+#endif /* ctype.h  */
diff -pruwN busybox-1.01/include2/dirent.h busybox-1.01-livebox/include2/dirent.h
--- busybox-1.01/include2/dirent.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/dirent.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,274 @@
+/* Copyright (C) 1991-1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 5.1.2 Directory Operations	<dirent.h>
+ */
+
+#ifndef	_DIRENT_H
+#define	_DIRENT_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/types.h>
+
+#ifdef __USE_XOPEN
+# ifndef __ino_t_defined
+#  ifndef __USE_FILE_OFFSET64
+typedef __ino_t ino_t;
+#  else
+typedef __ino64_t ino_t;
+#  endif
+#  define __ino_t_defined
+# endif
+# if defined __USE_LARGEFILE64 && !defined __ino64_t_defined
+typedef __ino64_t ino64_t;
+#  define __ino64_t_defined
+# endif
+#endif
+
+/* This file defines `struct dirent'.
+
+   It defines the macro `_DIRENT_HAVE_D_NAMLEN' iff there is a `d_namlen'
+   member that gives the length of `d_name'.
+
+   It defines the macro `_DIRENT_HAVE_D_RECLEN' iff there is a `d_reclen'
+   member that gives the size of the entire directory entry.
+
+   It defines the macro `_DIRENT_HAVE_D_OFF' iff there is a `d_off'
+   member that gives the file offset of the next directory entry.
+
+   It defines the macro `_DIRENT_HAVE_D_TYPE' iff there is a `d_type'
+   member that gives the type of the file.
+ */
+
+#include <bits/dirent.h>
+
+#if (defined __USE_BSD || defined __USE_MISC) && !defined d_fileno
+# define d_ino	d_fileno		 /* Backward compatibility.  */
+#endif
+
+/* These macros extract size information from a `struct dirent *'.
+   They may evaluate their argument multiple times, so it must not
+   have side effects.  Each of these may involve a relatively costly
+   call to `strlen' on some systems, so these values should be cached.
+
+   _D_EXACT_NAMLEN (DP)	returns the length of DP->d_name, not including
+   its terminating null character.
+
+   _D_ALLOC_NAMLEN (DP)	returns a size at least (_D_EXACT_NAMLEN (DP) + 1);
+   that is, the allocation size needed to hold the DP->d_name string.
+   Use this macro when you don't need the exact length, just an upper bound.
+   This macro is less likely to require calling `strlen' than _D_EXACT_NAMLEN.
+   */
+
+#ifdef _DIRENT_HAVE_D_NAMLEN
+# define _D_EXACT_NAMLEN(d) ((d)->d_namlen)
+# define _D_ALLOC_NAMLEN(d) (_D_EXACT_NAMLEN (d) + 1)
+#else
+# define _D_EXACT_NAMLEN(d) (strlen ((d)->d_name))
+# ifdef _DIRENT_HAVE_D_RECLEN
+#  define _D_ALLOC_NAMLEN(d) (((char *) (d) + (d)->d_reclen) - &(d)->d_name[0])
+# else
+#  define _D_ALLOC_NAMLEN(d) (sizeof (d)->d_name > 1 ? sizeof (d)->d_name : \
+			      _D_EXACT_NAMLEN (d) + 1)
+# endif
+#endif
+
+
+#ifdef __USE_BSD
+/* File types for `d_type'.  */
+enum
+  {
+    DT_UNKNOWN = 0,
+# define DT_UNKNOWN	DT_UNKNOWN
+    DT_FIFO = 1,
+# define DT_FIFO	DT_FIFO
+    DT_CHR = 2,
+# define DT_CHR		DT_CHR
+    DT_DIR = 4,
+# define DT_DIR		DT_DIR
+    DT_BLK = 6,
+# define DT_BLK		DT_BLK
+    DT_REG = 8,
+# define DT_REG		DT_REG
+    DT_LNK = 10,
+# define DT_LNK		DT_LNK
+    DT_SOCK = 12,
+# define DT_SOCK	DT_SOCK
+    DT_WHT = 14
+# define DT_WHT		DT_WHT
+  };
+
+/* Convert between stat structure types and directory types.  */
+# define IFTODT(mode)	(((mode) & 0170000) >> 12)
+# define DTTOIF(dirtype)	((dirtype) << 12)
+#endif
+
+
+/* This is the data type of directory stream objects.
+   The actual structure is opaque to users.  */
+typedef struct __dirstream DIR;
+
+/* Open a directory stream on NAME.
+   Return a DIR stream on the directory, or NULL if it could not be opened.  */
+extern DIR *opendir (__const char *__name) __THROW;
+
+/* Close the directory stream DIRP.
+   Return 0 if successful, -1 if not.  */
+extern int closedir (DIR *__dirp) __THROW;
+
+/* Read a directory entry from DIRP.  Return a pointer to a `struct
+   dirent' describing the entry, or NULL for EOF or error.  The
+   storage returned may be overwritten by a later readdir call on the
+   same DIR stream.
+
+   If the Large File Support API is selected we have to use the
+   appropriate interface.  */
+#ifndef __USE_FILE_OFFSET64
+extern struct dirent *readdir (DIR *__dirp) __THROW;
+#else
+# ifdef __REDIRECT
+extern struct dirent *__REDIRECT (readdir, (DIR *__dirp) __THROW, readdir64);
+# else
+#  define readdir readdir64
+# endif
+#endif
+
+#ifdef __USE_LARGEFILE64
+extern struct dirent64 *readdir64 (DIR *__dirp) __THROW;
+#endif
+
+#if defined __USE_POSIX || defined __USE_MISC
+/* Reentrant version of `readdir'.  Return in RESULT a pointer to the
+   next entry.  */
+# ifndef __USE_FILE_OFFSET64
+extern int readdir_r (DIR *__restrict __dirp,
+		      struct dirent *__restrict __entry,
+		      struct dirent **__restrict __result) __THROW;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (readdir_r,
+		       (DIR *__restrict __dirp,
+			struct dirent *__restrict __entry,
+			struct dirent **__restrict __result) __THROW,
+		       readdir64_r);
+#  else
+#   define readdir_r readdir64_r
+#  endif
+# endif
+
+# ifdef __USE_LARGEFILE64
+extern int readdir64_r (DIR *__restrict __dirp,
+			struct dirent64 *__restrict __entry,
+			struct dirent64 **__restrict __result) __THROW;
+# endif
+#endif	/* POSIX or misc */
+
+/* Rewind DIRP to the beginning of the directory.  */
+extern void rewinddir (DIR *__dirp) __THROW;
+
+#if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN
+# include <bits/types.h>
+
+/* Seek to position POS on DIRP.  */
+extern void seekdir (DIR *__dirp, long int __pos) __THROW;
+
+/* Return the current position of DIRP.  */
+extern long int telldir (DIR *__dirp) __THROW;
+#endif
+
+#if defined __USE_BSD || defined __USE_MISC
+
+/* Return the file descriptor used by DIRP.  */
+extern int dirfd (DIR *__dirp) __THROW;
+
+# ifndef MAXNAMLEN
+/* Get the definitions of the POSIX.1 limits.  */
+#  include <bits/posix1_lim.h>
+
+/* `MAXNAMLEN' is the BSD name for what POSIX calls `NAME_MAX'.  */
+#  ifdef NAME_MAX
+#   define MAXNAMLEN	NAME_MAX
+#  else
+#   define MAXNAMLEN	255
+#  endif
+# endif
+
+# define __need_size_t
+# include <stddef.h>
+
+/* Scan the directory DIR, calling SELECTOR on each directory entry.
+   Entries for which SELECT returns nonzero are individually malloc'd,
+   sorted using qsort with CMP, and collected in a malloc'd array in
+   *NAMELIST.  Returns the number of entries selected, or -1 on error.  */
+# ifndef __USE_FILE_OFFSET64
+extern int scandir (__const char *__restrict __dir,
+		    struct dirent ***__restrict __namelist,
+		    int (*__selector) (__const struct dirent *),
+		    int (*__cmp) (__const void *, __const void *)) __THROW;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (scandir,
+		       (__const char *__restrict __dir,
+			struct dirent ***__restrict __namelist,
+			int (*__selector) (__const struct dirent *),
+			int (*__cmp) (__const void *, __const void *)) __THROW,
+		       scandir64);
+#  else
+#   define scandir scandir64
+#  endif
+# endif
+
+# if defined __USE_GNU && defined __USE_LARGEFILE64
+/* This function is like `scandir' but it uses the 64bit dirent structure.
+   Please note that the CMP function must now work with struct dirent64 **.  */
+extern int scandir64 (__const char *__restrict __dir,
+		      struct dirent64 ***__restrict __namelist,
+		      int (*__selector) (__const struct dirent64 *),
+		      int (*__cmp) (__const void *, __const void *)) __THROW;
+# endif
+
+/* Function to compare two `struct dirent's alphabetically.  */
+# ifndef __USE_FILE_OFFSET64
+extern int alphasort (__const void *__e1, __const void *__e2)
+     __THROW __attribute_pure__;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (alphasort,
+		       (__const void *__e1, __const void *__e2)
+		       __THROW,
+		       alphasort64) __attribute_pure__;
+#  else
+#   define alphasort alphasort64
+#  endif
+# endif
+
+# if defined __USE_GNU && defined __USE_LARGEFILE64
+extern int alphasort64 (__const void *__e1, __const void *__e2)
+     __THROW __attribute_pure__;
+# endif
+
+
+#endif /* Use BSD or misc.  */
+
+__END_DECLS
+
+#endif /* dirent.h  */
diff -pruwN busybox-1.01/include2/endian.h busybox-1.01-livebox/include2/endian.h
--- busybox-1.01/include2/endian.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/endian.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,58 @@
+/* Copyright (C) 1992, 1996, 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_ENDIAN_H
+#define	_ENDIAN_H	1
+
+#include <features.h>
+
+/* Definitions for byte order, according to significance of bytes,
+   from low addresses to high addresses.  The value is what you get by
+   putting '4' in the most significant byte, '3' in the second most
+   significant byte, '2' in the second least significant byte, and '1'
+   in the least significant byte, and then writing down one digit for
+   each byte, starting with the byte at the lowest address at the left,
+   and proceeding to the byte with the highest address at the right.  */
+
+#define	__LITTLE_ENDIAN	1234
+#define	__BIG_ENDIAN	4321
+#define	__PDP_ENDIAN	3412
+
+/* This file defines `__BYTE_ORDER' for the particular machine.  */
+#include <bits/endian.h>
+
+/* Some machines may need to use a different endianness for floating point
+   values.  */
+#ifndef __FLOAT_WORD_ORDER
+# define __FLOAT_WORD_ORDER __BYTE_ORDER
+#endif
+
+#ifdef	__USE_BSD
+# define LITTLE_ENDIAN	__LITTLE_ENDIAN
+# define BIG_ENDIAN	__BIG_ENDIAN
+# define PDP_ENDIAN	__PDP_ENDIAN
+# define BYTE_ORDER	__BYTE_ORDER
+#endif
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+# define __LONG_LONG_PAIR(HI, LO) LO, HI
+#elif __BYTE_ORDER == __BIG_ENDIAN
+# define __LONG_LONG_PAIR(HI, LO) HI, LO
+#endif
+
+#endif	/* endian.h */
diff -pruwN busybox-1.01/include2/errno.h busybox-1.01-livebox/include2/errno.h
--- busybox-1.01/include2/errno.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/errno.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,73 @@
+/* Copyright (C) 1991,92,93,94,95,96,97,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99 Standard: 7.5 Errors	<errno.h>
+ */
+
+#ifndef	_ERRNO_H
+
+/* The includer defined __need_Emath if he wants only the definitions
+   of EDOM and ERANGE, and not everything else.  */
+#ifndef	__need_Emath
+# define _ERRNO_H	1
+# include <features.h>
+#endif
+
+__BEGIN_DECLS
+
+/* Get the error number constants from the system-specific file.
+   This file will test __need_Emath and _ERRNO_H.  */
+#include <bits/errno.h>
+#undef	__need_Emath
+
+#ifdef	_ERRNO_H
+
+/* Declare the `errno' variable, unless it's defined as a macro by
+   bits/errno.h.  This is the case in GNU, where it is a per-thread
+   variable.  This redeclaration using the macro still works, but it
+   will be a function declaration without a prototype and may trigger
+   a -Wstrict-prototypes warning.  */
+#ifndef	errno
+extern int errno;
+#endif
+
+#if 0 /*def __USE_GNU      uClibc note: not supported */
+
+/* The full and simple forms of the name with which the program was
+   invoked.  These variables are set up automatically at startup based on
+   the value of ARGV[0] (this works only if you use GNU ld).  */
+extern char *program_invocation_name, *program_invocation_short_name;
+#endif /* __USE_GNU */
+#endif /* _ERRNO_H */
+
+__END_DECLS
+
+#endif /* _ERRNO_H */
+
+/* The Hurd <bits/errno.h> defines `error_t' as an enumerated type so
+   that printing `error_t' values in the debugger shows the names.  We
+   might need this definition sometimes even if this file was included
+   before.  */
+#if defined __USE_GNU || defined __need_error_t
+# ifndef __error_t_defined
+typedef int error_t;
+#  define __error_t_defined	1
+# endif
+# undef __need_error_t
+#endif
diff -pruwN busybox-1.01/include2/fcntl.h busybox-1.01-livebox/include2/fcntl.h
--- busybox-1.01/include2/fcntl.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/fcntl.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,182 @@
+/* Copyright (C) 1991,92,94,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 6.5 File Control Operations	<fcntl.h>
+ */
+
+#ifndef	_FCNTL_H
+#define	_FCNTL_H	1
+
+#include <features.h>
+
+/* This must be early so <bits/fcntl.h> can define types winningly.  */
+__BEGIN_DECLS
+
+/* Get the definitions of O_*, F_*, FD_*: all the
+   numbers and flag bits for `open', `fcntl', et al.  */
+#include <bits/fcntl.h>
+
+/* For XPG all symbols from <sys/stat.h> should also be available.  */
+#ifdef __USE_XOPEN
+# include <sys/stat.h>
+#endif
+
+#ifdef	__USE_MISC
+# ifndef R_OK			/* Verbatim from <unistd.h>.  Ugh.  */
+/* Values for the second argument to access.
+   These may be OR'd together.  */
+#  define R_OK	4		/* Test for read permission.  */
+#  define W_OK	2		/* Test for write permission.  */
+#  define X_OK	1		/* Test for execute permission.  */
+#  define F_OK	0		/* Test for existence.  */
+# endif
+#endif /* Use misc.  */
+
+/* XPG wants the following symbols.  */
+#ifdef __USE_XOPEN		/* <stdio.h> has the same definitions.  */
+# define SEEK_SET	0	/* Seek from beginning of file.  */
+# define SEEK_CUR	1	/* Seek from current position.  */
+# define SEEK_END	2	/* Seek from end of file.  */
+#endif	/* XPG */
+
+/* Do the file control operation described by CMD on FD.
+   The remaining arguments are interpreted depending on CMD.  */
+#ifndef __USE_FILE_OFFSET64
+extern int fcntl (int __fd, int __cmd, ...) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (fcntl, (int __fd, int __cmd, ...) __THROW,
+		       fcntl64);
+# else
+#  define fcntl fcntl64
+# endif
+#endif
+
+/* Open FILE and return a new file descriptor for it, or -1 on error.
+   OFLAG determines the type of access used.  If O_CREAT is on OFLAG,
+   the third argument is taken as a `mode_t', the mode of the created file.  */
+#ifndef __USE_FILE_OFFSET64
+extern int open (__const char *__file, int __oflag, ...) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (open, (__const char *__file, int __oflag, ...) __THROW,
+		       open64);
+# else
+#  define open open64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int open64 (__const char *__file, int __oflag, ...) __THROW;
+#endif
+
+/* Create and open FILE, with mode MODE.
+   This takes an `int' MODE argument because that is
+   what `mode_t' will be widened to.  */
+#ifndef __USE_FILE_OFFSET64
+extern int creat (__const char *__file, __mode_t __mode) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (creat, (__const char *__file, __mode_t __mode) __THROW,
+		       creat64);
+# else
+#  define creat creat64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int creat64 (__const char *__file, __mode_t __mode) __THROW;
+#endif
+
+#if !defined F_LOCK && (defined __USE_MISC || (defined __USE_XOPEN_EXTENDED \
+					       && !defined __USE_POSIX))
+/* NOTE: These declarations also appear in <unistd.h>; be sure to keep both
+   files consistent.  Some systems have them there and some here, and some
+   software depends on the macros being defined without including both.  */
+
+/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
+   LEN is always relative to the current file position.
+   The CMD argument is one of the following.  */
+
+# define F_ULOCK 0	/* Unlock a previously locked region.  */
+# define F_LOCK  1	/* Lock a region for exclusive use.  */
+# define F_TLOCK 2	/* Test and lock a region for exclusive use.  */
+# define F_TEST  3	/* Test a region for other processes locks.  */
+
+# ifndef __USE_FILE_OFFSET64
+extern int lockf (int __fd, int __cmd, __off_t __len) __THROW;
+# else
+# ifdef __REDIRECT
+extern int __REDIRECT (lockf, (int __fd, int __cmd, __off64_t __len) __THROW,
+		       lockf64);
+# else
+#  define lockf lockf64
+# endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int lockf64 (int __fd, int __cmd, __off64_t __len) __THROW;
+# endif
+#endif
+
+
+#if 0
+
+/* FIXME -- uClibc should probably implement these... */
+
+#ifdef __USE_XOPEN2K
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+# ifndef __USE_FILE_OFFSET64
+extern int posix_fadvise (int __fd, __off_t __offset, size_t __len,
+			  int __advise) __THROW;
+# else
+# ifdef __REDIRECT
+extern int __REDIRECT (posix_fadvise, (int __fd, __off64_t __offset,
+				       size_t __len, int __advise) __THROW,
+		       posix_fadvise64);
+# else
+#  define posix_fadvise posix_fadvise64
+# endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int posix_fadvise64 (int __fd, __off64_t __offset, size_t __len,
+			    int __advise) __THROW;
+# endif
+
+
+/* Reserve storage for the data of the file associated with FD.  */
+# ifndef __USE_FILE_OFFSET64
+extern int posix_fallocate (int __fd, __off_t __offset, size_t __len) __THROW;
+# else
+# ifdef __REDIRECT
+extern int __REDIRECT (posix_fallocate, (int __fd, __off64_t __offset,
+					 size_t __len) __THROW,
+		       posix_fallocate64);
+# else
+#  define posix_fallocate posix_fallocate64
+# endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int posix_fallocate64 (int __fd, __off64_t __offset, size_t __len)
+     __THROW;
+# endif
+#endif
+#endif
+
+__END_DECLS
+
+#endif /* fcntl.h  */
diff -pruwN busybox-1.01/include2/features.h busybox-1.01-livebox/include2/features.h
--- busybox-1.01/include2/features.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/features.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,447 @@
+/* Copyright (C) 1991,92,93,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FEATURES_H
+#define	_FEATURES_H	1
+
+/* For uClibc, always optimize for size -- this should disable
+ * a lot of expensive inlining... */
+#define __OPTIMIZE_SIZE__   1
+
+/* These are defined by the user (or the compiler)
+   to specify the desired environment:
+
+   __STRICT_ANSI__	ISO Standard C.
+   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
+   _POSIX_SOURCE	IEEE Std 1003.1.
+   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
+			if >=199309L, add IEEE Std 1003.1b-1993;
+			if >=199506L, add IEEE Std 1003.1c-1995
+   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
+			Single Unix conformance is wanted, to 600 for the
+			upcoming sixth revision.
+   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
+   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
+   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
+   _FILE_OFFSET_BITS=N	Select default filesystem interface.
+   _BSD_SOURCE		ISO C, POSIX, and 4.3BSD things.
+   _SVID_SOURCE		ISO C, POSIX, and SVID things.
+   _GNU_SOURCE		All of the above, plus GNU extensions.
+   _REENTRANT		Select additionally reentrant object.
+   _THREAD_SAFE		Same as _REENTRANT, often used by other systems.
+
+   The `-ansi' switch to the GNU C compiler defines __STRICT_ANSI__.
+   If none of these are defined, the default is to have _SVID_SOURCE,
+   _BSD_SOURCE, and _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
+   199506L.  If more than one of these are defined, they accumulate.
+   For example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE
+   together give you ISO C, 1003.1, and 1003.2, but nothing else.
+
+   These are defined by this file and are used by the
+   header files to decide what to declare or define:
+
+   __USE_ISOC99		Define ISO C99 things.
+   __USE_POSIX		Define IEEE Std 1003.1 things.
+   __USE_POSIX2		Define IEEE Std 1003.2 things.
+   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
+   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
+   __USE_XOPEN		Define XPG things.
+   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
+   __USE_UNIX98		Define Single Unix V2 things.
+   __USE_XOPEN2K        Define XPG6 things.
+   __USE_LARGEFILE	Define correct standard I/O things.
+   __USE_LARGEFILE64	Define LFS things with separate names.
+   __USE_FILE_OFFSET64	Define 64bit interface as default.
+   __USE_BSD		Define 4.3BSD things.
+   __USE_SVID		Define SVID things.
+   __USE_MISC		Define things common to BSD and System V Unix.
+   __USE_GNU		Define GNU extensions.
+   __USE_REENTRANT	Define reentrant/thread-safe *_r functions.
+   __FAVOR_BSD		Favor 4.3BSD things in cases of conflict.
+
+   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
+   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
+   only for compatibility.  All new code should use the other symbols
+   to test for features.
+
+   All macros listed above as possibly being defined by this file are
+   explicitly undefined if they are not explicitly defined.
+   Feature-test macros that are not defined by the user or compiler
+   but are implied by the other feature-test macros defined (or by the
+   lack of any definitions) are defined by the file.  */
+
+/* Undefine everything, so we get a clean slate.  */
+#undef	__USE_ISOC99
+#undef	__USE_POSIX
+#undef	__USE_POSIX2
+#undef	__USE_POSIX199309
+#undef	__USE_POSIX199506
+#undef	__USE_XOPEN
+#undef	__USE_XOPEN_EXTENDED
+#undef	__USE_UNIX98
+#undef	__USE_XOPEN2K
+#undef	__USE_LARGEFILE
+#undef	__USE_LARGEFILE64
+#undef	__USE_FILE_OFFSET64
+#undef	__USE_BSD
+#undef	__USE_SVID
+#undef	__USE_MISC
+#undef	__USE_GNU
+#undef	__USE_REENTRANT
+#undef	__FAVOR_BSD
+#undef	__KERNEL_STRICT_NAMES
+
+/* Suppress kernel-name space pollution unless user expressedly asks
+   for it.  */
+#ifndef _LOOSE_KERNEL_NAMES
+# define __KERNEL_STRICT_NAMES
+#endif
+
+/* Always use ISO C things.  */
+#define	__USE_ANSI	1
+
+
+/* If _BSD_SOURCE was defined by the user, favor BSD over POSIX.  */
+#if defined _BSD_SOURCE && \
+    !(defined _POSIX_SOURCE || defined _POSIX_C_SOURCE || \
+      defined _XOPEN_SOURCE || defined _XOPEN_SOURCE_EXTENDED || \
+      defined _GNU_SOURCE || defined _SVID_SOURCE)
+# define __FAVOR_BSD	1
+#endif
+
+/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
+#ifdef _GNU_SOURCE
+# undef  _ISOC99_SOURCE
+# define _ISOC99_SOURCE	1
+# undef  _POSIX_SOURCE
+# define _POSIX_SOURCE	1
+# undef  _POSIX_C_SOURCE
+# define _POSIX_C_SOURCE	199506L
+# undef  _XOPEN_SOURCE
+# define _XOPEN_SOURCE	600
+# undef  _XOPEN_SOURCE_EXTENDED
+# define _XOPEN_SOURCE_EXTENDED	1
+# undef	 _LARGEFILE64_SOURCE
+# define _LARGEFILE64_SOURCE	1
+# undef  _BSD_SOURCE
+# define _BSD_SOURCE	1
+# undef  _SVID_SOURCE
+# define _SVID_SOURCE	1
+#endif
+
+/* If nothing (other than _GNU_SOURCE) is defined,
+   define _BSD_SOURCE and _SVID_SOURCE.  */
+#if (!defined __STRICT_ANSI__ && !defined _ISOC99_SOURCE && \
+     !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE && \
+     !defined _XOPEN_SOURCE && !defined _XOPEN_SOURCE_EXTENDED && \
+     !defined _BSD_SOURCE && !defined _SVID_SOURCE)
+# define _BSD_SOURCE	1
+# define _SVID_SOURCE	1
+#endif
+
+/* This is to enable the ISO C99 extension.  Also recognize the old macro
+   which was used prior to the standard acceptance.  This macro will
+   eventually go away and the features enabled by default once the ISO C99
+   standard is widely adopted.  */
+#if (defined _ISOC99_SOURCE || defined _ISOC9X_SOURCE \
+     || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))
+# define __USE_ISOC99	1
+#endif
+
+/* If none of the ANSI/POSIX macros are defined, use POSIX.1 and POSIX.2
+   (and IEEE Std 1003.1b-1993 unless _XOPEN_SOURCE is defined).  */
+#if (!defined __STRICT_ANSI__ && !defined _POSIX_SOURCE && \
+     !defined _POSIX_C_SOURCE)
+# define _POSIX_SOURCE	1
+# if defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 500
+#  define _POSIX_C_SOURCE	2
+# else
+#  define _POSIX_C_SOURCE	199506L
+# endif
+#endif
+
+#if defined _POSIX_SOURCE || _POSIX_C_SOURCE >= 1 || defined _XOPEN_SOURCE
+# define __USE_POSIX	1
+#endif
+
+#if defined _POSIX_C_SOURCE && _POSIX_C_SOURCE >= 2 || defined _XOPEN_SOURCE
+# define __USE_POSIX2	1
+#endif
+
+#if (_POSIX_C_SOURCE - 0) >= 199309L
+# define __USE_POSIX199309	1
+#endif
+
+#if (_POSIX_C_SOURCE - 0) >= 199506L
+# define __USE_POSIX199506	1
+#endif
+
+#ifdef	_XOPEN_SOURCE
+# define __USE_XOPEN	1
+# if (_XOPEN_SOURCE - 0) >= 500
+#  define __USE_XOPEN_EXTENDED	1
+#  define __USE_UNIX98	1
+#  undef _LARGEFILE_SOURCE
+#  define _LARGEFILE_SOURCE	1
+#  if (_XOPEN_SOURCE - 0) >= 600
+#   define __USE_XOPEN2K	1
+#   undef __USE_ISOC99
+#   define __USE_ISOC99		1
+#  endif
+# else
+#  ifdef _XOPEN_SOURCE_EXTENDED
+#   define __USE_XOPEN_EXTENDED	1
+#  endif
+# endif
+#endif
+
+#ifdef _LARGEFILE_SOURCE
+# define __USE_LARGEFILE	1
+#endif
+
+#ifdef _LARGEFILE64_SOURCE
+# define __USE_LARGEFILE64	1
+#endif
+
+#if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
+# define __USE_FILE_OFFSET64	1
+#endif
+
+#if defined _BSD_SOURCE || defined _SVID_SOURCE
+# define __USE_MISC	1
+#endif
+
+#ifdef	_BSD_SOURCE
+# define __USE_BSD	1
+#endif
+
+#ifdef	_SVID_SOURCE
+# define __USE_SVID	1
+#endif
+
+#ifdef	_GNU_SOURCE
+# define __USE_GNU	1
+#endif
+
+#if defined _REENTRANT || defined _THREAD_SAFE
+# define __USE_REENTRANT	1
+#endif
+
+/* We do support the IEC 559 math functionality, real and complex.  */
+#define __STDC_IEC_559__		1
+#define __STDC_IEC_559_COMPLEX__	1
+
+/* This macro indicates that the installed library is uClibc.  Use
+ * __UCLIBC_MAJOR__ and __UCLIBC_MINOR__ to test for the features in
+ * specific releases.  */
+#define	__UCLIBC__		1
+
+/* Load up the current set of uClibc supported features along
+ * with the current uClibc major and minor version numbers.
+ * For uClibc release 0.9.26, these numbers would be:
+ *	#define	__UCLIBC_MAJOR__	0
+ *	#define	__UCLIBC_MINOR__	9
+ *	#define	__UCLIBC_SUBLEVEL__	26
+ */
+#define __need_uClibc_config_h
+#include <bits/uClibc_config.h>
+#undef __need_uClibc_config_h
+
+#ifdef __UCLIBC_HAS_WCHAR__
+/* wchar_t uses ISO 10646-1 (2nd ed., published 2000-09-15) / Unicode 3.0.  */
+# define __STDC_ISO_10646__		200009L
+#endif
+
+/*  There is an unwholesomely huge amount of code out there that depends on the
+ *  presence of GNU libc header files.  We have GNU libc header files.  So here
+ *  we commit a horrible sin.  At this point, we _lie_ and claim to be GNU libc
+ *  to make things like /usr/include/linux/socket.h and lots of apps work as
+ *  their developers intended.  This is IMHO, pardonable, since these defines
+ *  are not really intended to check for the presence of a particular library,
+ *  but rather are used to define an _interface_.  */
+#if !defined __FORCE_NOGLIBC && (!defined _LIBC || defined __FORCE_GLIBC)
+#   define __GNU_LIBRARY__ 6
+#   define __GLIBC__       2
+#   define __GLIBC_MINOR__ 2
+#endif
+
+/* Convenience macros to test the versions of glibc and gcc.
+   Use them like this:
+   #if __GNUC_PREREQ (2,8)
+   ... code requiring gcc 2.8 or later ...
+   #endif
+   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
+   were not defined then.  */
+#if defined __GNUC__ && defined __GNUC_MINOR__
+# define __GNUC_PREREQ(maj, min) \
+	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+#else
+# define __GNUC_PREREQ(maj, min) 0
+#endif
+
+#define __GLIBC_PREREQ(maj, min) \
+	((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))
+
+/* This is here only because every header file already includes this one.  */
+#ifndef __ASSEMBLER__
+#ifndef _SYS_CDEFS_H
+# include <sys/cdefs.h>
+#endif
+
+/* If we don't have __REDIRECT, prototypes will be missing if
+   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */
+# if defined __USE_FILE_OFFSET64 && !defined __REDIRECT
+#  define __USE_LARGEFILE	1
+#  define __USE_LARGEFILE64	1
+# endif
+
+#endif	/* !ASSEMBLER */
+
+/* Decide whether we can define 'extern inline' functions in headers.  */
+#if __GNUC_PREREQ (2, 7) && defined __OPTIMIZE__ \
+    && !defined __OPTIMIZE_SIZE__ && !defined __NO_INLINE__
+# define __USE_EXTERN_INLINES	1
+#endif
+
+
+/* Make sure users large file options agree with uClibc's configuration. */
+#ifndef __UCLIBC_HAS_LFS__
+
+/* If uClibc was built without large file support, output an error if
+ * and 64-bit file offsets were requested, output an error.
+ * NOTE: This is probably incorrect on a 64-bit arch... */
+#ifdef __USE_FILE_OFFSET64
+#error It appears you have defined _FILE_OFFSET_BITS=64.  Unfortunately, \
+uClibc was built without large file support enabled.
+#endif
+
+/* If uClibc was built without large file support and _LARGEFILE64_SOURCE
+ * is defined, undefine it. */
+#if defined(_LARGEFILE64_SOURCE)
+#undef _LARGEFILE64_SOURCE
+#undef __USE_LARGEFILE64
+#endif
+
+/* If we're actually building uClibc with large file support,
+ * define __USE_LARGEFILE64 and __USE_LARGEFILE. */
+#elif defined(_LIBC)
+#undef _LARGEFILE_SOURCE
+#undef _LARGEFILE64_SOURCE
+#undef _FILE_OFFSET_BITS
+#undef __USE_LARGEFILE
+#undef __USE_LARGEFILE64
+#undef __USE_FILE_OFFSET64
+#define _LARGEFILE_SOURCE       1
+#define _LARGEFILE64_SOURCE     1
+#define __USE_LARGEFILE         1
+#define __USE_LARGEFILE64       1
+#endif
+
+/* Some nice features only work properly with ELF */
+#if defined _LIBC 
+#if defined __HAVE_ELF__
+/* Define ALIASNAME as a weak alias for NAME. */
+#  define weak_alias(name, aliasname) _weak_alias (name, aliasname)
+#  define _weak_alias(name, aliasname) \
+      extern __typeof (name) aliasname __attribute__ ((weak, alias (#name)));
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
+/* This comes between the return type and function name in
+ *    a function definition to make that definition weak.  */
+# define weak_function __attribute__ ((weak))
+# define weak_const_function __attribute__ ((weak, __const__))
+/* Tacking on "\n\t#" to the section name makes gcc put it's bogus
+ * section attributes on what looks like a comment to the assembler. */
+#  if defined(__cris__) 
+#    define link_warning(symbol, msg)
+#  else
+#    define link_warning(symbol, msg)					      \
+	asm (".section "  ".gnu.warning." #symbol  "\n\t.previous");	      \
+	    static const char __evoke_link_warning_##symbol[]		      \
+	    __attribute__ ((unused, section (".gnu.warning." #symbol "\n\t#"))) = msg;
+#endif
+#else /* !defined __HAVE_ELF__ */
+#  define strong_alias(name, aliasname) _strong_alias (name, aliasname)
+#  define weak_alias(name, aliasname) _strong_alias (name, aliasname)
+#  define _strong_alias(name, aliasname) \
+	__asm__(".global " __C_SYMBOL_PREFIX__ #aliasname "\n" \
+                ".set " __C_SYMBOL_PREFIX__ #aliasname "," __C_SYMBOL_PREFIX__ #name);
+#  define link_warning(symbol, msg) \
+	asm (".stabs \"" msg "\",30,0,0,0\n\t" \
+	      ".stabs \"" #symbol "\",1,0,0,0\n");
+#endif
+
+#ifndef weak_function
+/* If we do not have the __attribute__ ((weak)) syntax, there is no way we
+   can define functions as weak symbols.  The compiler will emit a `.globl'
+   directive for the function symbol, and a `.weak' directive in addition
+   will produce an error from the assembler.  */ 
+# define weak_function          /* empty */
+# define weak_const_function    /* empty */
+#endif
+
+/* On some platforms we can make internal function calls (i.e., calls of
+   functions not exported) a bit faster by using a different calling
+   convention.  */
+#ifndef internal_function
+# define internal_function      /* empty */
+#endif
+
+/* Prepare for the case that `__builtin_expect' is not available.  */
+#if __GNUC__ == 2 && __GNUC_MINOR__ < 96
+#define __builtin_expect(x, expected_value) (x)
+#endif
+#ifndef likely
+# define likely(x)	__builtin_expect((!!(x)),1)
+#endif
+#ifndef unlikely
+# define unlikely(x)	__builtin_expect((!!(x)),0)
+#endif
+#ifndef __LINUX_COMPILER_H
+#define __LINUX_COMPILER_H
+#endif
+#ifndef __cast__
+#define __cast__(_to)
+#endif
+
+/* Arrange to hide uClibc internals */
+#if __GNUC_PREREQ (3, 3)
+# define attribute_hidden __attribute__ ((visibility ("hidden")))
+#else
+# define attribute_hidden
+#endif
+
+/* Pull in things like __attribute_used__ */
+#include <sys/cdefs.h>
+
+/* --- this is added to integrate linuxthreads */
+#define __USE_UNIX98            1
+
+#endif /* _LIBC only stuff */
+
+#ifndef __linux__
+# define __linux__ 1
+#endif
+
+/* Disable __user, which shows up in 2.6.x include asm headers
+ * that get pulled in by signal.h */
+#define __user
+
+#endif	/* features.h  */
diff -pruwN busybox-1.01/include2/fnmatch.h busybox-1.01-livebox/include2/fnmatch.h
--- busybox-1.01/include2/fnmatch.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/fnmatch.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,85 @@
+/* Copyright (C) 1991,92,93,96,97,98,99,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FNMATCH_H
+#define	_FNMATCH_H	1
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#if defined __cplusplus || (defined __STDC__ && __STDC__) || defined WINDOWS32
+# if !defined __GLIBC__ || !defined __P
+#  undef	__P
+#  define __P(protos)	protos
+# endif
+#else /* Not C++ or ANSI C.  */
+# undef	__P
+# define __P(protos)	()
+/* We can get away without defining `const' here only because in this file
+   it is used only inside the prototype for `fnmatch', which is elided in
+   non-ANSI C where `const' is problematical.  */
+#endif /* C++ or ANSI C.  */
+
+#ifndef const
+# if (defined __STDC__ && __STDC__) || defined __cplusplus
+#  define __const	const
+# else
+#  define __const
+# endif
+#endif
+
+/* We #undef these before defining them because some losing systems
+   (HP-UX A.08.07 for example) define these in <unistd.h>.  */
+#undef	FNM_PATHNAME
+#undef	FNM_NOESCAPE
+#undef	FNM_PERIOD
+
+/* Bits set in the FLAGS argument to `fnmatch'.  */
+#define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
+#define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
+#define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
+
+#if !defined _POSIX_C_SOURCE || _POSIX_C_SOURCE < 2 || defined _GNU_SOURCE
+# define FNM_FILE_NAME	 FNM_PATHNAME	/* Preferred GNU name.  */
+# define FNM_LEADING_DIR (1 << 3)	/* Ignore `/...' after a match.  */
+# define FNM_CASEFOLD	 (1 << 4)	/* Compare without regard to case.  */
+# define FNM_EXTMATCH	 (1 << 5)	/* Use ksh-like extended matching. */
+#endif
+
+/* Value returned by `fnmatch' if STRING does not match PATTERN.  */
+#define	FNM_NOMATCH	1
+
+/* This value is returned if the implementation does not support
+   `fnmatch'.  Since this is not the case here it will never be
+   returned but the conformance test suites still require the symbol
+   to be defined.  */
+#ifdef _XOPEN_SOURCE
+# define FNM_NOSYS	(-1)
+#endif
+
+/* Match NAME against the filename pattern PATTERN,
+   returning zero if it matches, FNM_NOMATCH if not.  */
+extern int fnmatch __P ((__const char *__pattern, __const char *__name,
+			 int __flags));
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif /* fnmatch.h */
diff -pruwN busybox-1.01/include2/getopt.h busybox-1.01-livebox/include2/getopt.h
--- busybox-1.01/include2/getopt.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/getopt.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,4 @@
+/* This file will not be installed if not using gnu getopt. */
+
+#include <bits/getopt.h>
+
diff -pruwN busybox-1.01/include2/grp.h busybox-1.01-livebox/include2/grp.h
--- busybox-1.01/include2/grp.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/grp.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,148 @@
+/* Copyright (C) 1991,92,95,96,97,98,99,2000,01 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 9.2.1 Group Database Access	<grp.h>
+ */
+
+#ifndef	_GRP_H
+#define	_GRP_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/types.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+
+/* For the Single Unix specification we must define this type here.  */
+#if defined __USE_XOPEN && !defined __gid_t_defined
+typedef __gid_t gid_t;
+# define __gid_t_defined
+#endif
+
+/* The group structure.	 */
+struct group
+  {
+    char *gr_name;		/* Group name.	*/
+    char *gr_passwd;		/* Password.	*/
+    __gid_t gr_gid;		/* Group ID.	*/
+    char **gr_mem;		/* Member list.	*/
+  };
+
+
+#if defined __USE_SVID || defined __USE_GNU
+# define __need_FILE
+# include <stdio.h>
+#endif
+
+
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Rewind the group-file stream.  */
+extern void setgrent (void) __THROW;
+
+/* Close the group-file stream.  */
+extern void endgrent (void) __THROW;
+
+/* Read an entry from the group-file stream, opening it if necessary.  */
+extern struct group *getgrent (void) __THROW;
+#endif
+
+#ifdef	__USE_SVID
+/* Read a group entry from STREAM.  */
+extern struct group *fgetgrent (FILE *__stream) __THROW;
+#endif
+
+#ifdef __USE_GNU
+/* Write the given entry onto the given stream.  */
+extern int putgrent (__const struct group *__restrict __p,
+		     FILE *__restrict __f) __THROW;
+#endif
+
+/* Search for an entry with a matching group ID.  */
+extern struct group *getgrgid (__gid_t __gid) __THROW;
+
+/* Search for an entry with a matching group name.  */
+extern struct group *getgrnam (__const char *__name) __THROW;
+
+#if defined __USE_POSIX || defined __USE_MISC
+
+# ifdef __USE_MISC
+/* Reasonable value for the buffer sized used in the reentrant
+   functions below.  But better use `sysconf'.  */
+#  define NSS_BUFLEN_GROUP	1024
+# endif
+
+/* Reentrant versions of some of the functions above.
+
+   PLEASE NOTE: the `getgrent_r' function is not (yet) standardized.
+   The interface may change in later versions of this library.  But
+   the interface is designed following the principals used for the
+   other reentrant functions so the chances are good this is what the
+   POSIX people would choose.  */
+
+# ifdef __USE_GNU
+extern int getgrent_r (struct group *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct group **__restrict __result) __THROW;
+# endif
+
+/* Search for an entry with a matching group ID.  */
+extern int getgrgid_r (__gid_t __gid, struct group *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct group **__restrict __result) __THROW;
+
+/* Search for an entry with a matching group name.  */
+extern int getgrnam_r (__const char *__restrict __name,
+		       struct group *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct group **__restrict __result) __THROW;
+
+# ifdef	__USE_SVID
+/* Read a group entry from STREAM.  This function is not standardized
+   an probably never will.  */
+extern int fgetgrent_r (FILE *__restrict __stream,
+			struct group *__restrict __resultbuf,
+			char *__restrict __buffer, size_t __buflen,
+			struct group **__restrict __result) __THROW;
+# endif
+
+#endif	/* POSIX or reentrant */
+
+
+#ifdef	__USE_BSD
+
+# define __need_size_t
+# include <stddef.h>
+
+/* Set the group set for the current user to GROUPS (N of them).  */
+extern int setgroups (size_t __n, __const __gid_t *__groups) __THROW;
+
+/* Initialize the group set for the current user
+   by reading the group database and using all groups
+   of which USER is a member.  Also include GROUP.  */
+extern int initgroups (__const char *__user, __gid_t __group) __THROW;
+
+#endif /* Use BSD.  */
+
+__END_DECLS
+
+#endif /* grp.h  */
diff -pruwN busybox-1.01/include2/libgen.h busybox-1.01-livebox/include2/libgen.h
--- busybox-1.01/include2/libgen.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/libgen.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,40 @@
+/* Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LIBGEN_H
+#define _LIBGEN_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Return directory part of PATH or "." if none is available.  */
+extern char *dirname (char *__path) __THROW;
+
+/* Return final component of PATH.
+
+   This is the weird XPG version of this function.  It sometimes will
+   modify its argument.  Therefore we normally use the GNU version (in
+   <string.h>) and only if this header is included make the XPG
+   version available under the real name.  */
+extern char *__xpg_basename (char *__path) __THROW;
+#define basename	__xpg_basename
+
+__END_DECLS
+
+#endif /* libgen.h */
diff -pruwN busybox-1.01/include2/limits.h busybox-1.01-livebox/include2/limits.h
--- busybox-1.01/include2/limits.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/limits.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,153 @@
+/* Copyright (C) 1991, 92, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>
+ */
+
+#ifndef _LIBC_LIMITS_H_
+#define _LIBC_LIMITS_H_	1
+
+#include <features.h>
+
+
+/* Maximum length of any multibyte character in any locale.
+   We define this value here since the gcc header does not define
+   the correct value.  */
+#define MB_LEN_MAX	16
+
+
+/* If we are not using GNU CC we have to define all the symbols ourself.
+   Otherwise use gcc's definitions (see below).  */
+#if !defined __GNUC__ || __GNUC__ < 2
+
+/* We only protect from multiple inclusion here, because all the other
+   #include's protect themselves, and in GCC 2 we may #include_next through
+   multiple copies of this file before we get to GCC's.  */
+# ifndef _LIMITS_H
+#  define _LIMITS_H	1
+
+#include <bits/wordsize.h>
+
+/* We don't have #include_next.
+   Define ANSI <limits.h> for standard 32-bit words.  */
+
+/* These assume 8-bit `char's, 16-bit `short int's,
+   and 32-bit `int's and `long int's.  */
+
+/* Number of bits in a `char'.	*/
+#  define CHAR_BIT	8
+
+/* Minimum and maximum values a `signed char' can hold.  */
+#  define SCHAR_MIN	(-128)
+#  define SCHAR_MAX	127
+
+/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */
+#  define UCHAR_MAX	255
+
+/* Minimum and maximum values a `char' can hold.  */
+#  ifdef __CHAR_UNSIGNED__
+#   define CHAR_MIN	0
+#   define CHAR_MAX	UCHAR_MAX
+#  else
+#   define CHAR_MIN	SCHAR_MIN
+#   define CHAR_MAX	SCHAR_MAX
+#  endif
+
+/* Minimum and maximum values a `signed short int' can hold.  */
+#  define SHRT_MIN	(-32768)
+#  define SHRT_MAX	32767
+
+/* Maximum value an `unsigned short int' can hold.  (Minimum is 0.)  */
+#  define USHRT_MAX	65535
+
+/* Minimum and maximum values a `signed int' can hold.  */
+#  define INT_MIN	(-INT_MAX - 1)
+#  define INT_MAX	2147483647
+
+/* Maximum value an `unsigned int' can hold.  (Minimum is 0.)  */
+#  define UINT_MAX	4294967295U
+
+/* Minimum and maximum values a `signed long int' can hold.  */
+#  if __WORDSIZE == 64
+#   define LONG_MAX	9223372036854775807L
+#  else
+#   define LONG_MAX	2147483647L
+#  endif
+#  define LONG_MIN	(-LONG_MAX - 1L)
+
+/* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */
+#  if __WORDSIZE == 64
+#   define ULONG_MAX	18446744073709551615UL
+#  else
+#   define ULONG_MAX	4294967295UL
+#  endif
+
+#  ifdef __USE_ISOC99
+
+/* Minimum and maximum values a `signed long long int' can hold.  */
+#   define LLONG_MAX	9223372036854775807LL
+#   define LLONG_MIN	(-LLONG_MAX - 1LL)
+
+/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  */
+#   define ULLONG_MAX	18446744073709551615ULL
+
+#  endif /* ISO C99 */
+
+# endif	/* limits.h  */
+#endif	/* GCC 2.  */
+
+#endif	/* !_LIBC_LIMITS_H_ */
+
+ /* Get the compiler's limits.h, which defines almost all the ISO constants.
+
+    We put this #include_next outside the double inclusion check because
+    it should be possible to include this file more than once and still get
+    the definitions from gcc's header.  */
+#if defined __GNUC__ && !defined _GCC_LIMITS_H_
+/* `_GCC_LIMITS_H_' is what GCC's file defines.  */
+# include_next <limits.h>
+
+/* The <limits.h> files in some gcc versions don't define LLONG_MIN,
+   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
+   ages are available.  */
+# ifdef __USE_ISOC99
+#  ifndef LLONG_MIN
+#   define LLONG_MIN	LONG_LONG_MIN
+#  endif
+#  ifndef LLONG_MAX
+#   define LLONG_MAX	LONG_LONG_MAX
+#  endif
+#  ifndef ULLONG_MAX
+#   define ULLONG_MAX	ULONG_LONG_MAX
+#  endif
+# endif
+#endif
+
+#ifdef	__USE_POSIX
+/* POSIX adds things to <limits.h>.  */
+# include <bits/posix1_lim.h>
+#endif
+
+#ifdef	__USE_POSIX2
+# include <bits/posix2_lim.h>
+#endif
+
+#ifdef	__USE_XOPEN
+# include <bits/xopen_lim.h>
+#endif
diff -pruwN busybox-1.01/include2/linux/autoconf.h busybox-1.01-livebox/include2/linux/autoconf.h
--- busybox-1.01/include2/linux/autoconf.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/autoconf.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,2281 @@
+/* OpenRG: This file was automatically generated by pkg/build/create_config 
+ * See /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/build.FAST3202_LBV2ULT/config.log for configuration log.
+ */
+
+#define AUTOCONF_INCLUDED
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:22 */
+#define cCONFIG_SAGEM_WITH_HARDWARE_WATCHDOG_ADI 1
+#define CONFIG_SAGEM_WITH_HARDWARE_WATCHDOG_ADI 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:50 */
+#define CONFIG_INOTIFY 1
+
+#define cCONFIG_RG_DEV_IF_ATHBCMWRAPPER 0
+
+#define cCONFIG_RG_DEV_IF_BCM43XX 0
+
+#define cCONFIG_RG_DEV_IF_AR500XX 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1582 */
+#define CONFIG_RG_DEV_IF_VLAN 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1654 */
+#define CONFIG_RG_DEV_IF_ETHOA 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/device_config.c:193 */
+#define CONFIG_RG_DEV_IF_BRIDGE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1518 */
+#define CONFIG_RG_DEV_IF_AD6834_ETH 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1639 */
+#define CONFIG_RG_DEV_IF_AD68XX_ADSL 1
+
+#define cCONFIG_RG_DEV_IF_HSDPA 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3268 */
+#define cCONFIG_BOOTLDR_UBOOT 1
+#define CONFIG_BOOTLDR_UBOOT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2971 */
+#define RG_PROD_STR "Livebox"
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:40 */
+#define CONFIG_RG_OS "LINUX_26"
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:206 */
+#define cCONFIG_RG_HW "FAST3202"
+#define CONFIG_RG_HW "FAST3202"
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:207 */
+#define cCONFIG_RG_HW_DESC_STR "Sagem F@ST3202 Livebox1"
+#define CONFIG_RG_HW_DESC_STR "Sagem F@ST3202 Livebox1"
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:5054 */
+#define cCONFIG_RG_DIST "FAST3202_LBV2ULT"
+#define CONFIG_RG_DIST "FAST3202_LBV2ULT"
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3240 */
+#define cCONFIG_RG_WBM_READONLY_USERS_GROUPS 1
+#define CONFIG_RG_WBM_READONLY_USERS_GROUPS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:95 */
+#define CONFIG_MMU 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:68 */
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:71 */
+#define CONFIG_PRINTK 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:73 */
+#define CONFIG_BUG 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:74 */
+#define CONFIG_TINY_SHMEM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:75 */
+#define CONFIG_BASE_SMALL 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:101 */
+#define CONFIG_OBSOLETE_MODPARM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:102 */
+#define CONFIG_KMOD 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:76 */
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:118 */
+#define CONFIG_IOSCHED_NOOP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:96 */
+#define CONFIG_DEFAULT_IOSCHED "anticipatory"
+
+#define cCONFIG_NET_IPGRE_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1234 */
+#define CONFIG_XFRM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1235 */
+#define CONFIG_CRYPTO 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1236 */
+#define CONFIG_CRYPTO_HMAC 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1237 */
+#define CONFIG_CRYPTO_MD5 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1238 */
+#define CONFIG_CRYPTO_SHA1 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1239 */
+#define CONFIG_CRYPTO_AES 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1240 */
+#define CONFIG_INET_AH 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:115 */
+#define CONFIG_NET_SCH_CLK_JIFFIES 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:124 */
+#define CONFIG_LEGACY_PTYS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:125 */
+#define CONFIG_LEGACY_PTY_COUNT 256
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1195 */
+#define CONFIG_LOG_BUF_SHIFT 14
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:93 */
+#define CONFIG_CRC32 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:77 */
+#define CONFIG_GENERIC_HARDIRQS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:114 */
+#define CONFIG_IP_MULTIPLE_TABLES 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:100 */
+#define CONFIG_MODULE_UNLOAD 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1177 */
+#define CONFIG_BOOT_ELF32 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1191 */
+#define CONFIG_DMA_NONCOHERENT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3255 */
+#define cCONFIG_SOFTIRQ_THROTTLE 1
+#define CONFIG_SOFTIRQ_THROTTLE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1250 */
+#define CONFIG_KALLSYMS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1193 */
+#define CONFIG_MIPS_L1_CACHE_SHIFT 5
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1231 */
+#define CONFIG_DEBUG_INFO 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1194 */
+#define CONFIG_PAGE_SIZE_4KB 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1192 */
+#define CONFIG_TRAD_SIGNALS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2545 */
+#define CONFIG_INITRAMFS_SOURCE $(RAMDISK_MOUNT_POINT)
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2546 */
+#define CONFIG_INITRAMFS_ROOT_UID $(shell id -u)
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2547 */
+#define CONFIG_INITRAMFS_ROOT_GID $(shell id -g)
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:111 */
+#define CONFIG_IP_FIB_HASH 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1169 */
+#define ARCH "mips"
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1170 */
+#define LIBC_ARCH mips
+
+#define cCONFIG_BRIDGE_FEATURE 0
+
+#define cCONFIG_BRIDGE_UTILS 0
+
+#define cCONFIG_IPTABLES 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:575 */
+#define CONFIG_NETFILTER 1
+
+#define cCONFIG_IP_NF_FILTER_FEATURE 0
+
+#define cCONFIG_IP_NF_IPTABLES_FEATURE 0
+
+#define cCONFIG_IP_NF_CONNTRACK_FEATURE 0
+
+#define cCONFIG_IP_NF_NAT_FEATURE 0
+
+#define cCONFIG_IP_NF_TARGET_MASQUERADE_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3061 */
+#define CONFIG_EXPORT_BINARIES 1
+
+#define cCONFIG_LSP_DIST 0
+
+#define cCONFIG_RG_RGLOADER 0
+
+#define cCONFIG_RG_NETWORK_BOOT 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:299 */
+#define CONFIG_RG_RGLOADER_CLI_CMD 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1828 */
+#define CONFIG_RG_UIEVENTS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1829 */
+#define cCONFIG_RG_KLEDS_FEATURE 1
+#define CONFIG_RG_KLEDS_FEATURE 1
+#define CONFIG_RG_KLEDS_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1831 */
+#define cCONFIG_RG_KSTART_LEDS_LUMS_FEATURE 1
+#define CONFIG_RG_KSTART_LEDS_LUMS_FEATURE 1
+#define CONFIG_RG_KSTART_LEDS_LUMS_MODULE 1
+
+#define cCONFIG_RG_KRGLDR_FEATURE 0
+
+#define cCONFIG_RG_KMONTE 0
+
+#define cCONFIG_PCMCIA 0
+#define cCONFIG_PCMCIA_FEATURE 0
+
+#define cCONFIG_80211G_AP_ADVANCED 0
+
+#define cCONFIG_80211_WDS 0
+
+#define cCONFIG_8139TOO_FEATURE 0
+
+#define cCONFIG_ARCH_IXP22X 0
+
+#define cCONFIG_ARCH_IXP425_HG21 0
+
+#define cCONFIG_ARCH_IXP425_NAPA 0
+
+#define cCONFIG_ARCH_IXP425_BAMBOO 0
+
+#define cCONFIG_ARCH_IXP425_JEEVES 0
+
+#define cCONFIG_JEEVES_RTC7301_FEATURE 0
+
+#define cCONFIG_ARCH_IXP425_WAV54G 0
+
+#define cCONFIG_ARCH_IXP425_BRUCE 0
+
+#define cCONFIG_ARCH_IXP425_BRUCE_CPLD_FEATURE 0
+
+#define cCONFIG_ARM 0
+
+#define cCONFIG_ARMNOMMU 0
+
+#define cCONFIG_ATALK_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:424 */
+#define cCONFIG_ATM 1
+#define CONFIG_ATM 1
+
+#define cCONFIG_ATM_NULL 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:426 */
+#define cCONFIG_ATM_BR2684_FEATURE 1
+#define CONFIG_ATM_BR2684_FEATURE 1
+#define CONFIG_ATM_BR2684 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:433 */
+#define cCONFIG_ATM_CLIP_FEATURE 1
+#define CONFIG_ATM_CLIP_FEATURE 1
+#define CONFIG_ATM_CLIP_MODULE 1
+
+#define cCONFIG_ATM_CONEXANT_DSL_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:425 */
+#define CONFIG_ATM_SKB 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:429 */
+#define cCONFIG_ATM_PVC_SCAN 1
+#define CONFIG_ATM_PVC_SCAN 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1635 */
+#define cCONFIG_RG_ATM_QOS 1
+#define CONFIG_RG_ATM_QOS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:214 */
+#define cCONFIG_AUTO_LEARN_DNS 1
+#define CONFIG_AUTO_LEARN_DNS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:80 */
+#define cCONFIG_BINFMT_ELF_FEATURE 1
+#define CONFIG_BINFMT_ELF_FEATURE 1
+#define CONFIG_BINFMT_ELF 1
+
+#define cCONFIG_BLK_DEV_IDE_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1100 */
+#define CONFIG_CMDLINE "console=ttyS0,57600 quiet"
+
+#define cCONFIG_CNXT_EMAC_FEATURE 0
+
+#define cCONFIG_CNXT_ADSL_FEATURE 0
+
+#define cCONFIG_CNXT_ATM_FEATURE 0
+
+#define cCONFIG_CNXT_SOFTSAR_FEATURE 0
+
+#define cCONFIG_CONEXANT_DSL_TIGRIS_FEATURE 0
+
+#define cCONFIG_CONEXANT_DSL_YUKON_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2567 */
+#define CONFIG_CRAMFS_DYN_BLOCKSIZE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2582 */
+#define CONFIG_CRAMFS_BLKSZ 65536
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1171 */
+#define CONFIG_CPU_BIG_ENDIAN 1
+
+#define cCONFIG_ROMFS_FS 0
+
+#define cCONFIG_RG_BZIP2 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2563 */
+#define CONFIG_CRAMFS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2551 */
+#define CONFIG_CRAMFS_FS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:123 */
+#define CONFIG_NTFS_FS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2561 */
+#define cCONFIG_CRAMFS_FS_COMMON 1
+#define CONFIG_CRAMFS_FS_COMMON 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1201 */
+#define CONFIG_CROSSCOMPILE 1
+
+#define cCONFIG_CX821XX_COMMON 0
+
+#define cCONFIG_GEMTEK_WX5715 0
+
+#define cCONFIG_ISL38XX_FEATURE 0
+
+#define cCONFIG_ISL_SOFTMAC_FEATURE 0
+
+#define cCONFIG_RALINK_RT2560_FEATURE 0
+
+#define cCONFIG_AGN100_FEATURE 0
+
+#define cCONFIG_WIRELESS_TOOLS 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:144 */
+#define cCONFIG_RG_WIRELESS_EXTENSIONS 1
+#define CONFIG_RG_WIRELESS_EXTENSIONS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:874 */
+#define CONFIG_DEF_KEYS 1
+
+#define cCONFIG_DSL_SYNCD_FEATURE 0
+
+#define cCONFIG_DUETTE_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1204 */
+#define CONFIG_DYN_LINK 1
+
+#define cCONFIG_EEPRO100_FEATURE 0
+
+#define cCONFIG_EEXPRESS_PRO100_FEATURE 0
+/* Set by command line */
+#define LIC /home/p778094/devbis/kernel/4.3.14/lastcheckout/license/jpkg_fast3202.lic
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/create_config.c:655 */
+#define LICSTR 34ab8923211d0b2de5d3d0b527e8e204cf095886cdab51635b07f7222b565eb03491a37a19864f125d3bf8b5838ce291e6cc9907678ec674b5d1cee0a0fbd19115f3bd3d3a0ee7f89b9af02f
+
+#define cCONFIG_LICENSE_AGREEMENT 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:51 */
+#define CONFIG_E2FSPROGS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2859 */
+#define CONFIG_DOSFSPROGS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2860 */
+#define CONFIG_EXT2_FS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:124 */
+#define CONFIG_EXT3_FS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:125 */
+#define CONFIG_JBD 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1103 */
+#define CONFIG_MAGIC_SYSRQ 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1494 */
+#define CONFIG_FREEPAGES_HIGH 384
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1493 */
+#define CONFIG_FREEPAGES_LOW 256
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1492 */
+#define CONFIG_FREEPAGES_MIN 32
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3079 */
+#define CONFIG_FREEPAGES_THRESHOLD 1
+
+#define cCONFIG_FREESWAN 0
+
+#define cCONFIG_RG_NETBIOS_RT_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1483 */
+#define CONFIG_GEN_RG_DEFAULT 1
+
+#define cCONFIG_GLIBC 0
+
+#define cCONFIG_GMP 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1166 */
+#define CONFIG_HAS_MMU 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/device_config.c:203 */
+#define cCONFIG_DEF_BRIDGE_LANS 1
+#define CONFIG_DEF_BRIDGE_LANS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/device_config.c:205 */
+#define cCONFIG_DEF_BRIDGE_WAN 1
+#define CONFIG_DEF_BRIDGE_WAN 1
+
+#define cCONFIG_DEF_WAN_BRIDGE_FALLBACK_IP 0
+
+#define cCONFIG_DEF_BRIDGE_ALTERNATE_IP 0
+
+#define cCONFIG_DEF_WAN_ALIAS_IP 0
+
+#define cCONFIG_IEEE1394_FEATURE 0
+
+#define cCONFIG_IEEE1394_OHCI1394_FEATURE 0
+
+#define cCONFIG_IEEE1394_ETH1394_FEATURE 0
+
+#define cCONFIG_IEEE1394_SBP2_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:109 */
+#define cCONFIG_INET_FEATURE 1
+#define CONFIG_INET_FEATURE 1
+#define CONFIG_INET 1
+
+#define cCONFIG_INIT_BASIC_RUNLEVELS 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:612 */
+#define CONFIG_IP_ADVANCED_ROUTER 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:110 */
+#define cCONFIG_IP_MULTICAST 1
+#define CONFIG_IP_MULTICAST 1
+
+#define cCONFIG_IPSEC 0
+
+#define cCONFIG_IPSEC_ALG_MD5_FEATURE 0
+
+#define cCONFIG_IPSEC_ALG_SHA1_FEATURE 0
+
+#define cCONFIG_IPSEC_ALG_3DES_FEATURE 0
+
+#define cCONFIG_IPSEC_ALG_1DES_FEATURE 0
+
+#define cCONFIG_IPSEC_ALG_NULL_FEATURE 0
+
+#define cCONFIG_IPSEC_ENC_AES 0
+
+#define cCONFIG_IPSEC_ALG_AES_FEATURE 0
+
+#define cCONFIG_IPSEC_DRIVER_FEATURE 0
+
+#define cCONFIG_IXP_CS8900_FEATURE 0
+
+#define cCONFIG_ARCH_IXP425 0
+
+#define cCONFIG_IXP425_CODELET_DSP_ENG_FEATURE 0
+
+#define cCONFIG_IXP425_CODELET_ATM_FEATURE 0
+
+#define cCONFIG_IXP425_CODELET_ETH_FEATURE 0
+
+#define cCONFIG_IXP425_CODELET_HSS_FEATURE 0
+
+#define cCONFIG_IXP425_CODELET_USB_FEATURE 0
+
+#define cCONFIG_IXP425_CODELET_DMA_FEATURE 0
+
+#define cCONFIG_IXP425_CODELET_CRYPTO_FEATURE 0
+
+#define cCONFIG_IXP425_CODELET_PERF_PROF_FEATURE 0
+
+#define cCONFIG_IXP425_CODELET_TIMERS_FEATURE 0
+
+#define cCONFIG_IXP425_CODELETS_FEATURE 0
+
+#define cCONFIG_IXP425_COMMON 0
+
+#define cCONFIG_IXP425_CSR_FEATURE 0
+
+#define cCONFIG_IXP425_DSR_FEATURE 0
+
+#define cCONFIG_IXP425_ETH_FEATURE 0
+
+#define cCONFIG_IXP425_ATM_FEATURE 0
+
+#define cCONFIG_IXP425_FLASH_E28F128J3_FEATURE 0
+
+#define cCONFIG_IXP425_FLASH_E28F640J3_FEATURE 0
+
+#define cCONFIG_IXP425_FLASH_E28F320J3_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1837 */
+#define cCONFIG_JFFS2_FS_FEATURE 1
+#define CONFIG_JFFS2_FS_FEATURE 1
+#define CONFIG_JFFS2_FS 1
+
+#define cCONFIG_LINUX_OAM_FEATURE 0
+
+#define cCONFIG_LOCKD_FEATURE 0
+
+#define cCONFIG_I2C_FEATURE 0
+
+#define cCONFIG_I2C_ALGOBIT_FEATURE 0
+
+#define cCONFIG_I2C_IXP425_FEATURE 0
+
+#define cCONFIG_I2C_DS1374_FEATURE 0
+
+#define cCONFIG_I2C_LM81_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2763 */
+#define CONFIG_LOG_FILES_MAX_SIZE 16384
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2762 */
+#define CONFIG_LOG_FILES_MIN_SIZE 12288
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_host.c:1371 */
+#define cCONFIG_MIPS 1
+#define CONFIG_MIPS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1175 */
+#define CONFIG_MIPS_PATENTFREE 1
+
+#define cCONFIG_RG_INSMOD_SILENT 0
+
+#define cCONFIG_INCAIP 0
+
+#define cCONFIG_INCAIP_KEYPAD_FEATURE 0
+
+#define cCONFIG_INCAIP_LEDMATRIX_FEATURE 0
+
+#define cCONFIG_INCAIP_DSP_FEATURE 0
+
+#define cCONFIG_VINETIC_FEATURE 0
+
+#define cCONFIG_INCAIP_IOM2_FEATURE 0
+
+#define cCONFIG_INCAIP_ETHERNET_FEATURE 0
+
+#define cCONFIG_INCAIP_PSEUDO_LAN_FEATURE 0
+
+#define cCONFIG_INCAIPSSC_FEATURE 0
+
+#define cCONFIG_INCAIPPWM_FEATURE 0
+
+#define cCONFIG_SERIAL_INCAIPASC_FEATURE 0
+
+#define cCONFIG_MTD_INCAIP_FEATURE 0
+
+#define cCONFIG_ZSP400_FEATURE 0
+
+#define cCONFIG_INCAIP_SWITCH_FEATURE 0
+
+#define cCONFIG_INCAIP_SWITCH_API_FEATURE 0
+
+#define cCONFIG_MPC8272ADS 0
+
+#define cCONFIG_ADM5120_COMMON 0
+
+#define cCONFIG_ADM5120_MTD_FEATURE 0
+
+#define cCONFIG_ADM5120_SWITCH_FEATURE 0
+
+#define cCONFIG_ET_FEATURE 0
+
+#define cCONFIG_BCM947XX 0
+
+#define cCONFIG_BCM947_COMMON 0
+
+#define cCONFIG_BCM963XX 0
+
+#define cCONFIG_BCM963XX_MTD_FEATURE 0
+
+#define cCONFIG_BCM963XX_SERIAL_FEATURE 0
+
+#define cCONFIG_BCM963XX_BOARD_FEATURE 0
+
+#define cCONFIG_BCM963XX_ETH_FEATURE 0
+
+#define cCONFIG_BCM963XX_ATM_FEATURE 0
+
+#define cCONFIG_BCM963XX_ADSL_FEATURE 0
+
+#define cCONFIG_BCM963XX_USB_FEATURE 0
+
+#define cCONFIG_BCM963XX_WLAN_FEATURE 0
+
+#define cCONFIG_BCM963XX_ENDPOINT_FEATURE 0
+
+#define cCONFIG_BCM963XX_PROCFS_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1097 */
+#define cCONFIG_CPU_LX4189 1
+#define CONFIG_CPU_LX4189 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1161 */
+#define cCONFIG_ADI_6843 1
+#define CONFIG_ADI_6843 1
+
+#define cCONFIG_ETH_NETPRO_SIERRA_FEATURE 0
+
+#define cCONFIG_ADI_6843_USB_FEATURE 0
+
+#define cCONFIG_ADI_6843_MTD_FEATURE 0
+
+#define cCONFIG_ADI_6843_UART2_FEATURE 0
+
+#define cCONFIG_DSPDRIVER_218X_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1631 */
+#define CONFIG_MACH_ADI_FUSIV 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1843 */
+#define cCONFIG_FUSIV_LIBRARY 1
+#define CONFIG_FUSIV_LIBRARY 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1844 */
+#define cCONFIG_FUSIV_BMDRIVER 1
+#define CONFIG_FUSIV_BMDRIVER 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1845 */
+#define cCONFIG_FUSIV_TIMERS 1
+#define CONFIG_FUSIV_TIMERS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1506 */
+#define cCONFIG_FUSIV_KERNEL_ETHERNET 1
+#define CONFIG_FUSIV_KERNEL_ETHERNET 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1633 */
+#define cCONFIG_FUSIV_KERNEL_ATM 1
+#define CONFIG_FUSIV_KERNEL_ATM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1808 */
+#define cCONFIG_FUSIV_KERNEL_UART2 1
+#define CONFIG_FUSIV_KERNEL_UART2 1
+
+#define cCONFIG_FUSIV_VX200 0
+
+#define cCONFIG_FUSIV_VX160 0
+
+#define cCONFIG_FUSIV_AT300 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3324 */
+#define cCONFIG_FUSIV_REUSE_SKBS 1
+#define CONFIG_FUSIV_REUSE_SKBS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1776 */
+#define cCONFIG_FUSIV_KERNEL_PERI_AP 1
+#define CONFIG_FUSIV_KERNEL_PERI_AP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1484 */
+#define cNUM_PHYS 2
+#define NUM_PHYS 2
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1632 */
+#define cCONFIG_ARCH_AD6834_FAST3202 1
+#define CONFIG_ARCH_AD6834_FAST3202 1
+
+#define cCONFIG_SW_80211G_AR500XX 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:17 */
+#define cCONFIG_SW_80211N_AR500XX 1
+#define CONFIG_SW_80211N_AR500XX 1
+
+#define cCONFIG_LIVEBOX1 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3227 */
+#define cCONFIG_LIVEBOX 1
+#define CONFIG_LIVEBOX 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1682 */
+#define cCONFIG_LIVEBOX_SAGEM_SWITCH_FEATURE 1
+#define CONFIG_LIVEBOX_SAGEM_SWITCH_FEATURE 1
+#define CONFIG_LIVEBOX_SAGEM_SWITCH_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:109 */
+#define cCONFIG_LIVEBOX_TV 1
+#define CONFIG_LIVEBOX_TV 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:82 */
+#define cCONFIG_LIVEBOX_MULTICAST_ROUTING 1
+#define CONFIG_LIVEBOX_MULTICAST_ROUTING 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:83 */
+#define cCONFIG_LIVEBOX_MLTV_ROUTED 1
+#define CONFIG_LIVEBOX_MLTV_ROUTED 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:84 */
+#define CONFIG_LIVEBOX_MLTV_FTTH_ROUTED 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:76 */
+#define CONFIG_LIVEBOX_MLTV_ADSL_ROUTED 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:77 */
+#define CONFIG_LIVEBOX_MLTV_BRIDGED 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:78 */
+#define CONFIG_LIVEBOX_MLTV_ADSL_BRIDGED 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:80 */
+#define cCONFIG_SAGEM_MULTI_STB 1
+#define CONFIG_SAGEM_MULTI_STB 1
+
+#define cCONFIG_SAGEM_FTTH_MULTI_STB 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:81 */
+#define cCONFIG_SAGEM_ADSL_MULTI_STB 1
+#define CONFIG_SAGEM_ADSL_MULTI_STB 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:85 */
+#define cCONFIG_FTTH_ROUTED_DEFAULT 1
+#define CONFIG_FTTH_ROUTED_DEFAULT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:79 */
+#define cCONFIG_ADSL_ROUTED_DEFAULT 1
+#define CONFIG_ADSL_ROUTED_DEFAULT 1
+
+#define cCONFIG_LIVEBOX_VISIO 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:110 */
+#define cCONFIG_LIVEBOX_LIVEZOOM 1
+#define CONFIG_LIVEBOX_LIVEZOOM 1
+
+#define cCONFIG_LIVEBOX_PHOTOBLOG 0
+
+#define cCONFIG_LIVEBOX_TRACEABILITY 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3248 */
+#define cCONFIG_LIVEBOX_VOIP 1
+#define CONFIG_LIVEBOX_VOIP 1
+
+#define cCONFIG_SAGEM_VOIP_PPP 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:14 */
+#define cCONFIG_SAGEM_VOIP_VCCONV 1
+#define CONFIG_SAGEM_VOIP_VCCONV 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3308 */
+#define cCONFIG_LIVEBOX_TELNET_LOGIN_FAILURE_DELAY 1
+#define CONFIG_LIVEBOX_TELNET_LOGIN_FAILURE_DELAY 1
+
+#define cCONFIG_LIVEBOX_SERIAL_LOGIN_FAILURE_DELAY 0
+
+#define cCONFIG_LIVEBOX_PAIRING 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2884 */
+#define CONFIG_LBV2_PAIRING 1
+
+#define cCONFIG_LIVEBOX_MIGRATION 0
+
+#define cCONFIG_LIVEBOX_LIB_MIGRATION 0
+
+#define cCONFIG_LIVEBOX_MRA_WBM 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3281 */
+#define cCONFIG_RG_PERMST_ACCESS 1
+#define CONFIG_RG_PERMST_ACCESS 1
+
+#define cCONFIG_LIVEBOX_WIFIC_NTFY 0
+
+#define cCONFIG_LIVEBOX_VER_MRA_FR 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:112 */
+#define cCONFIG_LIVEBOX_VER_APP2_FR 1
+#define CONFIG_LIVEBOX_VER_APP2_FR 1
+
+#define cCONFIG_LIVEBOX_VER_MRA_OCH 0
+
+#define cCONFIG_LIVEBOX_VER_APP2_OCH 0
+
+#define cCONFIG_LIVEBOX_VER_APP2_OCH_V2 0
+
+#define cCONFIG_LIVEBOX_VER_MRA_NL 0
+
+#define cCONFIG_LIVEBOX_VER_APP2_NL 0
+
+#define cCONFIG_LIVEBOX_VER_MRA_POL 0
+
+#define cCONFIG_LIVEBOX_VER_APP2_POL 0
+
+#define cCONFIG_LIVEBOX_VER_MRA_SP 0
+
+#define cCONFIG_LIVEBOX_VER_APP2_SP 0
+
+#define cCONFIG_LIVEBOX_VER_MRA_BE 0
+
+#define cCONFIG_LIVEBOX_VER_APP2_BE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:49 */
+#define cCONFIG_LIVEBOX_MEDIA_SERVER 1
+#define CONFIG_LIVEBOX_MEDIA_SERVER 1
+
+#define cCONFIG_LIVEBOX_MEDIA_SERVER_VIP 0
+
+#define cCONFIG_LIVEBOX_TWONKY_WBM 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3127 */
+#define cCONFIG_LIVEBOX_ORANGE_TV_DHCP 1
+#define CONFIG_LIVEBOX_ORANGE_TV_DHCP 1
+
+#define cCONFIG_KS8695_FLASH_AM29LV033C_FEATURE 0
+
+#define cCONFIG_KSFLASH_FEATURE 0
+
+#define cCONFIG_CX8620X_COMMON 0
+
+#define cCONFIG_CX8620X_FLASH_TE28F160C3_FEATURE 0
+
+#define cCONFIG_CX8620X_FLASH_TE28F320C3_FEATURE 0
+
+#define cCONFIG_CX8620X_FLASH_TE28F640C3_FEATURE 0
+
+#define cCONFIG_CX8620X_SWITCH_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2857 */
+#define cCONFIG_HOTPLUG 1
+#define CONFIG_HOTPLUG 1
+
+#define cCONFIG_MTD_BCM947XX_FEATURE 0
+
+#define cCONFIG_MTD_XG1000_FEATURE 0
+
+#define cCONFIG_IL_FEATURE 0
+
+#define cCONFIG_IL_47XX_FEATURE 0
+
+#define cCONFIG_WL_FEATURE 0
+
+#define cCONFIG_HERMES_FEATURE 0
+
+#define cCONFIG_PCMCIA_HERMES_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:81 */
+#define CONFIG_RAMFS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:99 */
+#define CONFIG_MODULES 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:88 */
+#define cCONFIG_SYSFS 1
+#define CONFIG_SYSFS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1119 */
+#define CONFIG_MTD 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2251 */
+#define CONFIG_MTD_BLOCK 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2252 */
+#define CONFIG_MTD_CFI 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2253 */
+#define CONFIG_MTD_GEN_PROBE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2250 */
+#define CONFIG_MTD_PARTITIONS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1124 */
+#define CONFIG_MTD_MAP_BANK_WIDTH_1 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1125 */
+#define CONFIG_MTD_MAP_BANK_WIDTH_2 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1126 */
+#define CONFIG_MTD_MAP_BANK_WIDTH_4 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1127 */
+#define CONFIG_MTD_CFI_I1 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1128 */
+#define CONFIG_MTD_CFI_I2 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1120 */
+#define CONFIG_MTD_CFI_AMDSTD 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1129 */
+#define CONFIG_MTD_CFI_UTIL 1
+
+#define cCONFIG_NATSEMI_FEATURE 0
+
+#define cCONFIG_NE2000_FEATURE 0
+
+#define cCONFIG_NE2K_PCI_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:105 */
+#define CONFIG_NET 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:106 */
+#define CONFIG_NETDEVICES 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:113 */
+#define CONFIG_NET_ETHERNET 1
+
+#define cCONFIG_NETLINK_DEV_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:132 */
+#define CONFIG_NET_RADIO 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:133 */
+#define cCONFIG_NET_WIRELESS 1
+#define CONFIG_NET_WIRELESS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:284 */
+#define CONFIG_OPENRG 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:107 */
+#define CONFIG_PACKET 1
+
+#define cCONFIG_PCF8594C2_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1155 */
+#define CONFIG_PCI 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1156 */
+#define CONFIG_PCI_AUTO 1
+
+#define cCONFIG_PCMCIA_DEVELOPMENT 0
+
+#define cCONFIG_PCNET32_FEATURE 0
+
+#define cCONFIG_RG_PPTPS 0
+
+#define cCONFIG_PPC 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:384 */
+#define cCONFIG_RG_PPP 1
+#define cCONFIG_RG_PPP_FEATURE 1
+#define CONFIG_RG_PPP_FEATURE 1
+#define CONFIG_RG_PPP_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:390 */
+#define cCONFIG_RG_PPP_BSDCOMP 1
+#define CONFIG_RG_PPP_BSDCOMP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:389 */
+#define cCONFIG_RG_PPP_DEFLATE 1
+#define CONFIG_RG_PPP_DEFLATE 1
+
+#define cCONFIG_RG_PPP_ON_DEMAND_AS_DEFAULT 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:396 */
+#define cCONFIG_RG_PPP_ON_DEMAND_DEFAULT_MAX_IDLE_TIME 1200
+#define CONFIG_RG_PPP_ON_DEMAND_DEFAULT_MAX_IDLE_TIME 1200
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:405 */
+#define cCONFIG_RG_PPP_DEFAULT_BSD_COMPRESSION 1
+#define CONFIG_RG_PPP_DEFAULT_BSD_COMPRESSION 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:414 */
+#define cCONFIG_RG_PPP_DEFAULT_DEFLATE_COMPRESSION 1
+#define CONFIG_RG_PPP_DEFAULT_DEFLATE_COMPRESSION 1
+
+#define cCONFIG_RG_PPP_MPPE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:432 */
+#define cCONFIG_RG_PPPOA_FEATURE 1
+#define CONFIG_RG_PPPOA_FEATURE 1
+#define CONFIG_RG_PPPOA_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:385 */
+#define cCONFIG_RG_PPPOE 1
+#define CONFIG_RG_PPPOE 1
+
+#define cCONFIG_RG_PPPOES 0
+
+#define cCONFIG_RG_PPPOS_CLI 0
+
+#define cCONFIG_RG_HSS 0
+
+#define cCONFIG_RG_IPV6 0
+
+#define cCONFIG_RG_PPTP 0
+
+#define cCONFIG_RG_PPTPC 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3219 */
+#define cCONFIG_RG_L2TPC 1
+#define CONFIG_RG_L2TPC 1
+
+#define cCONFIG_PRISM2_PCI_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:84 */
+#define CONFIG_PROC_FS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1232 */
+#define CONFIG_IKCONFIG 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1233 */
+#define CONFIG_IKCONFIG_PROC 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:229 */
+#define CONFIG_RG_ALG 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:238 */
+#define CONFIG_RG_ALG_ICMP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:239 */
+#define cCONFIG_RG_ALG_PORT_TRIGGER 1
+#define CONFIG_RG_ALG_PORT_TRIGGER 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:240 */
+#define cCONFIG_RG_ALG_FTP 1
+#define CONFIG_RG_ALG_FTP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:241 */
+#define cCONFIG_RG_ALG_RTSP 1
+#define CONFIG_RG_ALG_RTSP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:232 */
+#define cCONFIG_RG_ALG_H323 1
+#define CONFIG_RG_ALG_H323 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2392 */
+#define cCONFIG_RG_ALG_SIP 1
+#define CONFIG_RG_ALG_SIP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:231 */
+#define cCONFIG_RG_ALG_MGCP 1
+#define CONFIG_RG_ALG_MGCP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:235 */
+#define cCONFIG_RG_ALG_PPTP 1
+#define CONFIG_RG_ALG_PPTP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:234 */
+#define cCONFIG_RG_ALG_MSNMS 1
+#define CONFIG_RG_ALG_MSNMS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:236 */
+#define cCONFIG_RG_ALG_IPSEC 1
+#define CONFIG_RG_ALG_IPSEC 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:237 */
+#define cCONFIG_RG_ALG_L2TP 1
+#define CONFIG_RG_ALG_L2TP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:233 */
+#define cCONFIG_RG_ALG_AIM 1
+#define CONFIG_RG_ALG_AIM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:277 */
+#define cCONFIG_RG_ALG_DNS 1
+#define CONFIG_RG_ALG_DNS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:278 */
+#define cCONFIG_RG_ALG_DHCP 1
+#define CONFIG_RG_ALG_DHCP 1
+
+#define cCONFIG_RG_ALG_USERSPACE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:242 */
+#define cCONFIG_SAGEM_ALG_SNMP 1
+#define CONFIG_SAGEM_ALG_SNMP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3284 */
+#define cCONFIG_RG_ADI_FASTPATH_BRIDGE 1
+#define cCONFIG_RG_ADI_FASTPATH_BRIDGE_FEATURE 1
+#define CONFIG_RG_ADI_FASTPATH_BRIDGE_FEATURE 1
+#define CONFIG_RG_ADI_FASTPATH_BRIDGE_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:223 */
+#define cCONFIG_RG_BRIDGE 1
+#define cCONFIG_RG_BRIDGE_FEATURE 1
+#define CONFIG_RG_BRIDGE_FEATURE 1
+#define CONFIG_RG_BRIDGE_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:442 */
+#define cCONFIG_RG_VLAN_BRIDGE 1
+#define CONFIG_RG_VLAN_BRIDGE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:444 */
+#define cCONFIG_RG_8021Q_IF 1
+#define CONFIG_RG_8021Q_IF 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3287 */
+#define cCONFIG_RG_FASTPATH 1
+#define cCONFIG_RG_FASTPATH_FEATURE 1
+#define CONFIG_RG_FASTPATH_FEATURE 1
+#define CONFIG_RG_FASTPATH_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3289 */
+#define CONFIG_RG_FASTPATH_PLAT_PATH vendor/adi/ad6843/rg_modules
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3290 */
+#define cCONFIG_RG_FASTPATH_PLAT_AD6834 1
+#define CONFIG_RG_FASTPATH_PLAT_AD6834 1
+
+#define cCONFIG_RG_CABLEHOME 0
+
+#define cCONFIG_RG_CABLEHOME_10 0
+
+#define cCONFIG_RG_CABLEHOME_11 0
+
+#define cCONFIG_RG_CABLEHOME_EMBEDDED 0
+
+#define cCONFIG_RG_CABLEHOME_FULL_WBM 0
+
+#define cCONFIG_RG_DSL_CH 0
+
+#define cCONFIG_RG_CH_FW 0
+
+#define cCONFIG_RG_CH_EVT_RPT 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:331 */
+#define CONFIG_RG_CHRDEV 1
+
+#define cCONFIG_RG_CHWAN_FEATURE 0
+
+#define cCONFIG_RG_USFS_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3210 */
+#define cCONFIG_RG_PPPOE_RELAY 1
+#define cCONFIG_RG_PPPOE_RELAY_FEATURE 1
+#define CONFIG_RG_PPPOE_RELAY_FEATURE 1
+#define CONFIG_RG_PPPOE_RELAY_MODULE 1
+
+#define cCONFIG_RG_BROUTE_FEATURE 0
+
+#define cCONFIG_RG_ELVIS 0
+
+#define cCONFIG_RG_DSLHOME 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:174 */
+#define cCONFIG_RG_FIREWALL 1
+#define CONFIG_RG_FIREWALL 1
+
+#define cCONFIG_RG_FW_ICSA 0
+
+#define cCONFIG_RG_GDBSERVER 0
+
+#define cCONFIG_RG_ADV_SERVICES 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1145 */
+#define CONFIG_RG_IGD 1
+
+#define cCONFIG_RG_IGD_XBOX 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:116 */
+#define cCONFIG_RG_IGMP_PROXY 1
+#define cCONFIG_RG_IGMP_PROXY_FEATURE 1
+#define CONFIG_RG_IGMP_PROXY_FEATURE 1
+#define CONFIG_RG_IGMP_PROXY_MODULE 1
+
+#define cCONFIG_RG_MCAST_RELAY 0
+#define cCONFIG_RG_MCAST_RELAY_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2413 */
+#define cCONFIG_RG_JFW_FEATURE 1
+#define CONFIG_RG_JFW_FEATURE 1
+#define CONFIG_RG_JFW_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:248 */
+#define cCONFIG_RG_MSS 1
+#define cCONFIG_RG_MSS_FEATURE 1
+#define CONFIG_RG_MSS_FEATURE 1
+#define CONFIG_RG_MSS_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:245 */
+#define cCONFIG_RG_FUWR 1
+#define cCONFIG_RG_FUWR_FEATURE 1
+#define CONFIG_RG_FUWR_FEATURE 1
+#define CONFIG_RG_FUWR_MODULE 1
+
+#define cCONFIG_RG_LAN_UPGRADE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:65 */
+#define CONFIG_RG_OS_LINUX 1
+
+#define cCONFIG_RG_OS_VXWORKS 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:226 */
+#define cCONFIG_RG_NAT 1
+#define CONFIG_RG_NAT 1
+
+#define cCONFIG_RG_NETKIT 0
+
+#define cCONFIG_RG_NETTOOLS_ARP 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2356 */
+#define CONFIG_RG_OPENSSL 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2359 */
+#define cCONFIG_RG_CRYPTO 1
+#define CONFIG_RG_CRYPTO 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:361 */
+#define cCONFIG_RG_SSL 1
+#define CONFIG_RG_SSL 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2951 */
+#define cCONFIG_RG_PERM_STORAGE 1
+#define CONFIG_RG_PERM_STORAGE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3241 */
+#define cCONFIG_RG_PERM_STORAGE_VENDOR_HEADER 1
+#define CONFIG_RG_PERM_STORAGE_VENDOR_HEADER 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:294 */
+#define cCONFIG_RG_KOS 1
+#define cCONFIG_RG_KOS_FEATURE 1
+#define CONFIG_RG_KOS_FEATURE 1
+#define CONFIG_RG_KOS_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:418 */
+#define cCONFIG_RG_KOS_KNET 1
+#define CONFIG_RG_KOS_KNET 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:89 */
+#define cCONFIG_RG_IPV4_FEATURE 1
+#define CONFIG_RG_IPV4_FEATURE 1
+#define CONFIG_RG_IPV4_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:161 */
+#define cCONFIG_RG_RIP 1
+#define CONFIG_RG_RIP 1
+
+#define cCONFIG_RG_RMT_UPDATE 0
+
+#define cCONFIG_RG_RMT_UPGRADE_IMG_IN_MEM 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:173 */
+#define cCONFIG_RG_RNAT 1
+#define CONFIG_RG_RNAT 1
+
+#define cCONFIG_BIDIR_NAT 0
+
+#define cCONFIG_RG_RNDIS_FEATURE 0
+
+#define cCONFIG_RG_STANDALONE_PS 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:326 */
+#define CONFIG_RG_SYSINIT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2769 */
+#define cCONFIG_RG_SYSLOG_REMOTE 1
+#define CONFIG_RG_SYSLOG_REMOTE 1
+
+#define cCONFIG_RG_TFTP_SERVER 0
+
+#define cCONFIG_RG_TFTP_SERVER_PASSWORD 0
+
+#define cCONFIG_RG_TFTP_UPGRADE 0
+
+#define cCONFIG_RG_UCD_SNMP 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1144 */
+#define cCONFIG_RG_UPNP 1
+#define CONFIG_RG_UPNP 1
+
+#define cCONFIG_RG_USB_SLAVE 0
+#define cCONFIG_RG_USB_SLAVE_FEATURE 0
+
+#define cCONFIG_RG_WAN_UPGRADE 0
+
+#define cCONFIG_RG_WLAN_AUTO_CHANNEL_SELECT 0
+
+#define cCONFIG_RG_RMT_UPD_LOW_MEM 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:305 */
+#define cCONFIG_RG_DNS 1
+#define CONFIG_RG_DNS 1
+
+#define cCONFIG_RG_DNS_CONCURRENT 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:163 */
+#define cCONFIG_DNS_OVERRIDE 1
+#define CONFIG_DNS_OVERRIDE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:169 */
+#define cCONFIG_RG_DNS_ROUTE 1
+#define CONFIG_RG_DNS_ROUTE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:165 */
+#define cCONFIG_RG_DNS_DOMAIN_ROUTING 1
+#define CONFIG_RG_DNS_DOMAIN_ROUTING 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:312 */
+#define cCONFIG_RG_DDNS 1
+#define CONFIG_RG_DDNS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:364 */
+#define cCONFIG_RG_ENTFY 1
+#define CONFIG_RG_ENTFY 1
+
+#define cCONFIG_RG_HTTP_PROXY 0
+
+#define cCONFIG_RG_MAIL_FILTER 0
+
+#define cCONFIG_RG_URL_KEYWORD_FILTER 0
+
+#define cCONFIG_RG_SURFCONTROL 0
+
+#define cCONFIG_RG_8021X 0
+
+#define cCONFIG_RG_8021X_MD5 0
+
+#define cCONFIG_RG_8021X_TTLS 0
+
+#define cCONFIG_RG_8021X_PKTFIL_FEATURE 0
+
+#define cCONFIG_RG_8021X_TLS 0
+
+#define cCONFIG_RG_8021X_RADIUS 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:139 */
+#define cCONFIG_RG_8021X_WBM 1
+#define CONFIG_RG_8021X_WBM 1
+
+#define cCONFIG_RG_RADIUS 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:136 */
+#define CONFIG_RG_VENDOR_WLAN_SEC 1
+
+#define cCONFIG_RG_RADIUS_WBM 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2998 */
+#define cCONFIG_RG_AUTH 1
+#define CONFIG_RG_AUTH 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:193 */
+#define CONFIG_RG_SSID_NAME "openrg"
+
+#define cCONFIG_RG_RADIUS_IN_CONN 0
+
+#define cCONFIG_RG_RADIUS_LOGIN_AUTH 0
+
+#define cCONFIG_RG_WPA 0
+
+#define cCONFIG_RG_WPA_BCM 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:138 */
+#define cCONFIG_SAGEM_WPA 1
+#define CONFIG_SAGEM_WPA 1
+
+#define cCONFIG_SAGEM_WPA_RALINK 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:137 */
+#define cCONFIG_RG_WPA_WBM 1
+#define CONFIG_RG_WPA_WBM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:213 */
+#define cCONFIG_RG_DHCPS 1
+#define CONFIG_RG_DHCPS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:315 */
+#define cCONFIG_RG_DHCPC 1
+#define CONFIG_RG_DHCPC 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:217 */
+#define cCONFIG_RG_DHCPR 1
+#define CONFIG_RG_DHCPR 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2320 */
+#define cCONFIG_RG_DHCP_PKTFIL_FEATURE 1
+#define CONFIG_RG_DHCP_PKTFIL_FEATURE 1
+#define CONFIG_RG_DHCP_PKTFIL_MODULE 1
+
+#define cCONFIG_RG_PKTCBL_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1409 */
+#define cCONFIG_RG_SSI 1
+#define CONFIG_RG_SSI 1
+
+#define cCONFIG_RG_SSI_PAGES 0
+
+#define cCONFIG_RG_WBM 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:105 */
+#define cCONFIG_RG_GUI 1
+#define CONFIG_RG_GUI 1
+
+#define cCONFIG_RG_TCPDUMP 0
+
+#define cCONFIG_FREESWAN_COMMON 0
+
+#define cCONFIG_RG_ACL 0
+
+#define cCONFIG_RG_ATTR 0
+
+#define cCONFIG_RG_BACKUP 0
+
+#define cCONFIG_RG_BOOTLDR 0
+
+#define cCONFIG_RG_CABLEHOME_COMMON 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3022 */
+#define cCONFIG_RG_DHCP_COMMON 1
+#define CONFIG_RG_DHCP_COMMON 1
+
+#define cCONFIG_RG_SAMPLES_COMMON 0
+
+#define cCONFIG_RG_DOSFSTOOLS  0
+
+#define cCONFIG_RG_E2FSPROGS 0
+
+#define cCONFIG_RG_FLEX 0
+
+#define cCONFIG_RG_LIBPCAP 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3012 */
+#define cCONFIG_RG_LZMA 1
+#define CONFIG_RG_LZMA 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3005 */
+#define cCONFIG_RG_MGT 1
+#define CONFIG_RG_MGT 1
+
+#define cCONFIG_RG_OPENSSL_COMMON 0
+
+#define cCONFIG_RG_READLINE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3027 */
+#define cCONFIG_RG_RGLOADER_COMMON 1
+#define CONFIG_RG_RGLOADER_COMMON 1
+
+#define cCONFIG_RG_STAR 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3053 */
+#define cCONFIG_RG_SYSLOG_COMMON 1
+#define CONFIG_RG_SYSLOG_COMMON 1
+
+#define cCONFIG_RG_TERMCAP 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3040 */
+#define cCONFIG_RG_TEST_TOOLS 1
+#define CONFIG_RG_TEST_TOOLS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3004 */
+#define cCONFIG_RG_TZ 1
+#define CONFIG_RG_TZ 1
+
+#define cCONFIG_RG_USAGI 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3035 */
+#define cCONFIG_RG_UTIL_LINUX 1
+#define CONFIG_RG_UTIL_LINUX 1
+
+#define cCONFIG_GUI_RG 0
+
+#define cCONFIG_GUI_BELKIN 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3237 */
+#define cCONFIG_GUI_LIVEBOX1 1
+#define CONFIG_GUI_LIVEBOX1 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2383 */
+#define cCONFIG_RG_LIBIMAGE 1
+#define CONFIG_RG_LIBIMAGE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2376 */
+#define cCONFIG_RG_LIBIMAGE_DIM 1
+#define CONFIG_RG_LIBIMAGE_DIM 1
+
+#define cCONFIG_RG_LIBJPEG 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2414 */
+#define cCONFIG_RG_NETOBJ 1
+#define CONFIG_RG_NETOBJ 1
+
+#define cCONFIG_RG_LAN_BRIDGE_CONST 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2402 */
+#define cCONFIG_RG_AUTO_DST 1
+#define CONFIG_RG_AUTO_DST 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:372 */
+#define CONFIG_RG_TZ_COMMON 1
+
+#define cCONFIG_RG_TZ_FULL 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2404 */
+#define CONFIG_RG_TZ_YEARS 5
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2386 */
+#define cCONFIG_RG_HTTPS 1
+#define CONFIG_RG_HTTPS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2389 */
+#define cCONFIG_HTTP_CGI_PROCESS 1
+#define CONFIG_HTTP_CGI_PROCESS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:220 */
+#define cCONFIG_RG_TELNETS 1
+#define CONFIG_RG_TELNETS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2760 */
+#define cCONFIG_RG_SYSLOG 1
+#define CONFIG_RG_SYSLOG 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2761 */
+#define cCONFIG_RG_LOG_DEV_FEATURE 1
+#define CONFIG_RG_LOG_DEV_FEATURE 1
+#define CONFIG_RG_LOG_DEV_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2766 */
+#define CONFIG_RG_KERN_LOG 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2689 */
+#define CONFIG_RG_LOG_DEV_BUF_SIZE 16384
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2690 */
+#define CONFIG_RG_SYSLOG_FW_DEF_SIZE 16384
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2949 */
+#define cCONFIG_RG_CLI 1
+#define CONFIG_RG_CLI 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2956 */
+#define CONFIG_RG_CLI_SERIAL 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:144 */
+#define CONFIG_RG_TTYP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:300 */
+#define CONFIG_RG_LOGIN 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:257 */
+#define cCONFIG_RG_STATIC_ROUTE 1
+#define CONFIG_RG_STATIC_ROUTE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:337 */
+#define cCONFIG_RG_BUSYBOX 1
+#define CONFIG_RG_BUSYBOX 1
+
+#define cCONFIG_RG_NO_BUSYBOX 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:306 */
+#define CONFIG_RG_ERESOLV 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2958 */
+#define cCONFIG_RG_WGET 1
+#define CONFIG_RG_WGET 1
+
+#define cCONFIG_RG_NON_ROUTABLE_LAN_DEVICE_IP 0
+
+#define cCONFIG_RG_FREESWAN 0
+
+#define cCONFIG_RG_X509 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2347 */
+#define cCONFIG_RG_CERT 1
+#define CONFIG_RG_CERT 1
+
+#define cCONFIG_RG_KERBEROS 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2948 */
+#define CONFIG_RGLOADER_CLI 1
+
+#define cCONFIG_RTL8139_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1178 */
+#define CONFIG_RWSEM_GENERIC_SPINLOCK 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1497 */
+#define cCONFIG_SDRAM_SIZE 32
+#define CONFIG_SDRAM_SIZE 32
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1499 */
+#define CONFIG_FLASH_SIZE 8
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1109 */
+#define CONFIG_SERIAL_CORE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1110 */
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1106 */
+#define CONFIG_SERIAL_8250 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1107 */
+#define CONFIG_SERIAL_8250_CONSOLE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1108 */
+#define CONFIG_SERIAL_8250_NR_UARTS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3085 */
+#define CONFIG_SYN_COOKIES 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:79 */
+#define CONFIG_SYSCTL 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2767 */
+#define CONFIG_SYSLOG_UNIXSOCK_SUPPORT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:142 */
+#define CONFIG_SYSVIPC 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2952 */
+#define CONFIG_TEST_TOOLS_PING 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:265 */
+#define CONFIG_TEST_TOOLS_CONN_SPEED 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:309 */
+#define cCONFIG_RG_TODC 1
+#define CONFIG_RG_TODC 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_host.c:388 */
+#define cCONFIG_ULIBC 1
+#define CONFIG_ULIBC 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3074 */
+#define CONFIG_UNIX 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1137 */
+#define cCONFIG_USB_FEATURE 1
+#define CONFIG_USB_FEATURE 1
+#define CONFIG_USB 1
+
+#define cCONFIG_RG_USB_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:41 */
+#define CONFIG_WPS_SUPPORT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:43 */
+#define CONFIG_SUPERVISOR_SAGEM_EZP_WPS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:44 */
+#define CONFIG_SAGEM_TR_MONITORING 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1142 */
+#define cCONFIG_USB_STORAGE_FEATURE 1
+#define CONFIG_USB_STORAGE_FEATURE 1
+#define CONFIG_USB_STORAGE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:65 */
+#define CONFIG_USB_DEVICEFS 1
+
+#define cCONFIG_USB_OHCI_FEATURE 0
+
+#define cCONFIG_USB_UHCI_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1141 */
+#define cCONFIG_USB_EHCI_HCD_FEATURE 1
+#define CONFIG_USB_EHCI_HCD_FEATURE 1
+#define CONFIG_USB_EHCI_HCD_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1140 */
+#define cCONFIG_USB_OHCI_HCD_FEATURE 1
+#define CONFIG_USB_OHCI_HCD_FEATURE 1
+#define CONFIG_USB_OHCI_HCD_MODULE 1
+
+#define cCONFIG_USB_RNDIS_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1138 */
+#define CONFIG_USB_ARCH_HAS_HCD 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1139 */
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+
+#define cCONFIG_USB_GADGET_FEATURE 0
+
+#define cCONFIG_USB_ETH_FEATURE 0
+
+#define cCONFIG_USB_VOX160_FEATURE 0
+
+#define cCONFIG_VALGRIND 0
+
+#define cCONFIG_ZOOM_CM_FEATURE 0
+
+#define cCONFIG_PCBOX 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1172 */
+#define TARGET_ENDIANESS BIG
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1685 */
+#define BOARD F@ST 3202
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1686 */
+#define FIRM Sagem
+
+#define cCONFIG_RG_TELEPHONY 0
+
+#define cCONFIG_RG_VOATM 0
+
+#define cCONFIG_RG_VOATM_ELCP_FEATURE 0
+
+#define cCONFIG_RG_VOATM_CAS_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3083 */
+#define cCONFIG_RG_FACTORY_SETTINGS 1
+#define CONFIG_RG_FACTORY_SETTINGS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2918 */
+#define cCONFIG_RG_HW_BUTTONS_FEATURE 1
+#define CONFIG_RG_HW_BUTTONS_FEATURE 1
+#define CONFIG_RG_HW_BUTTONS_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:650 */
+#define CONFIG_RG_CONSOLE_DEVICE ttyS0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3198 */
+#define CONFIG_FORCE_RECOVERY 1
+
+#define cCONFIG_SAMBA 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:52 */
+#define cCONFIG_SAGEM_SAMBA 1
+#define CONFIG_SAGEM_SAMBA 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:87 */
+#define cCONFIG_SAGEM_IPP_PRINT 1
+#define CONFIG_SAGEM_IPP_PRINT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:11 */
+#define CONFIG_ETH_SWITCH 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2894 */
+#define CONFIG_WAN_LED_BLINKING 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2900 */
+#define CONFIG_SHUTDOWN_BOX 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2893 */
+#define CONFIG_REBOOT_BUTTON 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3089 */
+#define OPENRG_CHRDEV_MAJOR 240
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:3088 */
+#define OPENRG_CHRDEV_NAME "rg_chrdev"
+
+#define cCONFIG_ATHEROS_AR531X_MIPS 0
+
+#define cCONFIG_ARCH_WRT108G 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1778 */
+#define cCONFIG_RG_ATHEROS 1
+#define cCONFIG_RG_ATHEROS_FEATURE 1
+#define CONFIG_RG_ATHEROS_FEATURE 1
+#define CONFIG_RG_ATHEROS_MODULE 1
+
+#define cCONFIG_RG_ATHEROS_HW_AR5212 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_hw_config.c:5 */
+#define cCONFIG_RG_ATHEROS_HW_AR5416 1
+#define CONFIG_RG_ATHEROS_HW_AR5416 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:159 */
+#define cCONFIG_RG_DEV_IF_WIFI 1
+#define CONFIG_RG_DEV_IF_WIFI 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:162 */
+#define CONFIG_RG_DEV_IF_AR5416_VAP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:169 */
+#define CONFIG_RG_DEV_IF_AR5416_VAP_SLAVE 1
+
+#define cCONFIG_RG_DEV_IF_RT2880 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:141 */
+#define cCONFIG_RG_HOSTAPD 1
+#define CONFIG_RG_HOSTAPD 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:143 */
+#define cCONFIG_HOSTAPD_RSN_PREAUTH 1
+#define CONFIG_HOSTAPD_RSN_PREAUTH 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:142 */
+#define cCONFIG_HOSTAPD_DRIVER_MADWIFI 1
+#define CONFIG_HOSTAPD_DRIVER_MADWIFI 1
+
+#define cCONFIG_TI_404_MIPS 0
+
+#define cCONFIG_TI_404_COMMON 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2315 */
+#define CONFIG_GCC_CAN_INLINE 1
+
+#define cCONFIG_I386 0
+
+#define cCONFIG_UM 0
+
+#define cCONFIG_RG_FILESERVER 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2813 */
+#define CONFIG_RG_STORAGE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2873 */
+#define CONFIG_RG_STORAGE_UTILS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2540 */
+#define CONFIG_RG_LARGE_FILE_SUPPORT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2870 */
+#define CONFIG_RG_CODEPAGE "437"
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2863 */
+#define CONFIG_MSDOS_PARTITION 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2861 */
+#define CONFIG_FAT_FS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2866 */
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2862 */
+#define CONFIG_MSDOS_FS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2864 */
+#define CONFIG_VFAT_FS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2906 */
+#define CONFIG_NLS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2867 */
+#define cCONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2911 */
+#define CONFIG_NLS_DEFAULT "437"
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2907 */
+#define CONFIG_NLS_CODEPAGE_437 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2908 */
+#define CONFIG_NLS_CODEPAGE_850 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2909 */
+#define CONFIG_NLS_ISO8859_1 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2910 */
+#define CONFIG_NLS_UTF8 1
+
+#define cCONFIG_RG_FILESERVER_ACLS 0
+
+#define cCONFIG_RG_FILESERVER_ACLS_DEBUG 0
+
+#define cCONFIG_RG_RAID 0
+
+#define cCONFIG_RG_RAID_IDE_ONLY 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2810 */
+#define CONFIG_SCSI 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2811 */
+#define CONFIG_BLK_DEV_SD 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2812 */
+#define CONFIG_SD_EXTRA_DEVS 32
+
+#define cCONFIG_FLASH 0
+#define cCONFIG_FLASH_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2449 */
+#define CONFIG_VLAN_8021Q 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2446 */
+#define cCONFIG_RG_VLAN_8021Q 1
+#define CONFIG_RG_VLAN_8021Q 1
+
+#define cCONFIG_RG_VLAN_DEBUG_TOOLS 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:70 */
+#define CONFIG_VLAN_8021Q_FAST 1
+
+#define cCONFIG_AT93CXX_FEATURE 0
+
+#define cCONFIG_ADM6996_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:45 */
+#define cCONFIG_RG_OS_LINUX_26 1
+#define CONFIG_RG_OS_LINUX_26 1
+
+#define cCONFIG_RG_OS_LINUX_24 0
+
+#define cCONFIG_RG_OS_LINUX_22 0
+
+#define cCONFIG_RG_EMI 0
+
+#define cCONFIG_RG_EMI_IRDA 0
+
+#define cCONFIG_RG_EMI_USB_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2968 */
+#define CONFIG_RG_DIST_LANG eng
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1190 */
+#define CONFIG_32BIT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1197 */
+#define CONFIG_FLATMEM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1198 */
+#define CONFIG_FLAT_NODE_MEM_MAP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1196 */
+#define CONFIG_SPLIT_PTLOCK_CPUS 4
+
+#define cCONFIG_RG_UML 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2564 */
+#define CONFIG_ZLIB_INFLATE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2397 */
+#define CONFIG_ZLIB_DEFLATE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:117 */
+#define cCONFIG_USB_SERIAL_FEATURE 1
+#define CONFIG_USB_SERIAL_FEATURE 1
+#define CONFIG_USB_SERIAL_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:118 */
+#define cCONFIG_USB_SERIAL_CP2101_FEATURE 1
+#define CONFIG_USB_SERIAL_CP2101_FEATURE 1
+#define CONFIG_USB_SERIAL_CP2101_MODULE 1
+
+#define cCONFIG_USB_SERIAL_OPTION_FEATURE 0
+
+#define cCONFIG_PPP_FEATURE 0
+
+#define cCONFIG_PPP_ASYNC_FEATURE 0
+
+#define cCONFIG_PPP_SYNC_TTY_FEATURE 0
+
+#define cCONFIG_CRC_CCITT_FEATURE 0
+
+#define cCONFIG_RG_PROXY_ARP 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:430 */
+#define cCONFIG_RG_OAM_PING 1
+#define CONFIG_RG_OAM_PING 1
+
+#define cCONFIG_STOP_ON_INIT_FAIL 0
+
+#define cCONFIG_RG_KCALL_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2981 */
+#define cCONFIG_RG_FRAG_CACHE_FEATURE 1
+#define CONFIG_RG_FRAG_CACHE_FEATURE 1
+#define CONFIG_RG_FRAG_CACHE_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2364 */
+#define cCONFIG_RG_XML 1
+#define CONFIG_RG_XML 1
+
+#define cCONFIG_WBM_PAGES_EXPIRE 0
+
+#define cCONFIG_RG_AUTOTEST 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1431 */
+#define CONFIG_RG_FW_NAT_STATE_TABLE_SIZE 3000
+
+#define cCONFIG_RG_TUTORIAL 0
+
+#define cCONFIG_RG_TUTORIAL_ADVANCED 0
+
+#define cCONFIG_RG_WEBCAM 0
+
+#define cCONFIG_ZC_IP_AUTO_DETECTION 0
+
+#define cCONFIG_ZC_AUTO_CONFIG_NON_PNP 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1143 */
+#define CONFIG_USB_PRINTER 1
+
+#define cCONFIG_RG_PRINT_SERVER 0
+
+#define cCONFIG_RG_SAMBA_PRINTING 0
+
+#define cCONFIG_RG_IPP 0
+
+#define cCONFIG_RG_LPD 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:287 */
+#define cCONFIG_RG_LANG 1
+#define CONFIG_RG_LANG 1
+
+#define cCONFIG_RG_DYN_FLASH_LAYOUT 0
+
+#define cCONFIG_RG_DNS_USE_ISP_DOMAIN 0
+
+#define cCONFIG_RG_VOIP 0
+
+#define cCONFIG_RG_IPPHONE 0
+
+#define cCONFIG_RG_ATA 0
+
+#define cCONFIG_RG_VOIP_SIP 0
+
+#define cCONFIG_RG_VOIP_H323 0
+
+#define cCONFIG_RG_VOIP_MGCP 0
+
+#define cCONFIG_RG_VOIP_NUMBER_OF_LINES 0
+
+#define cCONFIG_RG_VOIP_HW_EMULATION 0
+
+#define cCONFIG_RG_VOIP_USE_SIP_ALG 0
+
+#define cCONFIG_RG_VOIP_RV 0
+
+#define cCONFIG_RG_VOIP_RV_SIP 0
+
+#define cCONFIG_RG_VOIP_RV_H323 0
+
+#define cCONFIG_RG_VOIP_RV_MGCP 0
+
+#define cCONFIG_RG_VOIP_OSIP 0
+
+#define cCONFIG_RG_VOIP_ASTERISK 0
+
+#define cCONFIG_RG_RTP 0
+#define cCONFIG_RG_RTP_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_host.c:1163 */
+#define CONFIG_CC_OPTIMIZE_FOR_SIZE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:252 */
+#define cCONFIG_RG_OSS_RMT 1
+#define CONFIG_RG_OSS_RMT 1
+
+#define cCONFIG_HITRON_BSP 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:251 */
+#define cCONFIG_RG_RMT_MNG 1
+#define CONFIG_RG_RMT_MNG 1
+
+#define cCONFIG_SL2312_COMMON 0
+
+#define cCONFIG_SL2312_FLASH_FEATURE 0
+
+#define cCONFIG_USB_OHCI_SL2312_FEATURE 0
+
+#define cCONFIG_SL2312_ETH_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:419 */
+#define CONFIG_RG_EVENT_LOGGING 1
+
+#define cCONFIG_RG_WINS_SERVER 0
+
+#define cCONFIG_RG_FTP_SERVER 0
+
+#define cCONFIG_RG_MAIL_SERVER 0
+
+#define cCONFIG_RG_WEB_SERVER 0
+
+#define cCONFIG_RG_FS_BACKUP 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:573 */
+#define cCONFIG_TOS_DSCP_RFC2474_FEATURE 1
+#define CONFIG_TOS_DSCP_RFC2474_FEATURE 1
+#define CONFIG_TOS_DSCP_RFC2474 1
+
+#define cCONFIG_RG_IPROUTE2 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3257 */
+#define cCONFIG_RG_IPROUTE2_SAGEM 1
+#define CONFIG_RG_IPROUTE2_SAGEM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3243 */
+#define cCONFIG_RG_QOS 1
+#define CONFIG_RG_QOS 1
+
+#define cCONFIG_RG_QOS_MGT 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:626 */
+#define cCONFIG_RG_QOS_INGRESS_FEATURE 1
+#define CONFIG_RG_QOS_INGRESS_FEATURE 1
+#define CONFIG_RG_QOS_INGRESS_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:577 */
+#define cCONFIG_NET_SCHED_FEATURE 1
+#define CONFIG_NET_SCHED_FEATURE 1
+#define CONFIG_NET_SCHED 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:584 */
+#define cCONFIG_NET_SCH_INGRESS_FEATURE 1
+#define CONFIG_NET_SCH_INGRESS_FEATURE 1
+#define CONFIG_NET_SCH_INGRESS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:580 */
+#define cCONFIG_NET_SCH_HTB_FEATURE 1
+#define CONFIG_NET_SCH_HTB_FEATURE 1
+#define CONFIG_NET_SCH_HTB 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:582 */
+#define cCONFIG_NET_SCH_TBF_FEATURE 1
+#define CONFIG_NET_SCH_TBF_FEATURE 1
+#define CONFIG_NET_SCH_TBF 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:620 */
+#define cCONFIG_NET_SCH_ATM_FEATURE 1
+#define CONFIG_NET_SCH_ATM_FEATURE 1
+#define CONFIG_NET_SCH_ATM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:586 */
+#define cCONFIG_NET_SCH_PRIO_FEATURE 1
+#define CONFIG_NET_SCH_PRIO_FEATURE 1
+#define CONFIG_NET_SCH_PRIO 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:588 */
+#define cCONFIG_NET_SCH_RED_FEATURE 1
+#define CONFIG_NET_SCH_RED_FEATURE 1
+#define CONFIG_NET_SCH_RED 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:590 */
+#define cCONFIG_NET_SCH_SFQ_FEATURE 1
+#define CONFIG_NET_SCH_SFQ_FEATURE 1
+#define CONFIG_NET_SCH_SFQ 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:592 */
+#define cCONFIG_NET_SCH_DSMARK_FEATURE 1
+#define CONFIG_NET_SCH_DSMARK_FEATURE 1
+#define CONFIG_NET_SCH_DSMARK 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:594 */
+#define cCONFIG_NET_QOS_FEATURE 1
+#define CONFIG_NET_QOS_FEATURE 1
+#define CONFIG_NET_QOS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:596 */
+#define cCONFIG_NET_ESTIMATOR_FEATURE 1
+#define CONFIG_NET_ESTIMATOR_FEATURE 1
+#define CONFIG_NET_ESTIMATOR 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:598 */
+#define cCONFIG_NET_CLS_FEATURE 1
+#define CONFIG_NET_CLS_FEATURE 1
+#define CONFIG_NET_CLS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:600 */
+#define cCONFIG_NET_CLS_POLICE_FEATURE 1
+#define CONFIG_NET_CLS_POLICE_FEATURE 1
+#define CONFIG_NET_CLS_POLICE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:602 */
+#define cCONFIG_NET_CLS_TCINDEX_FEATURE 1
+#define CONFIG_NET_CLS_TCINDEX_FEATURE 1
+#define CONFIG_NET_CLS_TCINDEX 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:604 */
+#define cCONFIG_NET_CLS_FW_FEATURE 1
+#define CONFIG_NET_CLS_FW_FEATURE 1
+#define CONFIG_NET_CLS_FW 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:606 */
+#define cCONFIG_NET_CLS_U32_FEATURE 1
+#define CONFIG_NET_CLS_U32_FEATURE 1
+#define CONFIG_NET_CLS_U32 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:608 */
+#define cCONFIG_NET_CLS_RSVP_FEATURE 1
+#define CONFIG_NET_CLS_RSVP_FEATURE 1
+#define CONFIG_NET_CLS_RSVP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:610 */
+#define cCONFIG_NET_CLS_RSVP6_FEATURE 1
+#define CONFIG_NET_CLS_RSVP6_FEATURE 1
+#define CONFIG_NET_CLS_RSVP6 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:614 */
+#define cCONFIG_IP_ROUTE_MULTIPATH_FEATURE 1
+#define CONFIG_IP_ROUTE_MULTIPATH_FEATURE 1
+#define CONFIG_IP_ROUTE_MULTIPATH 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:616 */
+#define cCONFIG_IP_ROUTE_VERBOSE_FEATURE 1
+#define CONFIG_IP_ROUTE_VERBOSE_FEATURE 1
+#define CONFIG_IP_ROUTE_VERBOSE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:623 */
+#define cCONFIG_IP_ROUTE_FWMARK_FEATURE 1
+#define CONFIG_IP_ROUTE_FWMARK_FEATURE 1
+#define CONFIG_IP_ROUTE_FWMARK 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:208 */
+#define CONFIG_RG_FOUNDATION_CORE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:181 */
+#define CONFIG_RG_TARGET_LINUX 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_host.c:64 */
+#define CONFIG_RG_HOST_LINUX 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3201 */
+#define MODULE_RG_FOUNDATION 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3204 */
+#define MODULE_RG_ADVANCED_MANAGEMENT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3209 */
+#define MODULE_RG_SNMP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3205 */
+#define MODULE_RG_DSL 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3206 */
+#define MODULE_RG_PPP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3203 */
+#define MODULE_RG_VLAN 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3208 */
+#define MODULE_RG_ZERO_CONFIGURATION 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3202 */
+#define MODULE_RG_ADVANCED_ROUTING 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3207 */
+#define MODULE_RG_FIREWALL_AND_SECURITY 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:119 */
+#define MODULE_RG_WLAN_AND_ADVANCED_WLAN 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:67 */
+#define cCONFIG_HW_ETH_WAN 1
+#define CONFIG_HW_ETH_WAN 1
+
+#define cCONFIG_HW_ETH_WAN_BLOCKED 0
+
+#define cCONFIG_HW_CABLE_WAN 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:68 */
+#define cCONFIG_HW_DSL_WAN 1
+#define CONFIG_HW_DSL_WAN 1
+
+#define cCONFIG_HW_HSS_WAN 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3279 */
+#define cCONFIG_HW_ETH_LAN 1
+#define CONFIG_HW_ETH_LAN 1
+
+#define cCONFIG_HW_80211G_BCM43XX 0
+
+#define cCONFIG_HW_USB_RNDIS 0
+
+#define cCONFIG_HW_USB_HOST_UHCI_FEATURE 0
+
+#define cCONFIG_HW_USB_HOST_EHCI_FEATURE 0
+
+#define cCONFIG_HW_PCMCIA_CARDBUS_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3277 */
+#define cCONFIG_HW_LEDS_FEATURE 1
+#define CONFIG_HW_LEDS_FEATURE 1
+#define CONFIG_HW_LEDS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1807 */
+#define CONFIG_HW_BLUETOOTH 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3276 */
+#define cCONFIG_HW_BUTTONS_FEATURE 1
+#define CONFIG_HW_BUTTONS_FEATURE 1
+#define CONFIG_HW_BUTTONS_MODULE 1
+
+#define cCONFIG_HW_CLOCK 0
+
+#define cCONFIG_HW_IDE 0
+
+#define cCONFIG_HW_I2C 0
+
+#define cCONFIG_HW_ENV_MONITOR 0
+
+#define cCONFIG_HW_ST_20190 0
+
+#define cCONFIG_RG_FLASH_ONLY_ON_BOOT 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:341 */
+#define cCONFIG_RG_MAC_CLONING 1
+#define CONFIG_RG_MAC_CLONING 1
+
+#define cCONFIG_RG_WLAN_REPEATING 0
+
+#define cCONFIG_RG_WDS_CONN_NOTIFIER_FEATURE 0
+
+#define cCONFIG_RG_UNCONFIGURED_WAN_INTERCEPTION 0
+
+#define cCONFIG_RG_STATISTICS_CTRL_WBM 0
+
+#define cCONFIG_RG_WLAN_STA_STATISTICS_WBM 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:210 */
+#define cCONFIG_RG_CHECK_BAD_REBOOTS 1
+#define CONFIG_RG_CHECK_BAD_REBOOTS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:106 */
+#define cCONFIG_RG_BLUETOOTH 1
+#define CONFIG_RG_BLUETOOTH 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:107 */
+#define cCONFIG_RG_BLUETOOTH_DEBUG_TOOLS 1
+#define CONFIG_RG_BLUETOOTH_DEBUG_TOOLS 1
+
+#define cCONFIG_BLUEZ_FEATURE 0
+
+#define cCONFIG_BLUEZ_L2CAP_FEATURE 0
+
+#define cCONFIG_BLUEZ_SCO_FEATURE 0
+
+#define cCONFIG_BLUEZ_RFCOMM_FEATURE 0
+
+#define cCONFIG_BLUEZ_BNEP_FEATURE 0
+
+#define cCONFIG_BLUEZ_HCIUSB_FEATURE 0
+
+#define cCONFIG_BLUEZ_HCIUART_FEATURE 0
+
+#define cCONFIG_BLUEZ_HCIVHCI_FEATURE 0
+
+#define cCONFIG_BLUEZ_HCIBTUART_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2841 */
+#define cCONFIG_BT_FEATURE 1
+#define CONFIG_BT_FEATURE 1
+#define CONFIG_BT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2842 */
+#define cCONFIG_BT_L2CAP_FEATURE 1
+#define CONFIG_BT_L2CAP_FEATURE 1
+#define CONFIG_BT_L2CAP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2844 */
+#define cCONFIG_BT_SCO_FEATURE 1
+#define CONFIG_BT_SCO_FEATURE 1
+#define CONFIG_BT_SCO 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2843 */
+#define cCONFIG_BT_RFCOMM_FEATURE 1
+#define CONFIG_BT_RFCOMM_FEATURE 1
+#define CONFIG_BT_RFCOMM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2846 */
+#define cCONFIG_BT_BNEP_FEATURE 1
+#define CONFIG_BT_BNEP_FEATURE 1
+#define CONFIG_BT_BNEP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2847 */
+#define CONFIG_BT_BNEP_MC_FILTER 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2848 */
+#define CONFIG_BT_BNEP_PROTO_FILTER 1
+
+#define cCONFIG_BT_HCIUSB_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1820 */
+#define cCONFIG_BT_HCIUART_FEATURE 1
+#define CONFIG_BT_HCIUART_FEATURE 1
+#define CONFIG_BT_HCIUART_MODULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1821 */
+#define CONFIG_BT_HCIUART_H4 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1822 */
+#define CONFIG_BT_HCIUART_BCSP 1
+
+#define cCONFIG_BT_HCIVHCI_FEATURE 0
+
+#define cCONFIG_BT_HCIBTUART_FEATURE 0
+
+#define cCONFIG_RG_BLUETOOTH_REQUIRES_MAC 0
+
+#define cCONFIG_RG_BLUETOOTH_PAN 0
+
+#define cCONFIG_RG_OBEX 0
+
+#define cCONFIG_RG_CTP 0
+
+#define cCONFIG_RG_CTP_VOIP_EMULATOR 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3321 */
+#define CONFIG_RG_INITFS_RAMFS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2541 */
+#define CONFIG_RG_MAINFS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3322 */
+#define CONFIG_RG_MAINFS_CRAMFS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2574 */
+#define CONFIG_RG_CRAMFS_COMP_METHOD lzma
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_target_os.c:147 */
+#define CONFIG_RG_KERNEL_COMP_METHOD lzma
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:2668 */
+#define CONFIG_RG_LZMA_COMPRESSED_KERNEL 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:204 */
+#define CONFIG_RG_LICENSE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/config_host.c:389 */
+#define cLIBC_IN_TOOLCHAIN 1
+#define LIBC_IN_TOOLCHAIN 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/hw_config.c:1836 */
+#define cCONFIG_RG_FFS 1
+#define CONFIG_RG_FFS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:48 */
+#define CONFIG_SAGEM_QOS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:42 */
+#define CONFIG_SAGEM_EMBEDDED_BINARIES 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:20 */
+#define CONFIG_SAGEM_AUTOM_LBV1 1
+
+#define cCONFIG_SAGEM_AUTOM_FAKE_FEATURE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:21 */
+#define CONFIG_SAGEM_UMA 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:25 */
+#define CONFIG_SAGEM_TRACEABILITY 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:26 */
+#define CONFIG_SAGEM_FU_SAGEM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:27 */
+#define CONFIG_SAGEM_CPEALIVE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:28 */
+#define CONFIG_SAGEM_PROV 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:29 */
+#define CONFIG_SAGEM_PARAM_REQUEST 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:30 */
+#define CONFIG_SAGEM_PROC_MOD 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3326 */
+#define CONFIG_SAGEM_FLASHINFOS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:37 */
+#define CONFIG_SAGEM_VOICE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:38 */
+#define CONFIG_SAGEM_GEN_VOICE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:46 */
+#define CONFIG_SAGEM_H323 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:47 */
+#define CONFIG_SAGEM_TEST_PHONE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:32 */
+#define CONFIG_SAGEM_RTP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:31 */
+#define CONFIG_SAGEM_RELAY 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3328 */
+#define CONFIG_SAGEM_TIMEZONE_FR 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:111 */
+#define CONFIG_SAGEM_LIVEZOOM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:40 */
+#define cCONFIG_SAGEM_EZPAIRING 1
+#define CONFIG_SAGEM_EZPAIRING 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:39 */
+#define CONFIG_SAGEM_LIBUTILS 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:34 */
+#define CONFIG_SAGEM_USB_HOST 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:35 */
+#define CONFIG_SAGEM_USB_DECT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:36 */
+#define cCONFIG_THOMSON_USB_DECT 1
+#define CONFIG_THOMSON_USB_DECT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3306 */
+#define CONFIG_LIVEBOX_CGISCRIPT 1
+
+#define cCONFIG_SAGEM_WIFICOMMUNITY 0
+
+#define cCONFIG_SAGEM_IPCONF 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:23 */
+#define CONFIG_SAGEM_PHONE_APP 1
+
+#define cCONFIG_SAGEM_SENACF 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:73 */
+#define CONFIG_SAGEM_OPENSSL 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:8 */
+#define CONFIG_SAGEM_LBV2ULT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:7 */
+#define CONFIG_SAGEM_FTTHV2 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:6 */
+#define CONFIG_SAGEM_GENERIC_CARD_SUPPORT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:107 */
+#define cCONFIG_SAGEM_GUI_ADSL_CONFIGURATION 1
+#define CONFIG_SAGEM_GUI_ADSL_CONFIGURATION 1
+
+#define cCONFIG_SAGEM_GUI_SET_PPPO_FROM_INTERNET_ACCESS 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:9 */
+#define CONFIG_SAGEM_GPIO_BOXER_FOR_ULT_FW 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:12 */
+#define CONFIG_SAGEM_FTTH_V2_STEP2 1
+
+#define cCONFIG_SAGEM_GUI_DUMP 0
+
+#define cCONFIG_SAGEM_GUI_CFG_LINE_PVC 0
+
+#define cCONFIG_SAGEM_GUI_CFG_LINE_CLIP 0
+
+#define cCONFIG_SAGEM_GUI_CFG_LINE_ADV_PPPOA 0
+
+#define cCONFIG_SAGEM_GUI_CFG_LINE_ADV_PPPOE 0
+
+#define cCONFIG_SAGEM_GUI_CFG_LINE_ADV_L2TP 0
+
+#define cCONFIG_SAGEM_GUI_CFG_LINE_ADV_CLIP 0
+
+#define cCONFIG_SAGEM_GUI_CFG_LINE_ADV_BRIDGE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:64 */
+#define cCONFIG_SAGEM_DEVICE_DISCOVERY 1
+#define CONFIG_SAGEM_DEVICE_DISCOVERY 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:86 */
+#define cCONFIG_SAGEM_BACKUP_RESTORE 1
+#define CONFIG_SAGEM_BACKUP_RESTORE 1
+
+#define cCONFIG_SAGEM_BACKUP_RESTORE_DEBUG 0
+
+#define cCONFIG_FTTH_DEFAULT 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:72 */
+#define CONFIG_SAGEM_DUAL_AF_REBOOT_ON_CHANGE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:71 */
+#define CONFIG_LIVEBOX_DUAL_ADSL_FTTH 1
+
+#define cCONFIG_LIVEBOX_DUAL_PPPOA_PPPOE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:3126 */
+#define cCONFIG_LIVEBOX_PERM_PARAMS 1
+#define CONFIG_LIVEBOX_PERM_PARAMS 1
+
+#define cCONFIG_SAGEM_GUI_IPSEC 0
+
+#define cCONFIG_SAGEM_GUI_EASY_IPSEC 0
+
+#define cCONFIG_SAGEM_DEVICE_DISCOVERY_COMPANY 0
+
+#define cCONFIG_SAGEM_HDD_LOCAL 0
+
+#define cCONFIG_SAGEM_GUI_FAX 0
+
+#define cCONFIG_SAGEM_GUI_HARDDISK 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:128 */
+#define cCONFIG_SAGEM_GUI_WIFI_ENERGY 1
+#define CONFIG_SAGEM_GUI_WIFI_ENERGY 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:16 */
+#define cCONFIG_LIVEBOX_WIFI 1
+#define CONFIG_LIVEBOX_WIFI 1
+
+#define cWIFI_ATH 0
+
+#define cWIFI_ATH_N 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:15 */
+#define cWIFI_ATH_GN 1
+#define WIFI_ATH_GN 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:18 */
+#define cCONFIG_SAGEM_GUI_WIFI_BG_MIXED 1
+#define CONFIG_SAGEM_GUI_WIFI_BG_MIXED 1
+
+#define cCONFIG_SAGEM_GUI_WIFI_G_ONLY 0
+
+#define cCONFIG_SAGEM_GUI_WIFI_B_ONLY 0
+
+#define cCONFIG_SAGEM_GUI_WIFI_BGN_MIXED 0
+
+#define cCONFIG_SAGEM_GUI_WIFI_WEP64 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:19 */
+#define cCONFIG_SAGEM_GUI_WIFI_WPAxAUTO_AES_TKIP 1
+#define CONFIG_SAGEM_GUI_WIFI_WPAxAUTO_AES_TKIP 1
+
+#define cCONFIG_SAGEM_GUI_WIFICOMMUNITY 0
+
+#define cCONFIG_SAGEM_GUI_VISITORACCESS 0
+
+#define cCONFIG_SAGEM_GUI_ROUTE 0
+
+#define cCONFIG_SAGEM_GUI_LANGUAGE 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:104 */
+#define cCONFIG_SAGEM_GUI_LANG_FR 1
+#define CONFIG_SAGEM_GUI_LANG_FR 1
+
+#define cCONFIG_SAGEM_GUI_LANG_EN 0
+
+#define cCONFIG_SAGEM_GUI_LANG_ES 0
+
+#define cCONFIG_SAGEM_GUI_ADV_FILTER 0
+
+#define cCONFIG_SAGEM_GUI_INFO_SYS 0
+
+#define cCONFIG_SAGEM_GUI_RTC 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:5 */
+#define cCONFIG_SAGEM_GUI_LOGIN_ENABLED 1
+#define CONFIG_SAGEM_GUI_LOGIN_ENABLED 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:127 */
+#define cCONFIG_SAGEM_GUI_INFOSYS_WIFI 1
+#define CONFIG_SAGEM_GUI_INFOSYS_WIFI 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:108 */
+#define cCONFIG_SAGEM_GUI_INFOSYS_VOIP 1
+#define CONFIG_SAGEM_GUI_INFOSYS_VOIP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:109 */
+#define cCONFIG_SAGEM_GUI_INFOSYS_USB 1
+#define CONFIG_SAGEM_GUI_INFOSYS_USB 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:110 */
+#define cCONFIG_SAGEM_GUI_INFOSYS_TV 1
+#define CONFIG_SAGEM_GUI_INFOSYS_TV 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:119 */
+#define cCONFIG_SAGEM_GUI_PROTO_PAT_NAT 1
+#define CONFIG_SAGEM_GUI_PROTO_PAT_NAT 1
+
+#define cCONFIG_SAGEM_GUI_PORT_TRIGGERING_ACCESS 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:121 */
+#define cCONFIG_SAGEM_GUI_NAT_PAT_SCHEDULE 1
+#define CONFIG_SAGEM_GUI_NAT_PAT_SCHEDULE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/dist_config.c:117 */
+#define CONFIG_SAGEM_GUI_NOT_USED_CODE 1
+
+#define cCONFIG_SAGEM_GUI_DEBUG 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:103 */
+#define cCONFIG_SAGEM_GUI_WARNING 1
+#define CONFIG_SAGEM_GUI_WARNING 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:104 */
+#define cCONFIG_SAGEM_GUI_ERROR 1
+#define CONFIG_SAGEM_GUI_ERROR 1
+
+#define cCONFIG_SAGEM_GUI_HW_DEBUG 0
+
+#define cCONFIG_SAGEM_GUI_TV_MULTI_DECODERS 0
+
+#define cCONFIG_SAGEM_FLASH_LAYOUT_LBV2STD 0
+
+#define cCONFIG_SAGEM_FLASH_LAYOUT_LBV2MINI 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:10 */
+#define cCONFIG_SAGEM_FLASH_LAYOUT_LBV2ULT 1
+#define CONFIG_SAGEM_FLASH_LAYOUT_LBV2ULT 1
+
+#define cCONFIG_SAGEM_FLASH_LAYOUT_LBV2BABY 0
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/feature_config.c:1149 */
+#define cCONFIG_SAGEM_DSA_HDR 1
+#define CONFIG_SAGEM_DSA_HDR 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:88 */
+#define cCONFIG_SAGEM_CLI_RG_CONF_PRINT 1
+#define CONFIG_SAGEM_CLI_RG_CONF_PRINT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:89 */
+#define cCONFIG_SAGEM_CLI_RG_CONF_SET 1
+#define CONFIG_SAGEM_CLI_RG_CONF_SET 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:90 */
+#define cCONFIG_SAGEM_CLI_RG_CONF_SET_OBSCURE 1
+#define CONFIG_SAGEM_CLI_RG_CONF_SET_OBSCURE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:91 */
+#define cCONFIG_SAGEM_CLI_RG_CONF_DEL 1
+#define CONFIG_SAGEM_CLI_RG_CONF_DEL 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:92 */
+#define cCONFIG_SAGEM_CLI_RG_CONF_PRIV_SET 1
+#define CONFIG_SAGEM_CLI_RG_CONF_PRIV_SET 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:93 */
+#define cCONFIG_SAGEM_CLI_RG_CONF_PRIV_PRINT 1
+#define CONFIG_SAGEM_CLI_RG_CONF_PRIV_PRINT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:94 */
+#define cCONFIG_SAGEM_CLI_RG_CONF_PRIV_DEL 1
+#define CONFIG_SAGEM_CLI_RG_CONF_PRIV_DEL 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:95 */
+#define cCONFIG_SAGEM_CLI_RG_CONF_RAM_SET 1
+#define CONFIG_SAGEM_CLI_RG_CONF_RAM_SET 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:96 */
+#define cCONFIG_SAGEM_CLI_RG_CONF_RAM_PRINT 1
+#define CONFIG_SAGEM_CLI_RG_CONF_RAM_PRINT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:97 */
+#define cCONFIG_SAGEM_CLI_RG_CONF_RAM_DEL 1
+#define CONFIG_SAGEM_CLI_RG_CONF_RAM_DEL 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:98 */
+#define cCONFIG_SAGEM_CLI_RECONF 1
+#define CONFIG_SAGEM_CLI_RECONF 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:99 */
+#define cCONFIG_SAGEM_CLI_FLASH_LAYOUT 1
+#define CONFIG_SAGEM_CLI_FLASH_LAYOUT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:100 */
+#define cCONFIG_SAGEM_CLI_FLASH_DUMP 1
+#define CONFIG_SAGEM_CLI_FLASH_DUMP 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:101 */
+#define cCONFIG_SAGEM_CLI_FLASH_COMMIT 1
+#define CONFIG_SAGEM_CLI_FLASH_COMMIT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:102 */
+#define cCONFIG_SAGEM_CLI_FLASH_ERASE 1
+#define CONFIG_SAGEM_CLI_FLASH_ERASE 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:55 */
+#define CONFIG_SAGEM_RECONF 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:54 */
+#define CONFIG_SAGEM_GENAUTOM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:59 */
+#define CONFIG_SAGEM_TR69 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:61 */
+#define CONFIG_SAGEM_TR98 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:62 */
+#define CONFIG_SAGEM_TR111 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:56 */
+#define CONFIG_SAGEM_LIBTR69DM 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:53 */
+#define CONFIG_SAGEM_LIBMSG 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:63 */
+#define CONFIG_SAGEM_TR104_H323 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:60 */
+#define CONFIG_SAGEM_LIBTR98_FT 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:58 */
+#define CONFIG_SAGEM_TR69API 1
+/* /home/p778094/devbis/kernel/4.3.14/lastcheckout/rg/pkg/build/sagem_on_the_fly_dist_config.c:57 */
+#define CONFIG_SAGEM_LIBTR69FU 1
diff -pruwN busybox-1.01/include2/linux/byteorder/big_endian.h busybox-1.01-livebox/include2/linux/byteorder/big_endian.h
--- busybox-1.01/include2/linux/byteorder/big_endian.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/byteorder/big_endian.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,106 @@
+#ifndef _LINUX_BYTEORDER_BIG_ENDIAN_H
+#define _LINUX_BYTEORDER_BIG_ENDIAN_H
+
+#ifndef __BIG_ENDIAN
+#define __BIG_ENDIAN 4321
+#endif
+#ifndef __BIG_ENDIAN_BITFIELD
+#define __BIG_ENDIAN_BITFIELD
+#endif
+
+#include <linux/types.h>
+#include <linux/byteorder/swab.h>
+
+#define __constant_htonl(x) ((__force __be32)(__u32)(x))
+#define __constant_ntohl(x) ((__force __u32)(__be32)(x))
+#define __constant_htons(x) ((__force __be16)(__u16)(x))
+#define __constant_ntohs(x) ((__force __u16)(__be16)(x))
+#define __constant_cpu_to_le64(x) ((__force __le64)___constant_swab64((x)))
+#define __constant_le64_to_cpu(x) ___constant_swab64((__force __u64)(__le64)(x))
+#define __constant_cpu_to_le32(x) ((__force __le32)___constant_swab32((x)))
+#define __constant_le32_to_cpu(x) ___constant_swab32((__force __u32)(__le32)(x))
+#define __constant_cpu_to_le16(x) ((__force __le16)___constant_swab16((x)))
+#define __constant_le16_to_cpu(x) ___constant_swab16((__force __u16)(__le16)(x))
+#define __constant_cpu_to_be64(x) ((__force __be64)(__u64)(x))
+#define __constant_be64_to_cpu(x) ((__force __u64)(__be64)(x))
+#define __constant_cpu_to_be32(x) ((__force __be32)(__u32)(x))
+#define __constant_be32_to_cpu(x) ((__force __u32)(__be32)(x))
+#define __constant_cpu_to_be16(x) ((__force __be16)(__u16)(x))
+#define __constant_be16_to_cpu(x) ((__force __u16)(__be16)(x))
+#define __cpu_to_le64(x) ((__force __le64)__swab64((x)))
+#define __le64_to_cpu(x) __swab64((__force __u64)(__le64)(x))
+#define __cpu_to_le32(x) ((__force __le32)__swab32((x)))
+#define __le32_to_cpu(x) __swab32((__force __u32)(__le32)(x))
+#define __cpu_to_le16(x) ((__force __le16)__swab16((x)))
+#define __le16_to_cpu(x) __swab16((__force __u16)(__le16)(x))
+#define __cpu_to_be64(x) ((__force __be64)(__u64)(x))
+#define __be64_to_cpu(x) ((__force __u64)(__be64)(x))
+#define __cpu_to_be32(x) ((__force __be32)(__u32)(x))
+#define __be32_to_cpu(x) ((__force __u32)(__be32)(x))
+#define __cpu_to_be16(x) ((__force __be16)(__u16)(x))
+#define __be16_to_cpu(x) ((__force __u16)(__be16)(x))
+
+static inline __le64 __cpu_to_le64p(const __u64 *p)
+{
+	return (__force __le64)__swab64p(p);
+}
+static inline __u64 __le64_to_cpup(const __le64 *p)
+{
+	return __swab64p((__u64 *)p);
+}
+static inline __le32 __cpu_to_le32p(const __u32 *p)
+{
+	return (__force __le32)__swab32p(p);
+}
+static inline __u32 __le32_to_cpup(const __le32 *p)
+{
+	return __swab32p((__u32 *)p);
+}
+static inline __le16 __cpu_to_le16p(const __u16 *p)
+{
+	return (__force __le16)__swab16p(p);
+}
+static inline __u16 __le16_to_cpup(const __le16 *p)
+{
+	return __swab16p((__u16 *)p);
+}
+static inline __be64 __cpu_to_be64p(const __u64 *p)
+{
+	return (__force __be64)*p;
+}
+static inline __u64 __be64_to_cpup(const __be64 *p)
+{
+	return (__force __u64)*p;
+}
+static inline __be32 __cpu_to_be32p(const __u32 *p)
+{
+	return (__force __be32)*p;
+}
+static inline __u32 __be32_to_cpup(const __be32 *p)
+{
+	return (__force __u32)*p;
+}
+static inline __be16 __cpu_to_be16p(const __u16 *p)
+{
+	return (__force __be16)*p;
+}
+static inline __u16 __be16_to_cpup(const __be16 *p)
+{
+	return (__force __u16)*p;
+}
+#define __cpu_to_le64s(x) __swab64s((x))
+#define __le64_to_cpus(x) __swab64s((x))
+#define __cpu_to_le32s(x) __swab32s((x))
+#define __le32_to_cpus(x) __swab32s((x))
+#define __cpu_to_le16s(x) __swab16s((x))
+#define __le16_to_cpus(x) __swab16s((x))
+#define __cpu_to_be64s(x) do {} while (0)
+#define __be64_to_cpus(x) do {} while (0)
+#define __cpu_to_be32s(x) do {} while (0)
+#define __be32_to_cpus(x) do {} while (0)
+#define __cpu_to_be16s(x) do {} while (0)
+#define __be16_to_cpus(x) do {} while (0)
+
+#include <linux/byteorder/generic.h>
+
+#endif /* _LINUX_BYTEORDER_BIG_ENDIAN_H */
diff -pruwN busybox-1.01/include2/linux/byteorder/generic.h busybox-1.01-livebox/include2/linux/byteorder/generic.h
--- busybox-1.01/include2/linux/byteorder/generic.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/byteorder/generic.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,176 @@
+#ifndef _LINUX_BYTEORDER_GENERIC_H
+#define _LINUX_BYTEORDER_GENERIC_H
+
+/*
+ * linux/byteorder_generic.h
+ * Generic Byte-reordering support
+ *
+ * The "... p" macros, like le64_to_cpup, can be used with pointers
+ * to unaligned data, but there will be a performance penalty on 
+ * some architectures.  Use get_unaligned for unaligned data.
+ *
+ * Francois-Rene Rideau <fare@tunes.org> 19970707
+ *    gathered all the good ideas from all asm-foo/byteorder.h into one file,
+ *    cleaned them up.
+ *    I hope it is compliant with non-GCC compilers.
+ *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,
+ *    because I wasn't sure it would be ok to put it in types.h
+ *    Upgraded it to 2.1.43
+ * Francois-Rene Rideau <fare@tunes.org> 19971012
+ *    Upgraded it to 2.1.57
+ *    to please Linus T., replaced huge #ifdef's between little/big endian
+ *    by nestedly #include'd files.
+ * Francois-Rene Rideau <fare@tunes.org> 19971205
+ *    Made it to 2.1.71; now a facelift:
+ *    Put files under include/linux/byteorder/
+ *    Split swab from generic support.
+ *
+ * TODO:
+ *   = Regular kernel maintainers could also replace all these manual
+ *    byteswap macros that remain, disseminated among drivers,
+ *    after some grep or the sources...
+ *   = Linus might want to rename all these macros and files to fit his taste,
+ *    to fit his personal naming scheme.
+ *   = it seems that a few drivers would also appreciate
+ *    nybble swapping support...
+ *   = every architecture could add their byteswap macro in asm/byteorder.h
+ *    see how some architectures already do (i386, alpha, ppc, etc)
+ *   = cpu_to_beXX and beXX_to_cpu might some day need to be well
+ *    distinguished throughout the kernel. This is not the case currently,
+ *    since little endian, big endian, and pdp endian machines needn't it.
+ *    But this might be the case for, say, a port of Linux to 20/21 bit
+ *    architectures (and F21 Linux addict around?).
+ */
+
+/*
+ * The following macros are to be defined by <asm/byteorder.h>:
+ *
+ * Conversion of long and short int between network and host format
+ *	ntohl(__u32 x)
+ *	ntohs(__u16 x)
+ *	htonl(__u32 x)
+ *	htons(__u16 x)
+ * It seems that some programs (which? where? or perhaps a standard? POSIX?)
+ * might like the above to be functions, not macros (why?).
+ * if that's true, then detect them, and take measures.
+ * Anyway, the measure is: define only ___ntohl as a macro instead,
+ * and in a separate file, have
+ * unsigned long inline ntohl(x){return ___ntohl(x);}
+ *
+ * The same for constant arguments
+ *	__constant_ntohl(__u32 x)
+ *	__constant_ntohs(__u16 x)
+ *	__constant_htonl(__u32 x)
+ *	__constant_htons(__u16 x)
+ *
+ * Conversion of XX-bit integers (16- 32- or 64-)
+ * between native CPU format and little/big endian format
+ * 64-bit stuff only defined for proper architectures
+ *	cpu_to_[bl]eXX(__uXX x)
+ *	[bl]eXX_to_cpu(__uXX x)
+ *
+ * The same, but takes a pointer to the value to convert
+ *	cpu_to_[bl]eXXp(__uXX x)
+ *	[bl]eXX_to_cpup(__uXX x)
+ *
+ * The same, but change in situ
+ *	cpu_to_[bl]eXXs(__uXX x)
+ *	[bl]eXX_to_cpus(__uXX x)
+ *
+ * See asm-foo/byteorder.h for examples of how to provide
+ * architecture-optimized versions
+ *
+ */
+
+
+#if defined(__KERNEL__)
+/*
+ * inside the kernel, we can use nicknames;
+ * outside of it, we must avoid POSIX namespace pollution...
+ */
+#define cpu_to_le64 __cpu_to_le64
+#define le64_to_cpu __le64_to_cpu
+#define cpu_to_le32 __cpu_to_le32
+#define le32_to_cpu __le32_to_cpu
+#define cpu_to_le16 __cpu_to_le16
+#define le16_to_cpu __le16_to_cpu
+#define cpu_to_be64 __cpu_to_be64
+#define be64_to_cpu __be64_to_cpu
+#define cpu_to_be32 __cpu_to_be32
+#define be32_to_cpu __be32_to_cpu
+#define cpu_to_be16 __cpu_to_be16
+#define be16_to_cpu __be16_to_cpu
+#define cpu_to_le64p __cpu_to_le64p
+#define le64_to_cpup __le64_to_cpup
+#define cpu_to_le32p __cpu_to_le32p
+#define le32_to_cpup __le32_to_cpup
+#define cpu_to_le16p __cpu_to_le16p
+#define le16_to_cpup __le16_to_cpup
+#define cpu_to_be64p __cpu_to_be64p
+#define be64_to_cpup __be64_to_cpup
+#define cpu_to_be32p __cpu_to_be32p
+#define be32_to_cpup __be32_to_cpup
+#define cpu_to_be16p __cpu_to_be16p
+#define be16_to_cpup __be16_to_cpup
+#define cpu_to_le64s __cpu_to_le64s
+#define le64_to_cpus __le64_to_cpus
+#define cpu_to_le32s __cpu_to_le32s
+#define le32_to_cpus __le32_to_cpus
+#define cpu_to_le16s __cpu_to_le16s
+#define le16_to_cpus __le16_to_cpus
+#define cpu_to_be64s __cpu_to_be64s
+#define be64_to_cpus __be64_to_cpus
+#define cpu_to_be32s __cpu_to_be32s
+#define be32_to_cpus __be32_to_cpus
+#define cpu_to_be16s __cpu_to_be16s
+#define be16_to_cpus __be16_to_cpus
+#endif
+
+
+#if defined(__KERNEL__)
+/*
+ * Handle ntohl and suches. These have various compatibility
+ * issues - like we want to give the prototype even though we
+ * also have a macro for them in case some strange program
+ * wants to take the address of the thing or something..
+ *
+ * Note that these used to return a "long" in libc5, even though
+ * long is often 64-bit these days.. Thus the casts.
+ *
+ * They have to be macros in order to do the constant folding
+ * correctly - if the argument passed into a inline function
+ * it is no longer constant according to gcc..
+ */
+
+#undef ntohl
+#undef ntohs
+#undef htonl
+#undef htons
+
+/*
+ * Do the prototypes. Somebody might want to take the
+ * address or some such sick thing..
+ */
+extern __u32			ntohl(__be32);
+extern __be32			htonl(__u32);
+extern __u16			ntohs(__be16);
+extern __be16			htons(__u16);
+
+#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__)
+
+#define ___htonl(x) __cpu_to_be32(x)
+#define ___htons(x) __cpu_to_be16(x)
+#define ___ntohl(x) __be32_to_cpu(x)
+#define ___ntohs(x) __be16_to_cpu(x)
+
+#define htonl(x) ___htonl(x)
+#define ntohl(x) ___ntohl(x)
+#define htons(x) ___htons(x)
+#define ntohs(x) ___ntohs(x)
+
+#endif /* OPTIMIZE */
+
+#endif /* KERNEL */
+
+
+#endif /* _LINUX_BYTEORDER_GENERIC_H */
diff -pruwN busybox-1.01/include2/linux/byteorder/swab.h busybox-1.01-livebox/include2/linux/byteorder/swab.h
--- busybox-1.01/include2/linux/byteorder/swab.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/byteorder/swab.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,192 @@
+#ifndef _LINUX_BYTEORDER_SWAB_H
+#define _LINUX_BYTEORDER_SWAB_H
+
+/*
+ * linux/byteorder/swab.h
+ * Byte-swapping, independently from CPU endianness
+ *	swabXX[ps]?(foo)
+ *
+ * Francois-Rene Rideau <fare@tunes.org> 19971205
+ *    separated swab functions from cpu_to_XX,
+ *    to clean up support for bizarre-endian architectures.
+ *
+ * See asm-i386/byteorder.h and suches for examples of how to provide
+ * architecture-dependent optimized versions
+ *
+ */
+
+#include <linux/compiler.h>
+
+/* casts are necessary for constants, because we never know how for sure
+ * how U/UL/ULL map to __u16, __u32, __u64. At least not in a portable way.
+ */
+#define ___swab16(x) \
+({ \
+	__u16 __x = (x); \
+	((__u16)( \
+		(((__u16)(__x) & (__u16)0x00ffU) << 8) | \
+		(((__u16)(__x) & (__u16)0xff00U) >> 8) )); \
+})
+
+#define ___swab32(x) \
+({ \
+	__u32 __x = (x); \
+	((__u32)( \
+		(((__u32)(__x) & (__u32)0x000000ffUL) << 24) | \
+		(((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) | \
+		(((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) | \
+		(((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); \
+})
+
+#define ___swab64(x) \
+({ \
+	__u64 __x = (x); \
+	((__u64)( \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
+		(__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+	        (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); \
+})
+
+#define ___constant_swab16(x) \
+	((__u16)( \
+		(((__u16)(x) & (__u16)0x00ffU) << 8) | \
+		(((__u16)(x) & (__u16)0xff00U) >> 8) ))
+#define ___constant_swab32(x) \
+	((__u32)( \
+		(((__u32)(x) & (__u32)0x000000ffUL) << 24) | \
+		(((__u32)(x) & (__u32)0x0000ff00UL) <<  8) | \
+		(((__u32)(x) & (__u32)0x00ff0000UL) >>  8) | \
+		(((__u32)(x) & (__u32)0xff000000UL) >> 24) ))
+#define ___constant_swab64(x) \
+	((__u64)( \
+		(__u64)(((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) | \
+		(__u64)(((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) | \
+		(__u64)(((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+		(__u64)(((__u64)(x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+	        (__u64)(((__u64)(x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+		(__u64)(((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+		(__u64)(((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+		(__u64)(((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56) ))
+
+/*
+ * provide defaults when no architecture-specific optimization is detected
+ */
+#ifndef __arch__swab16
+#  define __arch__swab16(x) ({ __u16 __tmp = (x) ; ___swab16(__tmp); })
+#endif
+#ifndef __arch__swab32
+#  define __arch__swab32(x) ({ __u32 __tmp = (x) ; ___swab32(__tmp); })
+#endif
+#ifndef __arch__swab64
+#  define __arch__swab64(x) ({ __u64 __tmp = (x) ; ___swab64(__tmp); })
+#endif
+
+#ifndef __arch__swab16p
+#  define __arch__swab16p(x) __arch__swab16(*(x))
+#endif
+#ifndef __arch__swab32p
+#  define __arch__swab32p(x) __arch__swab32(*(x))
+#endif
+#ifndef __arch__swab64p
+#  define __arch__swab64p(x) __arch__swab64(*(x))
+#endif
+
+#ifndef __arch__swab16s
+#  define __arch__swab16s(x) do { *(x) = __arch__swab16p((x)); } while (0)
+#endif
+#ifndef __arch__swab32s
+#  define __arch__swab32s(x) do { *(x) = __arch__swab32p((x)); } while (0)
+#endif
+#ifndef __arch__swab64s
+#  define __arch__swab64s(x) do { *(x) = __arch__swab64p((x)); } while (0)
+#endif
+
+
+/*
+ * Allow constant folding
+ */
+#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__)
+#  define __swab16(x) \
+(__builtin_constant_p((__u16)(x)) ? \
+ ___swab16((x)) : \
+ __fswab16((x)))
+#  define __swab32(x) \
+(__builtin_constant_p((__u32)(x)) ? \
+ ___swab32((x)) : \
+ __fswab32((x)))
+#  define __swab64(x) \
+(__builtin_constant_p((__u64)(x)) ? \
+ ___swab64((x)) : \
+ __fswab64((x)))
+#else
+#  define __swab16(x) __fswab16(x)
+#  define __swab32(x) __fswab32(x)
+#  define __swab64(x) __fswab64(x)
+#endif /* OPTIMIZE */
+
+
+static __inline__ __attribute_const__ __u16 __fswab16(__u16 x)
+{
+	return __arch__swab16(x);
+}
+static __inline__ __u16 __swab16p(const __u16 *x)
+{
+	return __arch__swab16p(x);
+}
+static __inline__ void __swab16s(__u16 *addr)
+{
+	__arch__swab16s(addr);
+}
+
+static __inline__ __attribute_const__ __u32 __fswab32(__u32 x)
+{
+	return __arch__swab32(x);
+}
+static __inline__ __u32 __swab32p(const __u32 *x)
+{
+	return __arch__swab32p(x);
+}
+static __inline__ void __swab32s(__u32 *addr)
+{
+	__arch__swab32s(addr);
+}
+
+#ifdef __BYTEORDER_HAS_U64__
+static __inline__ __attribute_const__ __u64 __fswab64(__u64 x)
+{
+#  ifdef __SWAB_64_THRU_32__
+	__u32 h = x >> 32;
+        __u32 l = x & ((1ULL<<32)-1);
+        return (((__u64)__swab32(l)) << 32) | ((__u64)(__swab32(h)));
+#  else
+	return __arch__swab64(x);
+#  endif
+}
+static __inline__ __u64 __swab64p(const __u64 *x)
+{
+	return __arch__swab64p(x);
+}
+static __inline__ void __swab64s(__u64 *addr)
+{
+	__arch__swab64s(addr);
+}
+#endif /* __BYTEORDER_HAS_U64__ */
+
+#if defined(__KERNEL__)
+#define swab16 __swab16
+#define swab32 __swab32
+#define swab64 __swab64
+#define swab16p __swab16p
+#define swab32p __swab32p
+#define swab64p __swab64p
+#define swab16s __swab16s
+#define swab32s __swab32s
+#define swab64s __swab64s
+#endif
+
+#endif /* _LINUX_BYTEORDER_SWAB_H */
diff -pruwN busybox-1.01/include2/linux/compiler.h busybox-1.01-livebox/include2/linux/compiler.h
--- busybox-1.01/include2/linux/compiler.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/compiler.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,158 @@
+#ifndef __LINUX_COMPILER_H
+#define __LINUX_COMPILER_H
+
+#ifndef __ASSEMBLY__
+
+#ifdef __CHECKER__
+# define __user		__attribute__((noderef, address_space(1)))
+# define __kernel	/* default address space */
+# define __safe		__attribute__((safe))
+# define __force	__attribute__((force))
+# define __nocast	__attribute__((nocast))
+# define __iomem	__attribute__((noderef, address_space(2)))
+# define __acquires(x)	__attribute__((context(0,1)))
+# define __releases(x)	__attribute__((context(1,0)))
+# define __acquire(x)	__context__(1)
+# define __release(x)	__context__(-1)
+# define __cond_lock(x)	((x) ? ({ __context__(1); 1; }) : 0)
+extern void __chk_user_ptr(void __user *);
+extern void __chk_io_ptr(void __iomem *);
+#else
+# define __user
+# define __kernel
+# define __safe
+# define __force
+# define __nocast
+# define __iomem
+# define __chk_user_ptr(x) (void)0
+# define __chk_io_ptr(x) (void)0
+# define __builtin_warning(x, y...) (1)
+# define __acquires(x)
+# define __releases(x)
+# define __acquire(x) (void)0
+# define __release(x) (void)0
+# define __cond_lock(x) (x)
+#endif
+
+#ifdef __KERNEL__
+
+#if __GNUC__ > 4
+#error no compiler-gcc.h file for this gcc version
+#elif __GNUC__ == 4
+# include <linux/compiler-gcc4.h>
+#elif __GNUC__ == 3
+# include <linux/compiler-gcc3.h>
+#elif __GNUC__ == 2
+# include <linux/compiler-gcc2.h>
+#else
+# error Sorry, your compiler is too old/not recognized.
+#endif
+
+/* Intel compiler defines __GNUC__. So we will overwrite implementations
+ * coming from above header files here
+ */
+#ifdef __INTEL_COMPILER
+# include <linux/compiler-intel.h>
+#endif
+
+/*
+ * Generic compiler-dependent macros required for kernel
+ * build go below this comment. Actual compiler/compiler version
+ * specific implementations come from the above header files
+ */
+
+#define likely(x)	__builtin_expect(!!(x), 1)
+#define unlikely(x)	__builtin_expect(!!(x), 0)
+
+/* Optimization barrier */
+#ifndef barrier
+# define barrier() __memory_barrier()
+#endif
+
+#ifndef RELOC_HIDE
+# define RELOC_HIDE(ptr, off)					\
+  ({ unsigned long __ptr;					\
+     __ptr = (unsigned long) (ptr);				\
+    (typeof(ptr)) (__ptr + (off)); })
+#endif
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * Allow us to mark functions as 'deprecated' and have gcc emit a nice
+ * warning for each use, in hopes of speeding the functions removal.
+ * Usage is:
+ * 		int __deprecated foo(void)
+ */
+#ifndef __deprecated
+# define __deprecated		/* unimplemented */
+#endif
+
+#ifdef MODULE
+#define __deprecated_for_modules __deprecated
+#else
+#define __deprecated_for_modules
+#endif
+
+#ifndef __must_check
+#define __must_check
+#endif
+
+/*
+ * Allow us to avoid 'defined but not used' warnings on functions and data,
+ * as well as force them to be emitted to the assembly file.
+ *
+ * As of gcc 3.3, static functions that are not marked with attribute((used))
+ * may be elided from the assembly file.  As of gcc 3.3, static data not so
+ * marked will not be elided, but this may change in a future gcc version.
+ *
+ * In prior versions of gcc, such functions and data would be emitted, but
+ * would be warned about except with attribute((unused)).
+ */
+#ifndef __attribute_used__
+# define __attribute_used__	/* unimplemented */
+#endif
+
+/*
+ * From the GCC manual:
+ *
+ * Many functions have no effects except the return value and their
+ * return value depends only on the parameters and/or global
+ * variables.  Such a function can be subject to common subexpression
+ * elimination and loop optimization just as an arithmetic operator
+ * would be.
+ * [...]
+ */
+#ifndef __attribute_pure__
+# define __attribute_pure__	/* unimplemented */
+#endif
+
+/*
+ * From the GCC manual:
+ *
+ * Many functions do not examine any values except their arguments,
+ * and have no effects except the return value.  Basically this is
+ * just slightly more strict class than the `pure' attribute above,
+ * since function is not allowed to read global memory.
+ *
+ * Note that a function that has pointer arguments and examines the
+ * data pointed to must _not_ be declared `const'.  Likewise, a
+ * function that calls a non-`const' function usually must not be
+ * `const'.  It does not make sense for a `const' function to return
+ * `void'.
+ */
+#ifndef __attribute_const__
+# define __attribute_const__	/* unimplemented */
+#endif
+
+#ifndef noinline
+#define noinline
+#endif
+
+#ifndef __always_inline
+#define __always_inline inline
+#endif
+
+#endif /* __LINUX_COMPILER_H */
diff -pruwN busybox-1.01/include2/linux/config.h busybox-1.01-livebox/include2/linux/config.h
--- busybox-1.01/include2/linux/config.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/config.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,16 @@
+#ifndef _LINUX_CONFIG_H
+#define _LINUX_CONFIG_H
+/* This file is no longer in use and kept only for backward compatibility.
+ * autoconf.h is now included via -imacros on the commandline
+ */
+
+# ifndef _RG_CONFIG_H_
+# define _RG_CONFIG_H_ 
+
+#  ifndef AUTOCONF_INCLUDED
+#include <linux/autoconf.h>
+#  endif
+
+# endif
+
+#endif
diff -pruwN busybox-1.01/include2/linux/fd.h busybox-1.01-livebox/include2/linux/fd.h
--- busybox-1.01/include2/linux/fd.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/fd.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,374 @@
+#ifndef _LINUX_FD_H
+#define _LINUX_FD_H
+
+#include <linux/ioctl.h>
+#include <linux/compiler.h>
+
+/* New file layout: Now the ioctl definitions immediately follow the
+ * definitions of the structures that they use */
+
+/*
+ * Geometry
+ */
+struct floppy_struct {
+	unsigned int	size,		/* nr of sectors total */
+			sect,		/* sectors per track */
+			head,		/* nr of heads */
+			track,		/* nr of tracks */
+			stretch;	/* !=0 means double track steps */
+#define FD_STRETCH 1
+#define FD_SWAPSIDES 2
+#define FD_ZEROBASED 4
+
+	unsigned char	gap,		/* gap1 size */
+
+			rate,		/* data rate. |= 0x40 for perpendicular */
+#define FD_2M 0x4
+#define FD_SIZECODEMASK 0x38
+#define FD_SIZECODE(floppy) (((((floppy)->rate&FD_SIZECODEMASK)>> 3)+ 2) %8)
+#define FD_SECTSIZE(floppy) ( (floppy)->rate & FD_2M ? \
+			     512 : 128 << FD_SIZECODE(floppy) )
+#define FD_PERP 0x40
+
+			spec1,		/* stepping rate, head unload time */
+			fmt_gap;	/* gap2 size */
+	const char	* name; /* used only for predefined formats */
+};
+
+
+/* commands needing write access have 0x40 set */
+/* commands needing super user access have 0x80 set */
+
+#define FDCLRPRM _IO(2, 0x41)
+/* clear user-defined parameters */
+
+#define FDSETPRM _IOW(2, 0x42, struct floppy_struct) 
+#define FDSETMEDIAPRM FDSETPRM
+/* set user-defined parameters for current media */
+
+#define FDDEFPRM _IOW(2, 0x43, struct floppy_struct) 
+#define FDGETPRM _IOR(2, 0x04, struct floppy_struct)
+#define FDDEFMEDIAPRM FDDEFPRM
+#define FDGETMEDIAPRM FDGETPRM
+/* set/get disk parameters */
+
+
+#define	FDMSGON  _IO(2,0x45)
+#define	FDMSGOFF _IO(2,0x46)
+/* issue/don't issue kernel messages on media type change */
+
+
+/* 
+ * Formatting (obsolete)
+ */
+#define FD_FILL_BYTE 0xF6 /* format fill byte. */
+
+struct format_descr {
+	unsigned int device,head,track;
+};
+
+#define FDFMTBEG _IO(2,0x47)
+/* begin formatting a disk */
+#define	FDFMTTRK _IOW(2,0x48, struct format_descr)
+/* format the specified track */
+#define FDFMTEND _IO(2,0x49)
+/* end formatting a disk */
+
+
+/*
+ * Error thresholds
+ */
+struct floppy_max_errors {
+	unsigned int
+	  abort,      /* number of errors to be reached before aborting */
+	  read_track, /* maximal number of errors permitted to read an
+		       * entire track at once */
+	  reset,      /* maximal number of errors before a reset is tried */
+	  recal,      /* maximal number of errors before a recalibrate is
+		       * tried */
+
+	  /*
+	   * Threshold for reporting FDC errors to the console.
+	   * Setting this to zero may flood your screen when using
+	   * ultra cheap floppies ;-)
+	   */
+	  reporting;
+
+};
+
+#define FDSETEMSGTRESH	_IO(2,0x4a)
+/* set fdc error reporting threshold */
+
+#define FDFLUSH  _IO(2,0x4b)
+/* flush buffers for media; either for verifying media, or for
+ * handling a media change without closing the file descriptor */
+
+#define FDSETMAXERRS _IOW(2, 0x4c, struct floppy_max_errors)
+#define FDGETMAXERRS _IOR(2, 0x0e, struct floppy_max_errors)
+/* set/get abortion and read_track threshold. See also floppy_drive_params
+ * structure */
+
+
+typedef char floppy_drive_name[16];
+#define FDGETDRVTYP _IOR(2, 0x0f, floppy_drive_name)
+/* get drive type: 5 1/4 or 3 1/2 */
+
+
+/*
+ * Drive parameters (user modifiable)
+ */
+struct floppy_drive_params {
+	signed char cmos;		/* CMOS type */
+	
+	/* Spec2 is (HLD<<1 | ND), where HLD is head load time (1=2ms, 2=4 ms 
+	 * etc) and ND is set means no DMA. Hardcoded to 6 (HLD=6ms, use DMA).
+	 */
+	unsigned long max_dtr;		/* Step rate, usec */
+	unsigned long hlt;     		/* Head load/settle time, msec */
+	unsigned long hut;     		/* Head unload time (remnant of 
+					 * 8" drives) */
+	unsigned long srt;     		/* Step rate, usec */
+
+	unsigned long spinup;		/* time needed for spinup (expressed
+					 * in jiffies) */
+	unsigned long spindown;		/* timeout needed for spindown */
+	unsigned char spindown_offset;	/* decides in which position the disk
+					 * will stop */
+	unsigned char select_delay;	/* delay to wait after select */
+	unsigned char rps;		/* rotations per second */
+	unsigned char tracks;		/* maximum number of tracks */
+	unsigned long timeout;		/* timeout for interrupt requests */
+	
+	unsigned char interleave_sect;	/* if there are more sectors, use 
+					 * interleave */
+	
+	struct floppy_max_errors max_errors;
+	
+	char flags;			/* various flags, including ftd_msg */
+/*
+ * Announce successful media type detection and media information loss after
+ * disk changes.
+ * Also used to enable/disable printing of overrun warnings.
+ */
+
+#define FTD_MSG 0x10
+#define FD_BROKEN_DCL 0x20
+#define FD_DEBUG 0x02
+#define FD_SILENT_DCL_CLEAR 0x4
+#define FD_INVERTED_DCL 0x80 /* must be 0x80, because of hardware 
+				considerations */
+
+	char read_track;		/* use readtrack during probing? */
+
+/*
+ * Auto-detection. Each drive type has eight formats which are
+ * used in succession to try to read the disk. If the FDC cannot lock onto
+ * the disk, the next format is tried. This uses the variable 'probing'.
+ */
+	short autodetect[8];		/* autodetected formats */
+	
+	int checkfreq; /* how often should the drive be checked for disk 
+			* changes */
+	int native_format; /* native format of this drive */
+};
+
+enum {
+	FD_NEED_TWADDLE_BIT,	/* more magic */
+	FD_VERIFY_BIT,		/* inquire for write protection */
+	FD_DISK_NEWCHANGE_BIT,	/* change detected, and no action undertaken yet
+				 * to clear media change status */
+	FD_UNUSED_BIT,
+	FD_DISK_CHANGED_BIT,	/* disk has been changed since last i/o */
+	FD_DISK_WRITABLE_BIT	/* disk is writable */
+};
+
+#define FDSETDRVPRM _IOW(2, 0x90, struct floppy_drive_params)
+#define FDGETDRVPRM _IOR(2, 0x11, struct floppy_drive_params)
+/* set/get drive parameters */
+
+
+/*
+ * Current drive state (not directly modifiable by user, readonly)
+ */
+struct floppy_drive_struct {
+	unsigned long flags;
+/* values for these flags */
+#define FD_NEED_TWADDLE (1 << FD_NEED_TWADDLE_BIT)
+#define FD_VERIFY (1 << FD_VERIFY_BIT)
+#define FD_DISK_NEWCHANGE (1 << FD_DISK_NEWCHANGE_BIT)
+#define FD_DISK_CHANGED (1 << FD_DISK_CHANGED_BIT)
+#define FD_DISK_WRITABLE (1 << FD_DISK_WRITABLE_BIT)
+
+	unsigned long spinup_date;
+	unsigned long select_date;
+	unsigned long first_read_date;
+	short probed_format;
+	short track; /* current track */
+	short maxblock; /* id of highest block read */
+	short maxtrack; /* id of highest half track read */
+	int generation; /* how many diskchanges? */
+
+/*
+ * (User-provided) media information is _not_ discarded after a media change
+ * if the corresponding keep_data flag is non-zero. Positive values are
+ * decremented after each probe.
+ */
+	int keep_data;
+	
+	/* Prevent "aliased" accesses. */
+	int fd_ref;
+	int fd_device;
+	unsigned long last_checked; /* when was the drive last checked for a disk 
+			   * change? */
+	
+	char *dmabuf;
+	int bufblocks;
+};
+
+#define FDGETDRVSTAT _IOR(2, 0x12, struct floppy_drive_struct)
+#define FDPOLLDRVSTAT _IOR(2, 0x13, struct floppy_drive_struct)
+/* get drive state: GET returns the cached state, POLL polls for new state */
+
+
+/*
+ * reset FDC
+ */
+enum reset_mode {
+	FD_RESET_IF_NEEDED,	/* reset only if the reset flags is set */
+	FD_RESET_IF_RAWCMD,	/* obsolete */
+	FD_RESET_ALWAYS		/* reset always */
+};
+#define FDRESET _IO(2, 0x54)
+
+
+/*
+ * FDC state
+ */
+struct floppy_fdc_state {	
+	int spec1;		/* spec1 value last used */
+	int spec2;		/* spec2 value last used */
+	int dtr;
+	unsigned char version;	/* FDC version code */
+	unsigned char dor;
+	unsigned long address;	/* io address */
+	unsigned int rawcmd:2;
+	unsigned int reset:1;
+	unsigned int need_configure:1;
+	unsigned int perp_mode:2;
+	unsigned int has_fifo:1;
+	unsigned int driver_version;	/* version code for floppy driver */
+#define FD_DRIVER_VERSION 0x100
+/* user programs using the floppy API should use floppy_fdc_state to
+ * get the version number of the floppy driver that they are running
+ * on. If this version number is bigger than the one compiled into the
+ * user program (the FD_DRIVER_VERSION define), it should be prepared
+ * to bigger structures
+ */
+
+	unsigned char track[4];
+	/* Position of the heads of the 4 units attached to this FDC,
+	 * as stored on the FDC. In the future, the position as stored
+	 * on the FDC might not agree with the actual physical
+	 * position of these drive heads. By allowing such
+	 * disagreement, it will be possible to reset the FDC without
+	 * incurring the expensive cost of repositioning all heads.
+	 * Right now, these positions are hard wired to 0. */
+
+};
+
+#define FDGETFDCSTAT _IOR(2, 0x15, struct floppy_fdc_state)
+
+
+/*
+ * Asynchronous Write error tracking
+ */
+struct floppy_write_errors {
+	/* Write error logging.
+	 *
+	 * These fields can be cleared with the FDWERRORCLR ioctl.
+	 * Only writes that were attempted but failed due to a physical media
+	 * error are logged.  write(2) calls that fail and return an error code
+	 * to the user process are not counted.
+	 */
+
+	unsigned int write_errors;  /* number of physical write errors 
+				     * encountered */
+	
+	/* position of first and last write errors */
+	unsigned long first_error_sector;
+	int           first_error_generation;
+	unsigned long last_error_sector;
+	int           last_error_generation;
+	
+	unsigned int badness; /* highest retry count for a read or write 
+			       * operation */
+};
+
+#define FDWERRORCLR  _IO(2, 0x56)
+/* clear write error and badness information */
+#define FDWERRORGET  _IOR(2, 0x17, struct floppy_write_errors)
+/* get write error and badness information */
+
+
+/*
+ * Raw commands
+ */
+/* new interface flag: now we can do them in batches */
+#define FDHAVEBATCHEDRAWCMD
+
+struct floppy_raw_cmd {
+	unsigned int flags;
+#define FD_RAW_READ 1
+#define FD_RAW_WRITE 2
+#define FD_RAW_NO_MOTOR 4
+#define FD_RAW_DISK_CHANGE 4 /* out: disk change flag was set */
+#define FD_RAW_INTR 8    /* wait for an interrupt */
+#define FD_RAW_SPIN 0x10 /* spin up the disk for this command */
+#define FD_RAW_NO_MOTOR_AFTER 0x20 /* switch the motor off after command 
+				    * completion */
+#define FD_RAW_NEED_DISK 0x40  /* this command needs a disk to be present */
+#define FD_RAW_NEED_SEEK 0x80  /* this command uses an implied seek (soft) */
+
+/* more "in" flags */
+#define FD_RAW_MORE 0x100  /* more records follow */
+#define FD_RAW_STOP_IF_FAILURE 0x200 /* stop if we encounter a failure */
+#define FD_RAW_STOP_IF_SUCCESS 0x400 /* stop if command successful */
+#define FD_RAW_SOFTFAILURE 0x800 /* consider the return value for failure
+				  * detection too */
+
+/* more "out" flags */
+#define FD_RAW_FAILURE 0x10000 /* command sent to fdc, fdc returned error */
+#define FD_RAW_HARDFAILURE 0x20000 /* fdc had to be reset, or timed out */
+
+	void __user *data;
+	char *kernel_data; /* location of data buffer in the kernel */
+	struct floppy_raw_cmd *next; /* used for chaining of raw cmd's 
+				      * within the kernel */
+	long length; /* in: length of dma transfer. out: remaining bytes */
+	long phys_length; /* physical length, if different from dma length */
+	int buffer_length; /* length of allocated buffer */
+
+	unsigned char rate;
+	unsigned char cmd_count;
+	unsigned char cmd[16];
+	unsigned char reply_count;
+	unsigned char reply[16];
+	int track;
+	int resultcode;
+
+	int reserved1;
+	int reserved2;
+};
+
+#define FDRAWCMD _IO(2, 0x58)
+/* send a raw command to the fdc. Structure size not included, because of
+ * batches */
+
+#define FDTWADDLE _IO(2, 0x59)
+/* flicker motor-on bit before reading a sector. Experimental */
+
+
+#define FDEJECT _IO(2, 0x5a)
+/* eject the disk */
+
+#endif
diff -pruwN busybox-1.01/include2/linux/fs.h busybox-1.01-livebox/include2/linux/fs.h
--- busybox-1.01/include2/linux/fs.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/fs.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,1800 @@
+#ifndef _LINUX_FS_H
+#define _LINUX_FS_H
+
+/*
+ * This file has definitions for some important file table
+ * structures etc.
+ */
+
+#include <linux/config.h>
+#include <linux/limits.h>
+#include <linux/ioctl.h>
+#include <linux/rcuref.h>
+
+/*
+ * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
+ * the file limit at runtime and only root can increase the per-process
+ * nr_file rlimit, so it's safe to set up a ridiculously high absolute
+ * upper limit on files-per-process.
+ *
+ * Some programs (notably those using select()) may have to be 
+ * recompiled to take full advantage of the new limits..  
+ */
+
+/* Fixed constants first: */
+#undef NR_OPEN
+#define NR_OPEN (1024*1024)	/* Absolute upper limit on fd num */
+#define INR_OPEN 1024		/* Initial setting for nfile rlimits */
+
+#define BLOCK_SIZE_BITS 10
+#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
+
+/* And dynamically-tunable limits and defaults: */
+struct files_stat_struct {
+	int nr_files;		/* read only */
+	int nr_free_files;	/* read only */
+	int max_files;		/* tunable */
+};
+extern struct files_stat_struct files_stat;
+
+struct inodes_stat_t {
+	int nr_inodes;
+	int nr_unused;
+	int dummy[5];
+};
+extern struct inodes_stat_t inodes_stat;
+
+extern int leases_enable, lease_break_time;
+
+#ifdef CONFIG_DNOTIFY
+extern int dir_notify_enable;
+#endif
+
+#define NR_FILE  8192	/* this can well be larger on a larger system */
+
+#define MAY_EXEC 1
+#define MAY_WRITE 2
+#define MAY_READ 4
+#define MAY_APPEND 8
+
+#define FMODE_READ 1
+#define FMODE_WRITE 2
+
+/* Internal kernel extensions */
+#define FMODE_LSEEK	4
+#define FMODE_PREAD	8
+#define FMODE_PWRITE	FMODE_PREAD	/* These go hand in hand */
+
+#define RW_MASK		1
+#define RWA_MASK	2
+#define READ 0
+#define WRITE 1
+#define READA 2		/* read-ahead  - don't block if no resources */
+#define SWRITE 3	/* for ll_rw_block() - wait for buffer lock */
+#define SPECIAL 4	/* For non-blockdevice requests in request queue */
+#define READ_SYNC	(READ | (1 << BIO_RW_SYNC))
+#define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNC))
+#define WRITE_BARRIER	((1 << BIO_RW) | (1 << BIO_RW_BARRIER))
+
+#define SEL_IN		1
+#define SEL_OUT		2
+#define SEL_EX		4
+
+/* public flags for file_system_type */
+#define FS_REQUIRES_DEV 1 
+#define FS_BINARY_MOUNTDATA 2
+#define FS_REVAL_DOT	16384	/* Check the paths ".", ".." for staleness */
+#define FS_ODD_RENAME	32768	/* Temporary stuff; will go away as soon
+				  * as nfs_rename() will be cleaned up
+				  */
+/*
+ * These are the fs-independent mount-flags: up to 32 flags are supported
+ */
+#define MS_RDONLY	 1	/* Mount read-only */
+#define MS_NOSUID	 2	/* Ignore suid and sgid bits */
+#define MS_NODEV	 4	/* Disallow access to device special files */
+#define MS_NOEXEC	 8	/* Disallow program execution */
+#define MS_SYNCHRONOUS	16	/* Writes are synced at once */
+#define MS_REMOUNT	32	/* Alter flags of a mounted FS */
+#define MS_MANDLOCK	64	/* Allow mandatory locks on an FS */
+#define MS_DIRSYNC	128	/* Directory modifications are synchronous */
+#define MS_NOATIME	1024	/* Do not update access times. */
+#define MS_NODIRATIME	2048	/* Do not update directory access times */
+#define MS_BIND		4096
+#define MS_MOVE		8192
+#define MS_REC		16384
+#define MS_VERBOSE	32768
+#define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
+#define MS_PRIVATE	(1<<18)	/* change to private */
+#define MS_SLAVE	(1<<19)	/* change to slave */
+#define MS_SHARED	(1<<20)	/* change to shared */
+#define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
+#define MS_ACTIVE	(1<<30)
+#define MS_NOUSER	(1<<31)
+
+/*
+ * Superblock flags that can be altered by MS_REMOUNT
+ */
+#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_NOATIME|\
+			 MS_NODIRATIME)
+
+/*
+ * Old magic mount flag and mask
+ */
+#define MS_MGC_VAL 0xC0ED0000
+#define MS_MGC_MSK 0xffff0000
+
+/* Inode flags - they have nothing to superblock flags now */
+
+#define S_SYNC		1	/* Writes are synced at once */
+#define S_NOATIME	2	/* Do not update access times */
+#define S_APPEND	4	/* Append-only file */
+#define S_IMMUTABLE	8	/* Immutable file */
+#define S_DEAD		16	/* removed, but still open directory */
+#define S_NOQUOTA	32	/* Inode is not counted to quota */
+#define S_DIRSYNC	64	/* Directory modifications are synchronous */
+#define S_NOCMTIME	128	/* Do not update file c/mtime */
+#define S_SWAPFILE	256	/* Do not truncate: swapon got its bmaps */
+#define S_PRIVATE	512	/* Inode is fs-internal */
+
+/*
+ * Note that nosuid etc flags are inode-specific: setting some file-system
+ * flags just means all the inodes inherit those flags by default. It might be
+ * possible to override it selectively if you really wanted to with some
+ * ioctl() that is not currently implemented.
+ *
+ * Exception: MS_RDONLY is always applied to the entire file system.
+ *
+ * Unfortunately, it is possible to change a filesystems flags with it mounted
+ * with files in use.  This means that all of the inodes will not have their
+ * i_flags updated.  Hence, i_flags no longer inherit the superblock mount
+ * flags, so these have to be checked separately. -- rmk@arm.uk.linux.org
+ */
+#define __IS_FLG(inode,flg) ((inode)->i_sb->s_flags & (flg))
+
+#define IS_RDONLY(inode) ((inode)->i_sb->s_flags & MS_RDONLY)
+#define IS_SYNC(inode)		(__IS_FLG(inode, MS_SYNCHRONOUS) || \
+					((inode)->i_flags & S_SYNC))
+#define IS_DIRSYNC(inode)	(__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \
+					((inode)->i_flags & (S_SYNC|S_DIRSYNC)))
+#define IS_MANDLOCK(inode)	__IS_FLG(inode, MS_MANDLOCK)
+
+#define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
+#define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
+#define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
+#define IS_NOATIME(inode)	(__IS_FLG(inode, MS_NOATIME) || ((inode)->i_flags & S_NOATIME))
+#define IS_NODIRATIME(inode)	__IS_FLG(inode, MS_NODIRATIME)
+#define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)
+
+#define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
+#define IS_NOCMTIME(inode)	((inode)->i_flags & S_NOCMTIME)
+#define IS_SWAPFILE(inode)	((inode)->i_flags & S_SWAPFILE)
+#define IS_PRIVATE(inode)	((inode)->i_flags & S_PRIVATE)
+
+/* the read-only stuff doesn't really belong here, but any other place is
+   probably as bad and I don't want to create yet another include file. */
+
+#define BLKROSET   _IO(0x12,93)	/* set device read-only (0 = read-write) */
+#define BLKROGET   _IO(0x12,94)	/* get read-only status (0 = read_write) */
+#define BLKRRPART  _IO(0x12,95)	/* re-read partition table */
+#define BLKGETSIZE _IO(0x12,96)	/* return device size /512 (long *arg) */
+#define BLKFLSBUF  _IO(0x12,97)	/* flush buffer cache */
+#define BLKRASET   _IO(0x12,98)	/* set read ahead for block device */
+#define BLKRAGET   _IO(0x12,99)	/* get current read ahead setting */
+#define BLKFRASET  _IO(0x12,100)/* set filesystem (mm/filemap.c) read-ahead */
+#define BLKFRAGET  _IO(0x12,101)/* get filesystem (mm/filemap.c) read-ahead */
+#define BLKSECTSET _IO(0x12,102)/* set max sectors per request (ll_rw_blk.c) */
+#define BLKSECTGET _IO(0x12,103)/* get max sectors per request (ll_rw_blk.c) */
+#define BLKSSZGET  _IO(0x12,104)/* get block device sector size */
+#if 0
+#define BLKPG      _IO(0x12,105)/* See blkpg.h */
+
+/* Some people are morons.  Do not use sizeof! */
+
+#define BLKELVGET  _IOR(0x12,106,size_t)/* elevator get */
+#define BLKELVSET  _IOW(0x12,107,size_t)/* elevator set */
+/* This was here just to show that the number is taken -
+   probably all these _IO(0x12,*) ioctls should be moved to blkpg.h. */
+#endif
+/* A jump here: 108-111 have been used for various private purposes. */
+#define BLKBSZGET  _IOR(0x12,112,size_t)
+#define BLKBSZSET  _IOW(0x12,113,size_t)
+#define BLKGETSIZE64 _IOR(0x12,114,size_t)	/* return device size in bytes (u64 *arg) */
+
+#define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
+#define FIBMAP	   _IO(0x00,1)	/* bmap access */
+#define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */
+
+#ifdef __KERNEL__
+
+#include <linux/linkage.h>
+#include <linux/wait.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/dcache.h>
+#include <linux/stat.h>
+#include <linux/cache.h>
+#include <linux/kobject.h>
+#include <linux/list.h>
+#include <linux/radix-tree.h>
+#include <linux/prio_tree.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+
+#include <asm/atomic.h>
+#include <asm/semaphore.h>
+#include <asm/byteorder.h>
+
+struct iovec;
+struct nameidata;
+struct kiocb;
+struct pipe_inode_info;
+struct poll_table_struct;
+struct kstatfs;
+struct vm_area_struct;
+struct vfsmount;
+
+/* Used to be a macro which just called the function, now just a function */
+extern void update_atime (struct inode *);
+
+extern void __init inode_init(unsigned long);
+extern void __init inode_init_early(void);
+extern void __init mnt_init(unsigned long);
+extern void __init files_init(unsigned long);
+
+struct buffer_head;
+typedef int (get_block_t)(struct inode *inode, sector_t iblock,
+			struct buffer_head *bh_result, int create);
+typedef int (get_blocks_t)(struct inode *inode, sector_t iblock,
+			unsigned long max_blocks,
+			struct buffer_head *bh_result, int create);
+typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
+			ssize_t bytes, void *private);
+
+/*
+ * Attribute flags.  These should be or-ed together to figure out what
+ * has been changed!
+ */
+#define ATTR_MODE	1
+#define ATTR_UID	2
+#define ATTR_GID	4
+#define ATTR_SIZE	8
+#define ATTR_ATIME	16
+#define ATTR_MTIME	32
+#define ATTR_CTIME	64
+#define ATTR_ATIME_SET	128
+#define ATTR_MTIME_SET	256
+#define ATTR_FORCE	512	/* Not a change, but a change it */
+#define ATTR_ATTR_FLAG	1024
+#define ATTR_KILL_SUID	2048
+#define ATTR_KILL_SGID	4096
+#define ATTR_FILE	8192
+
+/*
+ * This is the Inode Attributes structure, used for notify_change().  It
+ * uses the above definitions as flags, to know which values have changed.
+ * Also, in this manner, a Filesystem can look at only the values it cares
+ * about.  Basically, these are the attributes that the VFS layer can
+ * request to change from the FS layer.
+ *
+ * Derek Atkins <warlord@MIT.EDU> 94-10-20
+ */
+struct iattr {
+	unsigned int	ia_valid;
+	umode_t		ia_mode;
+	uid_t		ia_uid;
+	gid_t		ia_gid;
+	loff_t		ia_size;
+	struct timespec	ia_atime;
+	struct timespec	ia_mtime;
+	struct timespec	ia_ctime;
+
+	/*
+	 * Not an attribute, but an auxilary info for filesystems wanting to
+	 * implement an ftruncate() like method.  NOTE: filesystem should
+	 * check for (ia_valid & ATTR_FILE), and not for (ia_file != NULL).
+	 */
+	struct file	*ia_file;
+};
+
+/*
+ * Includes for diskquotas.
+ */
+#include <linux/quota.h>
+
+/*
+ * oh the beauties of C type declarations.
+ */
+struct page;
+struct address_space;
+struct writeback_control;
+
+struct address_space_operations {
+	int (*writepage)(struct page *page, struct writeback_control *wbc);
+	int (*readpage)(struct file *, struct page *);
+	int (*sync_page)(struct page *);
+
+	/* Write back some dirty pages from this mapping. */
+	int (*writepages)(struct address_space *, struct writeback_control *);
+
+	/* Set a page dirty */
+	int (*set_page_dirty)(struct page *page);
+
+	int (*readpages)(struct file *filp, struct address_space *mapping,
+			struct list_head *pages, unsigned nr_pages);
+
+	/*
+	 * ext3 requires that a successful prepare_write() call be followed
+	 * by a commit_write() call - they must be balanced
+	 */
+	int (*prepare_write)(struct file *, struct page *, unsigned, unsigned);
+	int (*commit_write)(struct file *, struct page *, unsigned, unsigned);
+	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
+	sector_t (*bmap)(struct address_space *, sector_t);
+	int (*invalidatepage) (struct page *, unsigned long);
+	int (*releasepage) (struct page *, gfp_t);
+	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
+			loff_t offset, unsigned long nr_segs);
+	struct page* (*get_xip_page)(struct address_space *, sector_t,
+			int);
+};
+
+struct backing_dev_info;
+struct address_space {
+	struct inode		*host;		/* owner: inode, block_device */
+	struct radix_tree_root	page_tree;	/* radix tree of all pages */
+	rwlock_t		tree_lock;	/* and rwlock protecting it */
+	unsigned int		i_mmap_writable;/* count VM_SHARED mappings */
+	struct prio_tree_root	i_mmap;		/* tree of private and shared mappings */
+	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
+	spinlock_t		i_mmap_lock;	/* protect tree, count, list */
+	unsigned int		truncate_count;	/* Cover race condition with truncate */
+	unsigned long		nrpages;	/* number of total pages */
+	pgoff_t			writeback_index;/* writeback starts here */
+	struct address_space_operations *a_ops;	/* methods */
+	unsigned long		flags;		/* error bits/gfp mask */
+	struct backing_dev_info *backing_dev_info; /* device readahead, etc */
+	spinlock_t		private_lock;	/* for use by the address_space */
+	struct list_head	private_list;	/* ditto */
+	struct address_space	*assoc_mapping;	/* ditto */
+} __attribute__((aligned(sizeof(long))));
+	/*
+	 * On most architectures that alignment is already the case; but
+	 * must be enforced here for CRIS, to let the least signficant bit
+	 * of struct page's "mapping" pointer be used for PAGE_MAPPING_ANON.
+	 */
+
+struct block_device {
+	dev_t			bd_dev;  /* not a kdev_t - it's a search key */
+	struct inode *		bd_inode;	/* will die */
+	int			bd_openers;
+	struct semaphore	bd_sem;	/* open/close mutex */
+	struct semaphore	bd_mount_sem;	/* mount mutex */
+	struct list_head	bd_inodes;
+	void *			bd_holder;
+	int			bd_holders;
+	struct block_device *	bd_contains;
+	unsigned		bd_block_size;
+	struct hd_struct *	bd_part;
+	/* number of times partitions within this device have been opened. */
+	unsigned		bd_part_count;
+	int			bd_invalidated;
+	struct gendisk *	bd_disk;
+	struct list_head	bd_list;
+	struct backing_dev_info *bd_inode_backing_dev_info;
+	/*
+	 * Private data.  You must have bd_claim'ed the block_device
+	 * to use this.  NOTE:  bd_claim allows an owner to claim
+	 * the same device multiple times, the owner must take special
+	 * care to not mess up bd_private for that case.
+	 */
+	unsigned long		bd_private;
+};
+
+/*
+ * Radix-tree tags, for tagging dirty and writeback pages within the pagecache
+ * radix trees
+ */
+#define PAGECACHE_TAG_DIRTY	0
+#define PAGECACHE_TAG_WRITEBACK	1
+
+int mapping_tagged(struct address_space *mapping, int tag);
+
+/*
+ * Might pages of this file be mapped into userspace?
+ */
+static inline int mapping_mapped(struct address_space *mapping)
+{
+	return	!prio_tree_empty(&mapping->i_mmap) ||
+		!list_empty(&mapping->i_mmap_nonlinear);
+}
+
+/*
+ * Might pages of this file have been modified in userspace?
+ * Note that i_mmap_writable counts all VM_SHARED vmas: do_mmap_pgoff
+ * marks vma as VM_SHARED if it is shared, and the file was opened for
+ * writing i.e. vma may be mprotected writable even if now readonly.
+ */
+static inline int mapping_writably_mapped(struct address_space *mapping)
+{
+	return mapping->i_mmap_writable != 0;
+}
+
+/*
+ * Use sequence counter to get consistent i_size on 32-bit processors.
+ */
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#include <linux/seqlock.h>
+#define __NEED_I_SIZE_ORDERED
+#define i_size_ordered_init(inode) seqcount_init(&inode->i_size_seqcount)
+#else
+#define i_size_ordered_init(inode) do { } while (0)
+#endif
+
+struct inode {
+	struct hlist_node	i_hash;
+	struct list_head	i_list;
+	struct list_head	i_sb_list;
+	struct list_head	i_dentry;
+	unsigned long		i_ino;
+	atomic_t		i_count;
+	umode_t			i_mode;
+	unsigned int		i_nlink;
+	uid_t			i_uid;
+	gid_t			i_gid;
+	dev_t			i_rdev;
+	loff_t			i_size;
+	struct timespec		i_atime;
+	struct timespec		i_mtime;
+	struct timespec		i_ctime;
+	unsigned int		i_blkbits;
+	unsigned long		i_blksize;
+	unsigned long		i_version;
+	unsigned long		i_blocks;
+	unsigned short          i_bytes;
+	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
+	struct semaphore	i_sem;
+	struct rw_semaphore	i_alloc_sem;
+	struct inode_operations	*i_op;
+	struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
+	struct super_block	*i_sb;
+	struct file_lock	*i_flock;
+	struct address_space	*i_mapping;
+	struct address_space	i_data;
+#ifdef CONFIG_QUOTA
+	struct dquot		*i_dquot[MAXQUOTAS];
+#endif
+	/* These three should probably be a union */
+	struct list_head	i_devices;
+	struct pipe_inode_info	*i_pipe;
+	struct block_device	*i_bdev;
+	struct cdev		*i_cdev;
+	int			i_cindex;
+
+	__u32			i_generation;
+
+#ifdef CONFIG_DNOTIFY
+	unsigned long		i_dnotify_mask; /* Directory notify events */
+	struct dnotify_struct	*i_dnotify; /* for directory notifications */
+#endif
+
+#ifdef CONFIG_INOTIFY
+	struct list_head	inotify_watches; /* watches on this inode */
+	struct semaphore	inotify_sem;	/* protects the watches list */
+#endif
+
+	unsigned long		i_state;
+	unsigned long		dirtied_when;	/* jiffies of first dirtying */
+
+	unsigned int		i_flags;
+
+	atomic_t		i_writecount;
+	void			*i_security;
+	union {
+		void		*generic_ip;
+	} u;
+#ifdef __NEED_I_SIZE_ORDERED
+	seqcount_t		i_size_seqcount;
+#endif
+};
+
+/*
+ * NOTE: in a 32bit arch with a preemptable kernel and
+ * an UP compile the i_size_read/write must be atomic
+ * with respect to the local cpu (unlike with preempt disabled),
+ * but they don't need to be atomic with respect to other cpus like in
+ * true SMP (so they need either to either locally disable irq around
+ * the read or for example on x86 they can be still implemented as a
+ * cmpxchg8b without the need of the lock prefix). For SMP compiles
+ * and 64bit archs it makes no difference if preempt is enabled or not.
+ */
+static inline loff_t i_size_read(struct inode *inode)
+{
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+	loff_t i_size;
+	unsigned int seq;
+
+	do {
+		seq = read_seqcount_begin(&inode->i_size_seqcount);
+		i_size = inode->i_size;
+	} while (read_seqcount_retry(&inode->i_size_seqcount, seq));
+	return i_size;
+#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
+	loff_t i_size;
+
+	preempt_disable();
+	i_size = inode->i_size;
+	preempt_enable();
+	return i_size;
+#else
+	return inode->i_size;
+#endif
+}
+
+
+static inline void i_size_write(struct inode *inode, loff_t i_size)
+{
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+	write_seqcount_begin(&inode->i_size_seqcount);
+	inode->i_size = i_size;
+	write_seqcount_end(&inode->i_size_seqcount);
+#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
+	preempt_disable();
+	inode->i_size = i_size;
+	preempt_enable();
+#else
+	inode->i_size = i_size;
+#endif
+}
+
+static inline unsigned iminor(struct inode *inode)
+{
+	return MINOR(inode->i_rdev);
+}
+
+static inline unsigned imajor(struct inode *inode)
+{
+	return MAJOR(inode->i_rdev);
+}
+
+extern struct block_device *I_BDEV(struct inode *inode);
+
+struct fown_struct {
+	rwlock_t lock;          /* protects pid, uid, euid fields */
+	int pid;		/* pid or -pgrp where SIGIO should be sent */
+	uid_t uid, euid;	/* uid/euid of process setting the owner */
+	void *security;
+	int signum;		/* posix.1b rt signal to be delivered on IO */
+};
+
+/*
+ * Track a single file's readahead state
+ */
+struct file_ra_state {
+	unsigned long start;		/* Current window */
+	unsigned long size;
+	unsigned long flags;		/* ra flags RA_FLAG_xxx*/
+	unsigned long cache_hit;	/* cache hit count*/
+	unsigned long prev_page;	/* Cache last read() position */
+	unsigned long ahead_start;	/* Ahead window */
+	unsigned long ahead_size;
+	unsigned long ra_pages;		/* Maximum readahead window */
+	unsigned long mmap_hit;		/* Cache hit stat for mmap accesses */
+	unsigned long mmap_miss;	/* Cache miss stat for mmap accesses */
+};
+#define RA_FLAG_MISS 0x01	/* a cache miss occured against this file */
+#define RA_FLAG_INCACHE 0x02	/* file is already in cache */
+
+struct file {
+	/*
+	 * fu_list becomes invalid after file_free is called and queued via
+	 * fu_rcuhead for RCU freeing
+	 */
+	union {
+		struct list_head	fu_list;
+		struct rcu_head 	fu_rcuhead;
+	} f_u;
+	struct dentry		*f_dentry;
+	struct vfsmount         *f_vfsmnt;
+	struct file_operations	*f_op;
+	atomic_t		f_count;
+	unsigned int 		f_flags;
+	mode_t			f_mode;
+	loff_t			f_pos;
+	struct fown_struct	f_owner;
+	unsigned int		f_uid, f_gid;
+	struct file_ra_state	f_ra;
+
+	unsigned long		f_version;
+	void			*f_security;
+
+	/* needed for tty driver, and maybe others */
+	void			*private_data;
+
+#ifdef CONFIG_EPOLL
+	/* Used by fs/eventpoll.c to link all the hooks to this file */
+	struct list_head	f_ep_links;
+	spinlock_t		f_ep_lock;
+#endif /* #ifdef CONFIG_EPOLL */
+	struct address_space	*f_mapping;
+};
+extern spinlock_t files_lock;
+#define file_list_lock() spin_lock(&files_lock);
+#define file_list_unlock() spin_unlock(&files_lock);
+
+#define get_file(x)	rcuref_inc(&(x)->f_count)
+#define file_count(x)	atomic_read(&(x)->f_count)
+
+#define	MAX_NON_LFS	((1UL<<31) - 1)
+
+/* Page cache limit. The filesystems should put that into their s_maxbytes 
+   limits, otherwise bad things can happen in VM. */ 
+#if BITS_PER_LONG==32
+#define MAX_LFS_FILESIZE	(((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1) 
+#elif BITS_PER_LONG==64
+#define MAX_LFS_FILESIZE 	0x7fffffffffffffffUL
+#endif
+
+#define FL_POSIX	1
+#define FL_FLOCK	2
+#define FL_ACCESS	8	/* not trying to lock, just looking */
+#define FL_LOCKD	16	/* lock held by rpc.lockd */
+#define FL_LEASE	32	/* lease held on this file */
+#define FL_SLEEP	128	/* A blocking lock */
+
+/*
+ * The POSIX file lock owner is determined by
+ * the "struct files_struct" in the thread group
+ * (or NULL for no owner - BSD locks).
+ *
+ * Lockd stuffs a "host" pointer into this.
+ */
+typedef struct files_struct *fl_owner_t;
+
+struct file_lock_operations {
+	void (*fl_insert)(struct file_lock *);	/* lock insertion callback */
+	void (*fl_remove)(struct file_lock *);	/* lock removal callback */
+	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
+	void (*fl_release_private)(struct file_lock *);
+};
+
+struct lock_manager_operations {
+	int (*fl_compare_owner)(struct file_lock *, struct file_lock *);
+	void (*fl_notify)(struct file_lock *);	/* unblock callback */
+	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
+	void (*fl_release_private)(struct file_lock *);
+	void (*fl_break)(struct file_lock *);
+	int (*fl_mylease)(struct file_lock *, struct file_lock *);
+	int (*fl_change)(struct file_lock **, int);
+};
+
+/* that will die - we need it for nfs_lock_info */
+#include <linux/nfs_fs_i.h>
+
+struct file_lock {
+	struct file_lock *fl_next;	/* singly linked list for this inode  */
+	struct list_head fl_link;	/* doubly linked list of all locks */
+	struct list_head fl_block;	/* circular list of blocked processes */
+	fl_owner_t fl_owner;
+	unsigned int fl_pid;
+	wait_queue_head_t fl_wait;
+	struct file *fl_file;
+	unsigned char fl_flags;
+	unsigned char fl_type;
+	loff_t fl_start;
+	loff_t fl_end;
+
+	struct fasync_struct *	fl_fasync; /* for lease break notifications */
+	unsigned long fl_break_time;	/* for nonblocking lease breaks */
+
+	struct file_lock_operations *fl_ops;	/* Callbacks for filesystems */
+	struct lock_manager_operations *fl_lmops;	/* Callbacks for lockmanagers */
+	union {
+		struct nfs_lock_info	nfs_fl;
+		struct nfs4_lock_info	nfs4_fl;
+	} fl_u;
+};
+
+/* The following constant reflects the upper bound of the file/locking space */
+#ifndef OFFSET_MAX
+#define INT_LIMIT(x)	(~((x)1 << (sizeof(x)*8 - 1)))
+#define OFFSET_MAX	INT_LIMIT(loff_t)
+#define OFFT_OFFSET_MAX	INT_LIMIT(off_t)
+#endif
+
+extern struct list_head file_lock_list;
+
+#include <linux/fcntl.h>
+
+extern int fcntl_getlk(struct file *, struct flock __user *);
+extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
+			struct flock __user *);
+
+#if BITS_PER_LONG == 32
+extern int fcntl_getlk64(struct file *, struct flock64 __user *);
+extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
+			struct flock64 __user *);
+#endif
+
+extern void send_sigio(struct fown_struct *fown, int fd, int band);
+extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
+extern int fcntl_getlease(struct file *filp);
+
+/* fs/locks.c */
+extern void locks_init_lock(struct file_lock *);
+extern void locks_copy_lock(struct file_lock *, struct file_lock *);
+extern void locks_remove_posix(struct file *, fl_owner_t);
+extern void locks_remove_flock(struct file *);
+extern struct file_lock *posix_test_lock(struct file *, struct file_lock *);
+extern int posix_lock_file(struct file *, struct file_lock *);
+extern int posix_lock_file_wait(struct file *, struct file_lock *);
+extern void posix_block_lock(struct file_lock *, struct file_lock *);
+extern void posix_unblock_lock(struct file *, struct file_lock *);
+extern int posix_locks_deadlock(struct file_lock *, struct file_lock *);
+extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
+extern int __break_lease(struct inode *inode, unsigned int flags);
+extern void lease_get_mtime(struct inode *, struct timespec *time);
+extern int setlease(struct file *, long, struct file_lock **);
+extern int lease_modify(struct file_lock **, int);
+extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
+extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
+extern void steal_locks(fl_owner_t from);
+
+struct fasync_struct {
+	int	magic;
+	int	fa_fd;
+	struct	fasync_struct	*fa_next; /* singly linked list */
+	struct	file 		*fa_file;
+};
+
+#define FASYNC_MAGIC 0x4601
+
+/* SMP safe fasync helpers: */
+extern int fasync_helper(int, struct file *, int, struct fasync_struct **);
+/* can be called from interrupts */
+extern void kill_fasync(struct fasync_struct **, int, int);
+/* only for net: no internal synchronization */
+extern void __kill_fasync(struct fasync_struct *, int, int);
+
+extern int f_setown(struct file *filp, unsigned long arg, int force);
+extern void f_delown(struct file *filp);
+extern int send_sigurg(struct fown_struct *fown);
+
+/*
+ *	Umount options
+ */
+
+#define MNT_FORCE	0x00000001	/* Attempt to forcibily umount */
+#define MNT_DETACH	0x00000002	/* Just detach from the tree */
+#define MNT_EXPIRE	0x00000004	/* Mark for expiry */
+
+extern struct list_head super_blocks;
+extern spinlock_t sb_lock;
+
+#define sb_entry(list)	list_entry((list), struct super_block, s_list)
+#define S_BIAS (1<<30)
+struct super_block {
+	struct list_head	s_list;		/* Keep this first */
+	dev_t			s_dev;		/* search index; _not_ kdev_t */
+	unsigned long		s_blocksize;
+	unsigned long		s_old_blocksize;
+	unsigned char		s_blocksize_bits;
+	unsigned char		s_dirt;
+	unsigned long long	s_maxbytes;	/* Max file size */
+	struct file_system_type	*s_type;
+	struct super_operations	*s_op;
+	struct dquot_operations	*dq_op;
+ 	struct quotactl_ops	*s_qcop;
+	struct export_operations *s_export_op;
+	unsigned long		s_flags;
+	unsigned long		s_magic;
+	struct dentry		*s_root;
+	struct rw_semaphore	s_umount;
+	struct semaphore	s_lock;
+	int			s_count;
+	int			s_syncing;
+	int			s_need_sync_fs;
+	atomic_t		s_active;
+	void                    *s_security;
+	struct xattr_handler	**s_xattr;
+
+	struct list_head	s_inodes;	/* all inodes */
+	struct list_head	s_dirty;	/* dirty inodes */
+	struct list_head	s_io;		/* parked for writeback */
+	struct hlist_head	s_anon;		/* anonymous dentries for (nfs) exporting */
+	struct list_head	s_files;
+
+	struct block_device	*s_bdev;
+	struct list_head	s_instances;
+	struct quota_info	s_dquot;	/* Diskquota specific options */
+
+	int			s_frozen;
+	wait_queue_head_t	s_wait_unfrozen;
+
+	char s_id[32];				/* Informational name */
+
+	void 			*s_fs_info;	/* Filesystem private info */
+
+	/*
+	 * The next field is for VFS *only*. No filesystems have any business
+	 * even looking at it. You had been warned.
+	 */
+	struct semaphore s_vfs_rename_sem;	/* Kludge */
+
+	/* Granuality of c/m/atime in ns.
+	   Cannot be worse than a second */
+	u32		   s_time_gran;
+};
+
+extern struct timespec current_fs_time(struct super_block *sb);
+
+/*
+ * Snapshotting support.
+ */
+enum {
+	SB_UNFROZEN = 0,
+	SB_FREEZE_WRITE	= 1,
+	SB_FREEZE_TRANS = 2,
+};
+
+#define vfs_check_frozen(sb, level) \
+	wait_event((sb)->s_wait_unfrozen, ((sb)->s_frozen < (level)))
+
+static inline void get_fs_excl(void)
+{
+	atomic_inc(&current->fs_excl);
+}
+
+static inline void put_fs_excl(void)
+{
+	atomic_dec(&current->fs_excl);
+}
+
+static inline int has_fs_excl(void)
+{
+	return atomic_read(&current->fs_excl);
+}
+
+
+/*
+ * Superblock locking.
+ */
+static inline void lock_super(struct super_block * sb)
+{
+	get_fs_excl();
+	down(&sb->s_lock);
+}
+
+static inline void unlock_super(struct super_block * sb)
+{
+	put_fs_excl();
+	up(&sb->s_lock);
+}
+
+/*
+ * VFS helper functions..
+ */
+extern int vfs_permission(struct nameidata *, int);
+extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata *);
+extern int vfs_mkdir(struct inode *, struct dentry *, int);
+extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);
+extern int vfs_symlink(struct inode *, struct dentry *, const char *, int);
+extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
+extern int vfs_rmdir(struct inode *, struct dentry *);
+extern int vfs_unlink(struct inode *, struct dentry *);
+extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+
+/*
+ * VFS dentry helper functions.
+ */
+extern void dentry_unhash(struct dentry *dentry);
+
+/*
+ * VFS file helper functions.
+ */
+extern int file_permission(struct file *, int);
+
+/*
+ * File types
+ *
+ * NOTE! These match bits 12..15 of stat.st_mode
+ * (ie "(i_mode >> 12) & 15").
+ */
+#define DT_UNKNOWN	0
+#define DT_FIFO		1
+#define DT_CHR		2
+#define DT_DIR		4
+#define DT_BLK		6
+#define DT_REG		8
+#define DT_LNK		10
+#define DT_SOCK		12
+#define DT_WHT		14
+
+#define OSYNC_METADATA	(1<<0)
+#define OSYNC_DATA	(1<<1)
+#define OSYNC_INODE	(1<<2)
+int generic_osync_inode(struct inode *, struct address_space *, int);
+
+/*
+ * This is the "filldir" function type, used by readdir() to let
+ * the kernel specify what kind of dirent layout it wants to have.
+ * This allows the kernel to read directories into kernel space or
+ * to have different dirent layouts depending on the binary type.
+ */
+typedef int (*filldir_t)(void *, const char *, int, loff_t, ino_t, unsigned);
+
+struct block_device_operations {
+	int (*open) (struct inode *, struct file *);
+	int (*release) (struct inode *, struct file *);
+	int (*ioctl) (struct inode *, struct file *, unsigned, unsigned long);
+	long (*unlocked_ioctl) (struct file *, unsigned, unsigned long);
+	long (*compat_ioctl) (struct file *, unsigned, unsigned long);
+	int (*direct_access) (struct block_device *, sector_t, unsigned long *);
+	int (*media_changed) (struct gendisk *);
+	int (*revalidate_disk) (struct gendisk *);
+	struct module *owner;
+};
+
+/*
+ * "descriptor" for what we're up to with a read for sendfile().
+ * This allows us to use the same read code yet
+ * have multiple different users of the data that
+ * we read from a file.
+ *
+ * The simplest case just copies the data to user
+ * mode.
+ */
+typedef struct {
+	size_t written;
+	size_t count;
+	union {
+		char __user * buf;
+		void *data;
+	} arg;
+	int error;
+} read_descriptor_t;
+
+typedef int (*read_actor_t)(read_descriptor_t *, struct page *, unsigned long, unsigned long);
+
+/* These macros are for out of kernel modules to test that
+ * the kernel supports the unlocked_ioctl and compat_ioctl
+ * fields in struct file_operations. */
+#define HAVE_COMPAT_IOCTL 1
+#define HAVE_UNLOCKED_IOCTL 1
+
+/*
+ * NOTE:
+ * read, write, poll, fsync, readv, writev, unlocked_ioctl and compat_ioctl
+ * can be called without the big kernel lock held in all filesystems.
+ */
+struct file_operations {
+	struct module *owner;
+	loff_t (*llseek) (struct file *, loff_t, int);
+	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
+	ssize_t (*aio_read) (struct kiocb *, char __user *, size_t, loff_t);
+	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
+	ssize_t (*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);
+	int (*readdir) (struct file *, void *, filldir_t);
+	unsigned int (*poll) (struct file *, struct poll_table_struct *);
+	int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
+	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
+	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
+	int (*mmap) (struct file *, struct vm_area_struct *);
+	int (*open) (struct inode *, struct file *);
+	int (*flush) (struct file *);
+	int (*release) (struct inode *, struct file *);
+	int (*fsync) (struct file *, struct dentry *, int datasync);
+	int (*aio_fsync) (struct kiocb *, int datasync);
+	int (*fasync) (int, struct file *, int);
+	int (*lock) (struct file *, int, struct file_lock *);
+	ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);
+	ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);
+	ssize_t (*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void *);
+	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
+	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
+	int (*check_flags)(int);
+	int (*dir_notify)(struct file *filp, unsigned long arg);
+	int (*flock) (struct file *, int, struct file_lock *);
+};
+
+struct inode_operations {
+	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
+	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
+	int (*link) (struct dentry *,struct inode *,struct dentry *);
+	int (*unlink) (struct inode *,struct dentry *);
+	int (*symlink) (struct inode *,struct dentry *,const char *);
+	int (*mkdir) (struct inode *,struct dentry *,int);
+	int (*rmdir) (struct inode *,struct dentry *);
+	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
+	int (*rename) (struct inode *, struct dentry *,
+			struct inode *, struct dentry *);
+	int (*readlink) (struct dentry *, char __user *,int);
+	void * (*follow_link) (struct dentry *, struct nameidata *);
+	void (*put_link) (struct dentry *, struct nameidata *, void *);
+	void (*truncate) (struct inode *);
+	int (*permission) (struct inode *, int, struct nameidata *);
+	int (*setattr) (struct dentry *, struct iattr *);
+	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
+	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
+	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
+	ssize_t (*listxattr) (struct dentry *, char *, size_t);
+	int (*removexattr) (struct dentry *, const char *);
+};
+
+struct seq_file;
+
+extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
+extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
+extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
+		unsigned long, loff_t *);
+extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
+		unsigned long, loff_t *);
+
+/*
+ * NOTE: write_inode, delete_inode, clear_inode, put_inode can be called
+ * without the big kernel lock held in all filesystems.
+ */
+struct super_operations {
+   	struct inode *(*alloc_inode)(struct super_block *sb);
+	void (*destroy_inode)(struct inode *);
+
+	void (*read_inode) (struct inode *);
+  
+   	void (*dirty_inode) (struct inode *);
+	int (*write_inode) (struct inode *, int);
+	void (*put_inode) (struct inode *);
+	void (*drop_inode) (struct inode *);
+	void (*delete_inode) (struct inode *);
+	void (*put_super) (struct super_block *);
+	void (*write_super) (struct super_block *);
+	int (*sync_fs)(struct super_block *sb, int wait);
+	void (*write_super_lockfs) (struct super_block *);
+	void (*unlockfs) (struct super_block *);
+	int (*statfs) (struct super_block *, struct kstatfs *);
+	int (*remount_fs) (struct super_block *, int *, char *);
+	void (*clear_inode) (struct inode *);
+	void (*umount_begin) (struct super_block *);
+
+	int (*show_options)(struct seq_file *, struct vfsmount *);
+
+	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
+	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
+};
+
+/* Inode state bits.  Protected by inode_lock. */
+#define I_DIRTY_SYNC		1 /* Not dirty enough for O_DATASYNC */
+#define I_DIRTY_DATASYNC	2 /* Data-related inode changes pending */
+#define I_DIRTY_PAGES		4 /* Data-related inode changes pending */
+#define __I_LOCK		3
+#define I_LOCK			(1 << __I_LOCK)
+#define I_FREEING		16
+#define I_CLEAR			32
+#define I_NEW			64
+#define I_WILL_FREE		128
+
+#define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
+
+extern void __mark_inode_dirty(struct inode *, int);
+static inline void mark_inode_dirty(struct inode *inode)
+{
+	__mark_inode_dirty(inode, I_DIRTY);
+}
+
+static inline void mark_inode_dirty_sync(struct inode *inode)
+{
+	__mark_inode_dirty(inode, I_DIRTY_SYNC);
+}
+
+static inline void touch_atime(struct vfsmount *mnt, struct dentry *dentry)
+{
+	/* per-mountpoint checks will go here */
+	update_atime(dentry->d_inode);
+}
+
+static inline void file_accessed(struct file *file)
+{
+	if (!(file->f_flags & O_NOATIME))
+		touch_atime(file->f_vfsmnt, file->f_dentry);
+}
+
+int sync_inode(struct inode *inode, struct writeback_control *wbc);
+
+/**
+ * struct export_operations - for nfsd to communicate with file systems
+ * @decode_fh:      decode a file handle fragment and return a &struct dentry
+ * @encode_fh:      encode a file handle fragment from a dentry
+ * @get_name:       find the name for a given inode in a given directory
+ * @get_parent:     find the parent of a given directory
+ * @get_dentry:     find a dentry for the inode given a file handle sub-fragment
+ * @find_exported_dentry:
+ *	set by the exporting module to a standard helper function.
+ *
+ * Description:
+ *    The export_operations structure provides a means for nfsd to communicate
+ *    with a particular exported file system  - particularly enabling nfsd and
+ *    the filesystem to co-operate when dealing with file handles.
+ *
+ *    export_operations contains two basic operation for dealing with file
+ *    handles, decode_fh() and encode_fh(), and allows for some other
+ *    operations to be defined which standard helper routines use to get
+ *    specific information from the filesystem.
+ *
+ *    nfsd encodes information use to determine which filesystem a filehandle
+ *    applies to in the initial part of the file handle.  The remainder, termed
+ *    a file handle fragment, is controlled completely by the filesystem.  The
+ *    standard helper routines assume that this fragment will contain one or
+ *    two sub-fragments, one which identifies the file, and one which may be
+ *    used to identify the (a) directory containing the file.
+ *
+ *    In some situations, nfsd needs to get a dentry which is connected into a
+ *    specific part of the file tree.  To allow for this, it passes the
+ *    function acceptable() together with a @context which can be used to see
+ *    if the dentry is acceptable.  As there can be multiple dentrys for a
+ *    given file, the filesystem should check each one for acceptability before
+ *    looking for the next.  As soon as an acceptable one is found, it should
+ *    be returned.
+ *
+ * decode_fh:
+ *    @decode_fh is given a &struct super_block (@sb), a file handle fragment
+ *    (@fh, @fh_len) and an acceptability testing function (@acceptable,
+ *    @context).  It should return a &struct dentry which refers to the same
+ *    file that the file handle fragment refers to,  and which passes the
+ *    acceptability test.  If it cannot, it should return a %NULL pointer if
+ *    the file was found but no acceptable &dentries were available, or a
+ *    %ERR_PTR error code indicating why it couldn't be found (e.g. %ENOENT or
+ *    %ENOMEM).
+ *
+ * encode_fh:
+ *    @encode_fh should store in the file handle fragment @fh (using at most
+ *    @max_len bytes) information that can be used by @decode_fh to recover the
+ *    file refered to by the &struct dentry @de.  If the @connectable flag is
+ *    set, the encode_fh() should store sufficient information so that a good
+ *    attempt can be made to find not only the file but also it's place in the
+ *    filesystem.   This typically means storing a reference to de->d_parent in
+ *    the filehandle fragment.  encode_fh() should return the number of bytes
+ *    stored or a negative error code such as %-ENOSPC
+ *
+ * get_name:
+ *    @get_name should find a name for the given @child in the given @parent
+ *    directory.  The name should be stored in the @name (with the
+ *    understanding that it is already pointing to a a %NAME_MAX+1 sized
+ *    buffer.   get_name() should return %0 on success, a negative error code
+ *    or error.  @get_name will be called without @parent->i_sem held.
+ *
+ * get_parent:
+ *    @get_parent should find the parent directory for the given @child which
+ *    is also a directory.  In the event that it cannot be found, or storage
+ *    space cannot be allocated, a %ERR_PTR should be returned.
+ *
+ * get_dentry:
+ *    Given a &super_block (@sb) and a pointer to a file-system specific inode
+ *    identifier, possibly an inode number, (@inump) get_dentry() should find
+ *    the identified inode and return a dentry for that inode.  Any suitable
+ *    dentry can be returned including, if necessary, a new dentry created with
+ *    d_alloc_root.  The caller can then find any other extant dentrys by
+ *    following the d_alias links.  If a new dentry was created using
+ *    d_alloc_root, DCACHE_NFSD_DISCONNECTED should be set, and the dentry
+ *    should be d_rehash()ed.
+ *
+ *    If the inode cannot be found, either a %NULL pointer or an %ERR_PTR code
+ *    can be returned.  The @inump will be whatever was passed to
+ *    nfsd_find_fh_dentry() in either the @obj or @parent parameters.
+ *
+ * Locking rules:
+ *    get_parent is called with child->d_inode->i_sem down
+ *    get_name is not (which is possibly inconsistent)
+ */
+
+struct export_operations {
+	struct dentry *(*decode_fh)(struct super_block *sb, __u32 *fh, int fh_len, int fh_type,
+			 int (*acceptable)(void *context, struct dentry *de),
+			 void *context);
+	int (*encode_fh)(struct dentry *de, __u32 *fh, int *max_len,
+			 int connectable);
+
+	/* the following are only called from the filesystem itself */
+	int (*get_name)(struct dentry *parent, char *name,
+			struct dentry *child);
+	struct dentry * (*get_parent)(struct dentry *child);
+	struct dentry * (*get_dentry)(struct super_block *sb, void *inump);
+
+	/* This is set by the exporting module to a standard helper */
+	struct dentry * (*find_exported_dentry)(
+		struct super_block *sb, void *obj, void *parent,
+		int (*acceptable)(void *context, struct dentry *de),
+		void *context);
+
+
+};
+
+extern struct dentry *
+find_exported_dentry(struct super_block *sb, void *obj, void *parent,
+		     int (*acceptable)(void *context, struct dentry *de),
+		     void *context);
+
+struct file_system_type {
+	const char *name;
+	int fs_flags;
+	struct super_block *(*get_sb) (struct file_system_type *, int,
+				       const char *, void *);
+	void (*kill_sb) (struct super_block *);
+	struct module *owner;
+	struct file_system_type * next;
+	struct list_head fs_supers;
+};
+
+struct super_block *get_sb_bdev(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data,
+	int (*fill_super)(struct super_block *, void *, int));
+struct super_block *get_sb_single(struct file_system_type *fs_type,
+	int flags, void *data,
+	int (*fill_super)(struct super_block *, void *, int));
+struct super_block *get_sb_nodev(struct file_system_type *fs_type,
+	int flags, void *data,
+	int (*fill_super)(struct super_block *, void *, int));
+void generic_shutdown_super(struct super_block *sb);
+void kill_block_super(struct super_block *sb);
+void kill_anon_super(struct super_block *sb);
+void kill_litter_super(struct super_block *sb);
+void deactivate_super(struct super_block *sb);
+int set_anon_super(struct super_block *s, void *data);
+struct super_block *sget(struct file_system_type *type,
+			int (*test)(struct super_block *,void *),
+			int (*set)(struct super_block *,void *),
+			void *data);
+struct super_block *get_sb_pseudo(struct file_system_type *, char *,
+			struct super_operations *ops, unsigned long);
+int __put_super(struct super_block *sb);
+int __put_super_and_need_restart(struct super_block *sb);
+void unnamed_dev_init(void);
+
+/* Alas, no aliases. Too much hassle with bringing module.h everywhere */
+#define fops_get(fops) \
+	(((fops) && try_module_get((fops)->owner) ? (fops) : NULL))
+#define fops_put(fops) \
+	do { if (fops) module_put((fops)->owner); } while(0)
+
+extern int register_filesystem(struct file_system_type *);
+extern int unregister_filesystem(struct file_system_type *);
+extern struct vfsmount *kern_mount(struct file_system_type *);
+extern int may_umount_tree(struct vfsmount *);
+extern int may_umount(struct vfsmount *);
+extern void umount_tree(struct vfsmount *, int, struct list_head *);
+extern void release_mounts(struct list_head *);
+extern long do_mount(char *, char *, char *, unsigned long, void *);
+extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
+extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
+				  struct vfsmount *);
+
+extern int vfs_statfs(struct super_block *, struct kstatfs *);
+
+#define FLOCK_VERIFY_READ  1
+#define FLOCK_VERIFY_WRITE 2
+
+extern int locks_mandatory_locked(struct inode *);
+extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
+
+/*
+ * Candidates for mandatory locking have the setgid bit set
+ * but no group execute bit -  an otherwise meaningless combination.
+ */
+#define MANDATORY_LOCK(inode) \
+	(IS_MANDLOCK(inode) && ((inode)->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID)
+
+static inline int locks_verify_locked(struct inode *inode)
+{
+	if (MANDATORY_LOCK(inode))
+		return locks_mandatory_locked(inode);
+	return 0;
+}
+
+extern int rw_verify_area(int, struct file *, loff_t *, size_t);
+
+static inline int locks_verify_truncate(struct inode *inode,
+				    struct file *filp,
+				    loff_t size)
+{
+	if (inode->i_flock && MANDATORY_LOCK(inode))
+		return locks_mandatory_area(
+			FLOCK_VERIFY_WRITE, inode, filp,
+			size < inode->i_size ? size : inode->i_size,
+			(size < inode->i_size ? inode->i_size - size
+			 : size - inode->i_size)
+		);
+	return 0;
+}
+
+static inline int break_lease(struct inode *inode, unsigned int mode)
+{
+	if (inode->i_flock)
+		return __break_lease(inode, mode);
+	return 0;
+}
+
+/* fs/open.c */
+
+extern int do_truncate(struct dentry *, loff_t start, struct file *filp);
+extern long do_sys_open(const char __user *filename, int flags, int mode);
+extern struct file *filp_open(const char *, int, int);
+extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
+extern int filp_close(struct file *, fl_owner_t id);
+extern char * getname(const char __user *);
+
+/* fs/dcache.c */
+extern void __init vfs_caches_init_early(void);
+extern void __init vfs_caches_init(unsigned long);
+
+#define __getname()	kmem_cache_alloc(names_cachep, SLAB_KERNEL)
+#define __putname(name) kmem_cache_free(names_cachep, (void *)(name))
+#ifndef CONFIG_AUDITSYSCALL
+#define putname(name)   __putname(name)
+#else
+extern void putname(const char *name);
+#endif
+
+extern int register_blkdev(unsigned int, const char *);
+extern int unregister_blkdev(unsigned int, const char *);
+extern struct block_device *bdget(dev_t);
+extern void bd_set_size(struct block_device *, loff_t size);
+extern void bd_forget(struct inode *inode);
+extern void bdput(struct block_device *);
+extern struct block_device *open_by_devnum(dev_t, unsigned);
+extern struct file_operations def_blk_fops;
+extern struct address_space_operations def_blk_aops;
+extern struct file_operations def_chr_fops;
+extern struct file_operations bad_sock_fops;
+extern struct file_operations def_fifo_fops;
+extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
+extern int blkdev_ioctl(struct inode *, struct file *, unsigned, unsigned long);
+extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
+extern int blkdev_get(struct block_device *, mode_t, unsigned);
+extern int blkdev_put(struct block_device *);
+extern int bd_claim(struct block_device *, void *);
+extern void bd_release(struct block_device *);
+
+/* fs/char_dev.c */
+extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
+extern int register_chrdev_region(dev_t, unsigned, const char *);
+extern int register_chrdev(unsigned int, const char *,
+			   struct file_operations *);
+extern int unregister_chrdev(unsigned int, const char *);
+extern void unregister_chrdev_region(dev_t, unsigned);
+extern int chrdev_open(struct inode *, struct file *);
+
+/* fs/block_dev.c */
+#define BDEVNAME_SIZE	32	/* Largest string for a blockdev identifier */
+extern const char *__bdevname(dev_t, char *buffer);
+extern const char *bdevname(struct block_device *bdev, char *buffer);
+extern struct block_device *lookup_bdev(const char *);
+extern struct block_device *open_bdev_excl(const char *, int, void *);
+extern void close_bdev_excl(struct block_device *);
+
+extern void init_special_inode(struct inode *, umode_t, dev_t);
+
+/* Invalid inode operations -- fs/bad_inode.c */
+extern void make_bad_inode(struct inode *);
+extern int is_bad_inode(struct inode *);
+
+extern struct file_operations read_fifo_fops;
+extern struct file_operations write_fifo_fops;
+extern struct file_operations rdwr_fifo_fops;
+extern struct file_operations read_pipe_fops;
+extern struct file_operations write_pipe_fops;
+extern struct file_operations rdwr_pipe_fops;
+
+extern int fs_may_remount_ro(struct super_block *);
+
+/*
+ * return READ, READA, or WRITE
+ */
+#define bio_rw(bio)		((bio)->bi_rw & (RW_MASK | RWA_MASK))
+
+/*
+ * return data direction, READ or WRITE
+ */
+#define bio_data_dir(bio)	((bio)->bi_rw & 1)
+
+extern int check_disk_change(struct block_device *);
+extern int invalidate_inodes(struct super_block *);
+extern int __invalidate_device(struct block_device *);
+extern int invalidate_partition(struct gendisk *, int);
+unsigned long invalidate_mapping_pages(struct address_space *mapping,
+					pgoff_t start, pgoff_t end);
+unsigned long invalidate_inode_pages(struct address_space *mapping);
+static inline void invalidate_remote_inode(struct inode *inode)
+{
+	if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
+	    S_ISLNK(inode->i_mode))
+		invalidate_inode_pages(inode->i_mapping);
+}
+extern int invalidate_inode_pages2(struct address_space *mapping);
+extern int invalidate_inode_pages2_range(struct address_space *mapping,
+					 pgoff_t start, pgoff_t end);
+extern int write_inode_now(struct inode *, int);
+extern int filemap_fdatawrite(struct address_space *);
+extern int filemap_flush(struct address_space *);
+extern int filemap_fdatawait(struct address_space *);
+extern int filemap_write_and_wait(struct address_space *mapping);
+extern int filemap_write_and_wait_range(struct address_space *mapping,
+				        loff_t lstart, loff_t lend);
+extern void sync_supers(void);
+extern void sync_filesystems(int wait);
+extern void emergency_sync(void);
+extern void emergency_remount(void);
+extern int do_remount_sb(struct super_block *sb, int flags,
+			 void *data, int force);
+extern sector_t bmap(struct inode *, sector_t);
+extern int notify_change(struct dentry *, struct iattr *);
+extern int permission(struct inode *, int, struct nameidata *);
+extern int generic_permission(struct inode *, int,
+		int (*check_acl)(struct inode *, int));
+
+extern int get_write_access(struct inode *);
+extern int deny_write_access(struct file *);
+static inline void put_write_access(struct inode * inode)
+{
+	atomic_dec(&inode->i_writecount);
+}
+static inline void allow_write_access(struct file *file)
+{
+	if (file)
+		atomic_inc(&file->f_dentry->d_inode->i_writecount);
+}
+extern int do_pipe(int *);
+
+extern int open_namei(const char *, int, int, struct nameidata *);
+extern int may_open(struct nameidata *, int, int);
+
+extern int kernel_read(struct file *, unsigned long, char *, unsigned long);
+extern struct file * open_exec(const char *);
+ 
+/* fs/dcache.c -- generic fs support functions */
+extern int is_subdir(struct dentry *, struct dentry *);
+extern ino_t find_inode_number(struct dentry *, struct qstr *);
+
+#include <linux/err.h>
+
+/* needed for stackable file system support */
+extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
+
+extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
+
+extern void inode_init_once(struct inode *);
+extern void iput(struct inode *);
+extern struct inode * igrab(struct inode *);
+extern ino_t iunique(struct super_block *, ino_t);
+extern int inode_needs_sync(struct inode *inode);
+extern void generic_delete_inode(struct inode *inode);
+extern void generic_drop_inode(struct inode *inode);
+
+extern struct inode *ilookup5_nowait(struct super_block *sb,
+		unsigned long hashval, int (*test)(struct inode *, void *),
+		void *data);
+extern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,
+		int (*test)(struct inode *, void *), void *data);
+extern struct inode *ilookup(struct super_block *sb, unsigned long ino);
+
+extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);
+extern struct inode * iget_locked(struct super_block *, unsigned long);
+extern void unlock_new_inode(struct inode *);
+
+static inline struct inode *iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode = iget_locked(sb, ino);
+	
+	if (inode && (inode->i_state & I_NEW)) {
+		sb->s_op->read_inode(inode);
+		unlock_new_inode(inode);
+	}
+
+	return inode;
+}
+
+extern void __iget(struct inode * inode);
+extern void clear_inode(struct inode *);
+extern void destroy_inode(struct inode *);
+extern struct inode *new_inode(struct super_block *);
+extern int remove_suid(struct dentry *);
+extern void remove_dquot_ref(struct super_block *, int, struct list_head *);
+extern struct semaphore iprune_sem;
+
+extern void __insert_inode_hash(struct inode *, unsigned long hashval);
+extern void remove_inode_hash(struct inode *);
+static inline void insert_inode_hash(struct inode *inode) {
+	__insert_inode_hash(inode, inode->i_ino);
+}
+
+extern struct file * get_empty_filp(void);
+extern void file_move(struct file *f, struct list_head *list);
+extern void file_kill(struct file *f);
+struct bio;
+extern void submit_bio(int, struct bio *);
+extern int bdev_read_only(struct block_device *);
+extern int set_blocksize(struct block_device *, int);
+extern int sb_set_blocksize(struct super_block *, int);
+extern int sb_min_blocksize(struct super_block *, int);
+
+extern int generic_file_mmap(struct file *, struct vm_area_struct *);
+extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
+extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
+extern int file_send_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
+extern ssize_t generic_file_read(struct file *, char __user *, size_t, loff_t *);
+int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
+extern ssize_t generic_file_write(struct file *, const char __user *, size_t, loff_t *);
+extern ssize_t generic_file_aio_read(struct kiocb *, char __user *, size_t, loff_t);
+extern ssize_t __generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t *);
+extern ssize_t generic_file_aio_write(struct kiocb *, const char __user *, size_t, loff_t);
+extern ssize_t generic_file_aio_write_nolock(struct kiocb *, const struct iovec *,
+		unsigned long, loff_t *);
+extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
+		unsigned long *, loff_t, loff_t *, size_t, size_t);
+extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
+		unsigned long, loff_t, loff_t *, size_t, ssize_t);
+extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
+extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
+ssize_t generic_file_write_nolock(struct file *file, const struct iovec *iov,
+				unsigned long nr_segs, loff_t *ppos);
+extern ssize_t generic_file_sendfile(struct file *, loff_t *, size_t, read_actor_t, void *);
+extern void do_generic_mapping_read(struct address_space *mapping,
+				    struct file_ra_state *, struct file *,
+				    loff_t *, read_descriptor_t *, read_actor_t);
+extern void
+file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
+extern ssize_t generic_file_readv(struct file *filp, const struct iovec *iov, 
+	unsigned long nr_segs, loff_t *ppos);
+ssize_t generic_file_writev(struct file *filp, const struct iovec *iov, 
+			unsigned long nr_segs, loff_t *ppos);
+extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t remote_llseek(struct file *file, loff_t offset, int origin);
+extern int generic_file_open(struct inode * inode, struct file * filp);
+extern int nonseekable_open(struct inode * inode, struct file * filp);
+
+#ifdef CONFIG_FS_XIP
+extern ssize_t xip_file_read(struct file *filp, char __user *buf, size_t len,
+			     loff_t *ppos);
+extern ssize_t xip_file_sendfile(struct file *in_file, loff_t *ppos,
+				 size_t count, read_actor_t actor,
+				 void *target);
+extern int xip_file_mmap(struct file * file, struct vm_area_struct * vma);
+extern ssize_t xip_file_write(struct file *filp, const char __user *buf,
+			      size_t len, loff_t *ppos);
+extern int xip_truncate_page(struct address_space *mapping, loff_t from);
+#else
+static inline int xip_truncate_page(struct address_space *mapping, loff_t from)
+{
+	return 0;
+}
+#endif
+
+static inline void do_generic_file_read(struct file * filp, loff_t *ppos,
+					read_descriptor_t * desc,
+					read_actor_t actor)
+{
+	do_generic_mapping_read(filp->f_mapping,
+				&filp->f_ra,
+				filp,
+				ppos,
+				desc,
+				actor);
+}
+
+ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
+	struct block_device *bdev, const struct iovec *iov, loff_t offset,
+	unsigned long nr_segs, get_blocks_t get_blocks, dio_iodone_t end_io,
+	int lock_type);
+
+enum {
+	DIO_LOCKING = 1, /* need locking between buffered and direct access */
+	DIO_NO_LOCKING,  /* bdev; no locking at all between buffered/direct */
+	DIO_OWN_LOCKING, /* filesystem locks buffered and direct internally */
+};
+
+static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
+	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
+	dio_iodone_t end_io)
+{
+	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
+				nr_segs, get_blocks, end_io, DIO_LOCKING);
+}
+
+static inline ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
+	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
+	dio_iodone_t end_io)
+{
+	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
+				nr_segs, get_blocks, end_io, DIO_NO_LOCKING);
+}
+
+static inline ssize_t blockdev_direct_IO_own_locking(int rw, struct kiocb *iocb,
+	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
+	dio_iodone_t end_io)
+{
+	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
+				nr_segs, get_blocks, end_io, DIO_OWN_LOCKING);
+}
+
+extern struct file_operations generic_ro_fops;
+
+#define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
+
+extern int vfs_readlink(struct dentry *, char __user *, int, const char *);
+extern int vfs_follow_link(struct nameidata *, const char *);
+extern int page_readlink(struct dentry *, char __user *, int);
+extern void *page_follow_link_light(struct dentry *, struct nameidata *);
+extern void page_put_link(struct dentry *, struct nameidata *, void *);
+extern int page_symlink(struct inode *inode, const char *symname, int len);
+extern struct inode_operations page_symlink_inode_operations;
+extern int generic_readlink(struct dentry *, char __user *, int);
+extern void generic_fillattr(struct inode *, struct kstat *);
+extern int vfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
+void inode_add_bytes(struct inode *inode, loff_t bytes);
+void inode_sub_bytes(struct inode *inode, loff_t bytes);
+loff_t inode_get_bytes(struct inode *inode);
+void inode_set_bytes(struct inode *inode, loff_t bytes);
+
+extern int vfs_readdir(struct file *, filldir_t, void *);
+
+extern int vfs_stat(char __user *, struct kstat *);
+extern int vfs_lstat(char __user *, struct kstat *);
+extern int vfs_fstat(unsigned int, struct kstat *);
+
+extern int vfs_ioctl(struct file *, unsigned int, unsigned int, unsigned long);
+
+extern struct file_system_type *get_fs_type(const char *name);
+extern struct super_block *get_super(struct block_device *);
+extern struct super_block *user_get_super(dev_t);
+extern void drop_super(struct super_block *sb);
+
+extern int dcache_dir_open(struct inode *, struct file *);
+extern int dcache_dir_close(struct inode *, struct file *);
+extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
+extern int dcache_readdir(struct file *, void *, filldir_t);
+extern int simple_getattr(struct vfsmount *, struct dentry *, struct kstat *);
+extern int simple_statfs(struct super_block *, struct kstatfs *);
+extern int simple_link(struct dentry *, struct inode *, struct dentry *);
+extern int simple_unlink(struct inode *, struct dentry *);
+extern int simple_rmdir(struct inode *, struct dentry *);
+extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+extern int simple_sync_file(struct file *, struct dentry *, int);
+extern int simple_empty(struct dentry *);
+extern int simple_readpage(struct file *file, struct page *page);
+extern int simple_prepare_write(struct file *file, struct page *page,
+			unsigned offset, unsigned to);
+extern int simple_commit_write(struct file *file, struct page *page,
+				unsigned offset, unsigned to);
+
+extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata *);
+extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);
+extern struct file_operations simple_dir_operations;
+extern struct inode_operations simple_dir_inode_operations;
+struct tree_descr { char *name; struct file_operations *ops; int mode; };
+struct dentry *d_alloc_name(struct dentry *, const char *);
+extern int simple_fill_super(struct super_block *, int, struct tree_descr *);
+extern int simple_pin_fs(char *name, struct vfsmount **mount, int *count);
+extern void simple_release_fs(struct vfsmount **mount, int *count);
+
+extern ssize_t simple_read_from_buffer(void __user *, size_t, loff_t *, const void *, size_t);
+
+extern int inode_change_ok(struct inode *, struct iattr *);
+extern int __must_check inode_setattr(struct inode *, struct iattr *);
+
+extern void inode_update_time(struct inode *inode, int ctime_too);
+
+static inline ino_t parent_ino(struct dentry *dentry)
+{
+	ino_t res;
+
+	spin_lock(&dentry->d_lock);
+	res = dentry->d_parent->d_inode->i_ino;
+	spin_unlock(&dentry->d_lock);
+	return res;
+}
+
+/* kernel/fork.c */
+extern int unshare_files(void);
+
+/* Transaction based IO helpers */
+
+/*
+ * An argresp is stored in an allocated page and holds the
+ * size of the argument or response, along with its content
+ */
+struct simple_transaction_argresp {
+	ssize_t size;
+	char data[0];
+};
+
+#define SIMPLE_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct simple_transaction_argresp))
+
+char *simple_transaction_get(struct file *file, const char __user *buf,
+				size_t size);
+ssize_t simple_transaction_read(struct file *file, char __user *buf,
+				size_t size, loff_t *pos);
+int simple_transaction_release(struct inode *inode, struct file *file);
+
+static inline void simple_transaction_set(struct file *file, size_t n)
+{
+	struct simple_transaction_argresp *ar = file->private_data;
+
+	BUG_ON(n > SIMPLE_TRANSACTION_LIMIT);
+
+	/*
+	 * The barrier ensures that ar->size will really remain zero until
+	 * ar->data is ready for reading.
+	 */
+	smp_mb();
+	ar->size = n;
+}
+
+/*
+ * simple attribute files
+ *
+ * These attributes behave similar to those in sysfs:
+ *
+ * Writing to an attribute immediately sets a value, an open file can be
+ * written to multiple times.
+ *
+ * Reading from an attribute creates a buffer from the value that might get
+ * read with multiple read calls. When the attribute has been read
+ * completely, no further read calls are possible until the file is opened
+ * again.
+ *
+ * All attributes contain a text representation of a numeric value
+ * that are accessed with the get() and set() functions.
+ */
+#define DEFINE_SIMPLE_ATTRIBUTE(__fops, __get, __set, __fmt)		\
+static int __fops ## _open(struct inode *inode, struct file *file)	\
+{									\
+	__simple_attr_check_format(__fmt, 0ull);			\
+	return simple_attr_open(inode, file, __get, __set, __fmt);	\
+}									\
+static struct file_operations __fops = {				\
+	.owner	 = THIS_MODULE,						\
+	.open	 = __fops ## _open,					\
+	.release = simple_attr_close,					\
+	.read	 = simple_attr_read,					\
+	.write	 = simple_attr_write,					\
+};
+
+static inline void __attribute__((format(printf, 1, 2)))
+__simple_attr_check_format(const char *fmt, ...)
+{
+	/* don't do anything, just let the compiler check the arguments; */
+}
+
+int simple_attr_open(struct inode *inode, struct file *file,
+		     u64 (*get)(void *), void (*set)(void *, u64),
+		     const char *fmt);
+int simple_attr_close(struct inode *inode, struct file *file);
+ssize_t simple_attr_read(struct file *file, char __user *buf,
+			 size_t len, loff_t *ppos);
+ssize_t simple_attr_write(struct file *file, const char __user *buf,
+			  size_t len, loff_t *ppos);
+
+
+#ifdef CONFIG_SECURITY
+static inline char *alloc_secdata(void)
+{
+	return (char *)get_zeroed_page(GFP_KERNEL);
+}
+
+static inline void free_secdata(void *secdata)
+{
+	free_page((unsigned long)secdata);
+}
+#else
+static inline char *alloc_secdata(void)
+{
+	return (char *)1;
+}
+
+static inline void free_secdata(void *secdata)
+{ }
+#endif	/* CONFIG_SECURITY */
+
+#endif /* __KERNEL__ */
+#endif /* _LINUX_FS_H */
diff -pruwN busybox-1.01/include2/linux/hdreg.h busybox-1.01-livebox/include2/linux/hdreg.h
--- busybox-1.01/include2/linux/hdreg.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/hdreg.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,705 @@
+#ifndef _LINUX_HDREG_H
+#define _LINUX_HDREG_H
+
+#ifdef __KERNEL__
+#include <linux/ata.h>
+
+/*
+ * This file contains some defines for the AT-hd-controller.
+ * Various sources.
+ */
+
+/* ide.c has its own port definitions in "ide.h" */
+
+#define HD_IRQ		14
+
+/* Hd controller regs. Ref: IBM AT Bios-listing */
+#define HD_DATA		0x1f0		/* _CTL when writing */
+#define HD_ERROR	0x1f1		/* see err-bits */
+#define HD_NSECTOR	0x1f2		/* nr of sectors to read/write */
+#define HD_SECTOR	0x1f3		/* starting sector */
+#define HD_LCYL		0x1f4		/* starting cylinder */
+#define HD_HCYL		0x1f5		/* high byte of starting cyl */
+#define HD_CURRENT	0x1f6		/* 101dhhhh , d=drive, hhhh=head */
+#define HD_STATUS	0x1f7		/* see status-bits */
+#define HD_FEATURE	HD_ERROR	/* same io address, read=error, write=feature */
+#define HD_PRECOMP	HD_FEATURE	/* obsolete use of this port - predates IDE */
+#define HD_COMMAND	HD_STATUS	/* same io address, read=status, write=cmd */
+
+#define HD_CMD		0x3f6		/* used for resets */
+#define HD_ALTSTATUS	0x3f6		/* same as HD_STATUS but doesn't clear irq */
+
+/* remainder is shared between hd.c, ide.c, ide-cd.c, and the hdparm utility */
+
+/* Bits of HD_STATUS */
+#define ERR_STAT		0x01
+#define INDEX_STAT		0x02
+#define ECC_STAT		0x04	/* Corrected error */
+#define DRQ_STAT		0x08
+#define SEEK_STAT		0x10
+#define SRV_STAT		0x10
+#define WRERR_STAT		0x20
+#define READY_STAT		0x40
+#define BUSY_STAT		0x80
+
+/* Bits for HD_ERROR */
+#define MARK_ERR		0x01	/* Bad address mark */
+#define TRK0_ERR		0x02	/* couldn't find track 0 */
+#define ABRT_ERR		0x04	/* Command aborted */
+#define MCR_ERR			0x08	/* media change request */
+#define ID_ERR			0x10	/* ID field not found */
+#define MC_ERR			0x20	/* media changed */
+#define ECC_ERR			0x40	/* Uncorrectable ECC error */
+#define BBD_ERR			0x80	/* pre-EIDE meaning:  block marked bad */
+#define ICRC_ERR		0x80	/* new meaning:  CRC error during transfer */
+
+/* Bits of HD_NSECTOR */
+#define CD			0x01
+#define IO			0x02
+#define REL			0x04
+#define TAG_MASK		0xf8
+#endif /* __KERNEL__ */
+
+/*
+ * Command Header sizes for IOCTL commands
+ */
+
+#define HDIO_DRIVE_CMD_HDR_SIZE		(4 * sizeof(u8))
+#define HDIO_DRIVE_HOB_HDR_SIZE		(8 * sizeof(u8))
+#define HDIO_DRIVE_TASK_HDR_SIZE	(8 * sizeof(u8))
+
+#define IDE_DRIVE_TASK_INVALID		-1
+#define IDE_DRIVE_TASK_NO_DATA		0
+#define IDE_DRIVE_TASK_SET_XFER		1
+
+#define IDE_DRIVE_TASK_IN		2
+
+#define IDE_DRIVE_TASK_OUT		3
+#define IDE_DRIVE_TASK_RAW_WRITE	4
+
+/*
+ * Define standard taskfile in/out register
+ */
+#define IDE_TASKFILE_STD_IN_FLAGS	0xFE
+#define IDE_HOB_STD_IN_FLAGS		0x3C
+#ifndef __KERNEL__
+#define IDE_TASKFILE_STD_OUT_FLAGS	0xFE
+#define IDE_HOB_STD_OUT_FLAGS		0x3C
+#endif
+
+typedef unsigned char task_ioreg_t;
+typedef unsigned long sata_ioreg_t;
+
+typedef union ide_reg_valid_s {
+	unsigned all				: 16;
+	struct {
+		unsigned data			: 1;
+		unsigned error_feature		: 1;
+		unsigned sector			: 1;
+		unsigned nsector		: 1;
+		unsigned lcyl			: 1;
+		unsigned hcyl			: 1;
+		unsigned select			: 1;
+		unsigned status_command		: 1;
+
+		unsigned data_hob		: 1;
+		unsigned error_feature_hob	: 1;
+		unsigned sector_hob		: 1;
+		unsigned nsector_hob		: 1;
+		unsigned lcyl_hob		: 1;
+		unsigned hcyl_hob		: 1;
+		unsigned select_hob		: 1;
+		unsigned control_hob		: 1;
+	} b;
+} ide_reg_valid_t;
+
+typedef struct ide_task_request_s {
+	task_ioreg_t	io_ports[8];
+	task_ioreg_t	hob_ports[8];
+	ide_reg_valid_t	out_flags;
+	ide_reg_valid_t	in_flags;
+	int		data_phase;
+	int		req_cmd;
+	unsigned long	out_size;
+	unsigned long	in_size;
+} ide_task_request_t;
+
+typedef struct ide_ioctl_request_s {
+	ide_task_request_t	*task_request;
+	unsigned char		*out_buffer;
+	unsigned char		*in_buffer;
+} ide_ioctl_request_t;
+
+struct hd_drive_cmd_hdr {
+	task_ioreg_t command;
+	task_ioreg_t sector_number;
+	task_ioreg_t feature;
+	task_ioreg_t sector_count;
+};
+
+typedef struct hd_drive_task_hdr {
+	task_ioreg_t data;
+	task_ioreg_t feature;
+	task_ioreg_t sector_count;
+	task_ioreg_t sector_number;
+	task_ioreg_t low_cylinder;
+	task_ioreg_t high_cylinder;
+	task_ioreg_t device_head;
+	task_ioreg_t command;
+} task_struct_t;
+
+typedef struct hd_drive_hob_hdr {
+	task_ioreg_t data;
+	task_ioreg_t feature;
+	task_ioreg_t sector_count;
+	task_ioreg_t sector_number;
+	task_ioreg_t low_cylinder;
+	task_ioreg_t high_cylinder;
+	task_ioreg_t device_head;
+	task_ioreg_t control;
+} hob_struct_t;
+
+#define TASKFILE_INVALID		0x7fff
+#define TASKFILE_48			0x8000
+
+#define TASKFILE_NO_DATA		0x0000
+
+#define TASKFILE_IN			0x0001
+#define TASKFILE_MULTI_IN		0x0002
+
+#define TASKFILE_OUT			0x0004
+#define TASKFILE_MULTI_OUT		0x0008
+#define TASKFILE_IN_OUT			0x0010
+
+#define TASKFILE_IN_DMA			0x0020
+#define TASKFILE_OUT_DMA		0x0040
+#define TASKFILE_IN_DMAQ		0x0080
+#define TASKFILE_OUT_DMAQ		0x0100
+
+#define TASKFILE_P_IN			0x0200
+#define TASKFILE_P_OUT			0x0400
+#define TASKFILE_P_IN_DMA		0x0800
+#define TASKFILE_P_OUT_DMA		0x1000
+#define TASKFILE_P_IN_DMAQ		0x2000
+#define TASKFILE_P_OUT_DMAQ		0x4000
+
+/* ATA/ATAPI Commands pre T13 Spec */
+#define WIN_NOP				0x00
+/*
+ *	0x01->0x02 Reserved
+ */
+#define CFA_REQ_EXT_ERROR_CODE		0x03 /* CFA Request Extended Error Code */
+/*
+ *	0x04->0x07 Reserved
+ */
+#define WIN_SRST			0x08 /* ATAPI soft reset command */
+#define WIN_DEVICE_RESET		0x08
+/*
+ *	0x09->0x0F Reserved
+ */
+#define WIN_RECAL			0x10
+#define WIN_RESTORE			WIN_RECAL
+/*
+ *	0x10->0x1F Reserved
+ */
+#define WIN_READ			0x20 /* 28-Bit */
+#define WIN_READ_ONCE			0x21 /* 28-Bit without retries */
+#define WIN_READ_LONG			0x22 /* 28-Bit */
+#define WIN_READ_LONG_ONCE		0x23 /* 28-Bit without retries */
+#define WIN_READ_EXT			0x24 /* 48-Bit */
+#define WIN_READDMA_EXT			0x25 /* 48-Bit */
+#define WIN_READDMA_QUEUED_EXT		0x26 /* 48-Bit */
+#define WIN_READ_NATIVE_MAX_EXT		0x27 /* 48-Bit */
+/*
+ *	0x28
+ */
+#define WIN_MULTREAD_EXT		0x29 /* 48-Bit */
+/*
+ *	0x2A->0x2F Reserved
+ */
+#define WIN_WRITE			0x30 /* 28-Bit */
+#define WIN_WRITE_ONCE			0x31 /* 28-Bit without retries */
+#define WIN_WRITE_LONG			0x32 /* 28-Bit */
+#define WIN_WRITE_LONG_ONCE		0x33 /* 28-Bit without retries */
+#define WIN_WRITE_EXT			0x34 /* 48-Bit */
+#define WIN_WRITEDMA_EXT		0x35 /* 48-Bit */
+#define WIN_WRITEDMA_QUEUED_EXT		0x36 /* 48-Bit */
+#define WIN_SET_MAX_EXT			0x37 /* 48-Bit */
+#define CFA_WRITE_SECT_WO_ERASE		0x38 /* CFA Write Sectors without erase */
+#define WIN_MULTWRITE_EXT		0x39 /* 48-Bit */
+/*
+ *	0x3A->0x3B Reserved
+ */
+#define WIN_WRITE_VERIFY		0x3C /* 28-Bit */
+/*
+ *	0x3D->0x3F Reserved
+ */
+#define WIN_VERIFY			0x40 /* 28-Bit - Read Verify Sectors */
+#define WIN_VERIFY_ONCE			0x41 /* 28-Bit - without retries */
+#define WIN_VERIFY_EXT			0x42 /* 48-Bit */
+/*
+ *	0x43->0x4F Reserved
+ */
+#define WIN_FORMAT			0x50
+/*
+ *	0x51->0x5F Reserved
+ */
+#define WIN_INIT			0x60
+/*
+ *	0x61->0x5F Reserved
+ */
+#define WIN_SEEK			0x70 /* 0x70-0x7F Reserved */
+
+#define CFA_TRANSLATE_SECTOR		0x87 /* CFA Translate Sector */
+#define WIN_DIAGNOSE			0x90
+#define WIN_SPECIFY			0x91 /* set drive geometry translation */
+#define WIN_DOWNLOAD_MICROCODE		0x92
+#define WIN_STANDBYNOW2			0x94
+#define WIN_STANDBY2			0x96
+#define WIN_SETIDLE2			0x97
+#define WIN_CHECKPOWERMODE2		0x98
+#define WIN_SLEEPNOW2			0x99
+/*
+ *	0x9A VENDOR
+ */
+#define WIN_PACKETCMD			0xA0 /* Send a packet command. */
+#define WIN_PIDENTIFY			0xA1 /* identify ATAPI device	*/
+#define WIN_QUEUED_SERVICE		0xA2
+#define WIN_SMART			0xB0 /* self-monitoring and reporting */
+#define CFA_ERASE_SECTORS		0xC0
+#define WIN_MULTREAD			0xC4 /* read sectors using multiple mode*/
+#define WIN_MULTWRITE			0xC5 /* write sectors using multiple mode */
+#define WIN_SETMULT			0xC6 /* enable/disable multiple mode */
+#define WIN_READDMA_QUEUED		0xC7 /* read sectors using Queued DMA transfers */
+#define WIN_READDMA			0xC8 /* read sectors using DMA transfers */
+#define WIN_READDMA_ONCE		0xC9 /* 28-Bit - without retries */
+#define WIN_WRITEDMA			0xCA /* write sectors using DMA transfers */
+#define WIN_WRITEDMA_ONCE		0xCB /* 28-Bit - without retries */
+#define WIN_WRITEDMA_QUEUED		0xCC /* write sectors using Queued DMA transfers */
+#define CFA_WRITE_MULTI_WO_ERASE	0xCD /* CFA Write multiple without erase */
+#define WIN_GETMEDIASTATUS		0xDA
+#define WIN_ACKMEDIACHANGE		0xDB /* ATA-1, ATA-2 vendor */
+#define WIN_POSTBOOT			0xDC
+#define WIN_PREBOOT 			0xDD
+#define WIN_DOORLOCK			0xDE /* lock door on removable drives */
+#define WIN_DOORUNLOCK			0xDF /* unlock door on removable drives */
+#define WIN_STANDBYNOW1			0xE0
+#define WIN_IDLEIMMEDIATE		0xE1 /* force drive to become "ready" */
+#define WIN_STANDBY			0xE2 /* Set device in Standby Mode */
+#define WIN_SETIDLE1			0xE3
+#define WIN_READ_BUFFER			0xE4 /* force read only 1 sector */
+#define WIN_CHECKPOWERMODE1		0xE5
+#define WIN_SLEEPNOW1			0xE6
+#define WIN_FLUSH_CACHE			0xE7
+#define WIN_WRITE_BUFFER		0xE8 /* force write only 1 sector */
+#define WIN_WRITE_SAME			0xE9 /* read ata-2 to use */
+	/* SET_FEATURES 0x22 or 0xDD */
+#define WIN_FLUSH_CACHE_EXT		0xEA /* 48-Bit */
+#define WIN_IDENTIFY			0xEC /* ask drive to identify itself	*/
+#define WIN_MEDIAEJECT			0xED
+#define WIN_IDENTIFY_DMA		0xEE /* same as WIN_IDENTIFY, but DMA */
+#define WIN_SETFEATURES			0xEF /* set special drive features */
+#define EXABYTE_ENABLE_NEST		0xF0
+#define WIN_SECURITY_SET_PASS		0xF1
+#define WIN_SECURITY_UNLOCK		0xF2
+#define WIN_SECURITY_ERASE_PREPARE	0xF3
+#define WIN_SECURITY_ERASE_UNIT		0xF4
+#define WIN_SECURITY_FREEZE_LOCK	0xF5
+#define WIN_SECURITY_DISABLE		0xF6
+#define WIN_READ_NATIVE_MAX		0xF8 /* return the native maximum address */
+#define WIN_SET_MAX			0xF9
+#define DISABLE_SEAGATE			0xFB
+
+/* WIN_SMART sub-commands */
+
+#define SMART_READ_VALUES		0xD0
+#define SMART_READ_THRESHOLDS		0xD1
+#define SMART_AUTOSAVE			0xD2
+#define SMART_SAVE			0xD3
+#define SMART_IMMEDIATE_OFFLINE		0xD4
+#define SMART_READ_LOG_SECTOR		0xD5
+#define SMART_WRITE_LOG_SECTOR		0xD6
+#define SMART_WRITE_THRESHOLDS		0xD7
+#define SMART_ENABLE			0xD8
+#define SMART_DISABLE			0xD9
+#define SMART_STATUS			0xDA
+#define SMART_AUTO_OFFLINE		0xDB
+
+/* Password used in TF4 & TF5 executing SMART commands */
+
+#define SMART_LCYL_PASS			0x4F
+#define SMART_HCYL_PASS			0xC2
+
+/* WIN_SETFEATURES sub-commands */
+#define SETFEATURES_EN_8BIT	0x01	/* Enable 8-Bit Transfers */
+#define SETFEATURES_EN_WCACHE	0x02	/* Enable write cache */
+#define SETFEATURES_DIS_DEFECT	0x04	/* Disable Defect Management */
+#define SETFEATURES_EN_APM	0x05	/* Enable advanced power management */
+#define SETFEATURES_EN_SAME_R	0x22	/* for a region ATA-1 */
+#define SETFEATURES_DIS_MSN	0x31	/* Disable Media Status Notification */
+#define SETFEATURES_DIS_RETRY	0x33	/* Disable Retry */
+#define SETFEATURES_EN_AAM	0x42	/* Enable Automatic Acoustic Management */
+#define SETFEATURES_RW_LONG	0x44	/* Set Length of VS bytes */
+#define SETFEATURES_SET_CACHE	0x54	/* Set Cache segments to SC Reg. Val */
+#define SETFEATURES_DIS_RLA	0x55	/* Disable read look-ahead feature */
+#define SETFEATURES_EN_RI	0x5D	/* Enable release interrupt */
+#define SETFEATURES_EN_SI	0x5E	/* Enable SERVICE interrupt */
+#define SETFEATURES_DIS_RPOD	0x66	/* Disable reverting to power on defaults */
+#define SETFEATURES_DIS_ECC	0x77	/* Disable ECC byte count */
+#define SETFEATURES_DIS_8BIT	0x81	/* Disable 8-Bit Transfers */
+#define SETFEATURES_DIS_WCACHE	0x82	/* Disable write cache */
+#define SETFEATURES_EN_DEFECT	0x84	/* Enable Defect Management */
+#define SETFEATURES_DIS_APM	0x85	/* Disable advanced power management */
+#define SETFEATURES_EN_ECC	0x88	/* Enable ECC byte count */
+#define SETFEATURES_EN_MSN	0x95	/* Enable Media Status Notification */
+#define SETFEATURES_EN_RETRY	0x99	/* Enable Retry */
+#define SETFEATURES_EN_RLA	0xAA	/* Enable read look-ahead feature */
+#define SETFEATURES_PREFETCH	0xAB	/* Sets drive prefetch value */
+#define SETFEATURES_EN_REST	0xAC	/* ATA-1 */
+#define SETFEATURES_4B_RW_LONG	0xBB	/* Set Lenght of 4 bytes */
+#define SETFEATURES_DIS_AAM	0xC2	/* Disable Automatic Acoustic Management */
+#define SETFEATURES_EN_RPOD	0xCC	/* Enable reverting to power on defaults */
+#define SETFEATURES_DIS_RI	0xDD	/* Disable release interrupt ATAPI */
+#define SETFEATURES_EN_SAME_M	0xDD	/* for a entire device ATA-1 */
+#define SETFEATURES_DIS_SI	0xDE	/* Disable SERVICE interrupt ATAPI */
+
+/* WIN_SECURITY sub-commands */
+
+#define SECURITY_SET_PASSWORD		0xBA
+#define SECURITY_UNLOCK			0xBB
+#define SECURITY_ERASE_PREPARE		0xBC
+#define SECURITY_ERASE_UNIT		0xBD
+#define SECURITY_FREEZE_LOCK		0xBE
+#define SECURITY_DISABLE_PASSWORD	0xBF
+
+struct hd_geometry {
+      unsigned char heads;
+      unsigned char sectors;
+      unsigned short cylinders;
+      unsigned long start;
+};
+
+/* hd/ide ctl's that pass (arg) ptrs to user space are numbered 0x030n/0x031n */
+#define HDIO_GETGEO		0x0301	/* get device geometry */
+#define HDIO_GET_UNMASKINTR	0x0302	/* get current unmask setting */
+#define HDIO_GET_MULTCOUNT	0x0304	/* get current IDE blockmode setting */
+#define HDIO_GET_QDMA		0x0305	/* get use-qdma flag */
+
+#define HDIO_SET_XFER		0x0306  /* set transfer rate via proc */
+
+#define HDIO_OBSOLETE_IDENTITY	0x0307	/* OBSOLETE, DO NOT USE: returns 142 bytes */
+#define HDIO_GET_KEEPSETTINGS	0x0308	/* get keep-settings-on-reset flag */
+#define HDIO_GET_32BIT		0x0309	/* get current io_32bit setting */
+#define HDIO_GET_NOWERR		0x030a	/* get ignore-write-error flag */
+#define HDIO_GET_DMA		0x030b	/* get use-dma flag */
+#define HDIO_GET_NICE		0x030c	/* get nice flags */
+#define HDIO_GET_IDENTITY	0x030d	/* get IDE identification info */
+#define HDIO_GET_WCACHE		0x030e	/* get write cache mode on|off */
+#define HDIO_GET_ACOUSTIC	0x030f	/* get acoustic value */
+#define	HDIO_GET_ADDRESS	0x0310	/* */
+
+#define HDIO_GET_BUSSTATE	0x031a	/* get the bus state of the hwif */
+#define HDIO_TRISTATE_HWIF	0x031b	/* execute a channel tristate */
+#define HDIO_DRIVE_RESET	0x031c	/* execute a device reset */
+#define HDIO_DRIVE_TASKFILE	0x031d	/* execute raw taskfile */
+#define HDIO_DRIVE_TASK		0x031e	/* execute task and special drive command */
+#define HDIO_DRIVE_CMD		0x031f	/* execute a special drive command */
+#define HDIO_DRIVE_CMD_AEB	HDIO_DRIVE_TASK
+
+/* hd/ide ctl's that pass (arg) non-ptr values are numbered 0x032n/0x033n */
+#define HDIO_SET_MULTCOUNT	0x0321	/* change IDE blockmode */
+#define HDIO_SET_UNMASKINTR	0x0322	/* permit other irqs during I/O */
+#define HDIO_SET_KEEPSETTINGS	0x0323	/* keep ioctl settings on reset */
+#define HDIO_SET_32BIT		0x0324	/* change io_32bit flags */
+#define HDIO_SET_NOWERR		0x0325	/* change ignore-write-error flag */
+#define HDIO_SET_DMA		0x0326	/* change use-dma flag */
+#define HDIO_SET_PIO_MODE	0x0327	/* reconfig interface to new speed */
+#define HDIO_SCAN_HWIF		0x0328	/* register and (re)scan interface */
+#define HDIO_SET_NICE		0x0329	/* set nice flags */
+#define HDIO_UNREGISTER_HWIF	0x032a  /* unregister interface */
+#define HDIO_SET_WCACHE		0x032b	/* change write cache enable-disable */
+#define HDIO_SET_ACOUSTIC	0x032c	/* change acoustic behavior */
+#define HDIO_SET_BUSSTATE	0x032d	/* set the bus state of the hwif */
+#define HDIO_SET_QDMA		0x032e	/* change use-qdma flag */
+#define HDIO_SET_ADDRESS	0x032f	/* change lba addressing modes */
+
+/* bus states */
+enum {
+	BUSSTATE_OFF = 0,
+	BUSSTATE_ON,
+	BUSSTATE_TRISTATE
+};
+
+/* hd/ide ctl's that pass (arg) ptrs to user space are numbered 0x033n/0x033n */
+/* 0x330 is reserved - used to be HDIO_GETGEO_BIG */
+/* 0x331 is reserved - used to be HDIO_GETGEO_BIG_RAW */
+/* 0x338 is reserved - used to be HDIO_SET_IDE_SCSI */
+/* 0x339 is reserved - used to be HDIO_SET_SCSI_IDE */
+
+#define __NEW_HD_DRIVE_ID
+
+/*
+ * Structure returned by HDIO_GET_IDENTITY, as per ANSI NCITS ATA6 rev.1b spec.
+ *
+ * If you change something here, please remember to update fix_driveid() in
+ * ide/probe.c.
+ */
+struct hd_driveid {
+	unsigned short	config;		/* lots of obsolete bit flags */
+	unsigned short	cyls;		/* Obsolete, "physical" cyls */
+	unsigned short	reserved2;	/* reserved (word 2) */
+	unsigned short	heads;		/* Obsolete, "physical" heads */
+	unsigned short	track_bytes;	/* unformatted bytes per track */
+	unsigned short	sector_bytes;	/* unformatted bytes per sector */
+	unsigned short	sectors;	/* Obsolete, "physical" sectors per track */
+	unsigned short	vendor0;	/* vendor unique */
+	unsigned short	vendor1;	/* vendor unique */
+	unsigned short	vendor2;	/* Retired vendor unique */
+	unsigned char	serial_no[20];	/* 0 = not_specified */
+	unsigned short	buf_type;	/* Retired */
+	unsigned short	buf_size;	/* Retired, 512 byte increments
+					 * 0 = not_specified
+					 */
+	unsigned short	ecc_bytes;	/* for r/w long cmds; 0 = not_specified */
+	unsigned char	fw_rev[8];	/* 0 = not_specified */
+	unsigned char	model[40];	/* 0 = not_specified */
+	unsigned char	max_multsect;	/* 0=not_implemented */
+	unsigned char	vendor3;	/* vendor unique */
+	unsigned short	dword_io;	/* 0=not_implemented; 1=implemented */
+	unsigned char	vendor4;	/* vendor unique */
+	unsigned char	capability;	/* (upper byte of word 49)
+					 *  3:	IORDYsup
+					 *  2:	IORDYsw
+					 *  1:	LBA
+					 *  0:	DMA
+					 */
+	unsigned short	reserved50;	/* reserved (word 50) */
+	unsigned char	vendor5;	/* Obsolete, vendor unique */
+	unsigned char	tPIO;		/* Obsolete, 0=slow, 1=medium, 2=fast */
+	unsigned char	vendor6;	/* Obsolete, vendor unique */
+	unsigned char	tDMA;		/* Obsolete, 0=slow, 1=medium, 2=fast */
+	unsigned short	field_valid;	/* (word 53)
+					 *  2:	ultra_ok	word  88
+					 *  1:	eide_ok		words 64-70
+					 *  0:	cur_ok		words 54-58
+					 */
+	unsigned short	cur_cyls;	/* Obsolete, logical cylinders */
+	unsigned short	cur_heads;	/* Obsolete, l heads */
+	unsigned short	cur_sectors;	/* Obsolete, l sectors per track */
+	unsigned short	cur_capacity0;	/* Obsolete, l total sectors on drive */
+	unsigned short	cur_capacity1;	/* Obsolete, (2 words, misaligned int)     */
+	unsigned char	multsect;	/* current multiple sector count */
+	unsigned char	multsect_valid;	/* when (bit0==1) multsect is ok */
+	unsigned int	lba_capacity;	/* Obsolete, total number of sectors */
+	unsigned short	dma_1word;	/* Obsolete, single-word dma info */
+	unsigned short	dma_mword;	/* multiple-word dma info */
+	unsigned short  eide_pio_modes; /* bits 0:mode3 1:mode4 */
+	unsigned short  eide_dma_min;	/* min mword dma cycle time (ns) */
+	unsigned short  eide_dma_time;	/* recommended mword dma cycle time (ns) */
+	unsigned short  eide_pio;       /* min cycle time (ns), no IORDY  */
+	unsigned short  eide_pio_iordy; /* min cycle time (ns), with IORDY */
+	unsigned short	words69_70[2];	/* reserved words 69-70
+					 * future command overlap and queuing
+					 */
+	/* HDIO_GET_IDENTITY currently returns only words 0 through 70 */
+	unsigned short	words71_74[4];	/* reserved words 71-74
+					 * for IDENTIFY PACKET DEVICE command
+					 */
+	unsigned short  queue_depth;	/* (word 75)
+					 * 15:5	reserved
+					 *  4:0	Maximum queue depth -1
+					 */
+	unsigned short  words76_79[4];	/* reserved words 76-79 */
+	unsigned short  major_rev_num;	/* (word 80) */
+	unsigned short  minor_rev_num;	/* (word 81) */
+	unsigned short  command_set_1;	/* (word 82) supported
+					 * 15:	Obsolete
+					 * 14:	NOP command
+					 * 13:	READ_BUFFER
+					 * 12:	WRITE_BUFFER
+					 * 11:	Obsolete
+					 * 10:	Host Protected Area
+					 *  9:	DEVICE Reset
+					 *  8:	SERVICE Interrupt
+					 *  7:	Release Interrupt
+					 *  6:	look-ahead
+					 *  5:	write cache
+					 *  4:	PACKET Command
+					 *  3:	Power Management Feature Set
+					 *  2:	Removable Feature Set
+					 *  1:	Security Feature Set
+					 *  0:	SMART Feature Set
+					 */
+	unsigned short  command_set_2;	/* (word 83)
+					 * 15:	Shall be ZERO
+					 * 14:	Shall be ONE
+					 * 13:	FLUSH CACHE EXT
+					 * 12:	FLUSH CACHE
+					 * 11:	Device Configuration Overlay
+					 * 10:	48-bit Address Feature Set
+					 *  9:	Automatic Acoustic Management
+					 *  8:	SET MAX security
+					 *  7:	reserved 1407DT PARTIES
+					 *  6:	SetF sub-command Power-Up
+					 *  5:	Power-Up in Standby Feature Set
+					 *  4:	Removable Media Notification
+					 *  3:	APM Feature Set
+					 *  2:	CFA Feature Set
+					 *  1:	READ/WRITE DMA QUEUED
+					 *  0:	Download MicroCode
+					 */
+	unsigned short  cfsse;		/* (word 84)
+					 * cmd set-feature supported extensions
+					 * 15:	Shall be ZERO
+					 * 14:	Shall be ONE
+					 * 13:6	reserved
+					 *  5:	General Purpose Logging
+					 *  4:	Streaming Feature Set
+					 *  3:	Media Card Pass Through
+					 *  2:	Media Serial Number Valid
+					 *  1:	SMART selt-test supported
+					 *  0:	SMART error logging
+					 */
+	unsigned short  cfs_enable_1;	/* (word 85)
+					 * command set-feature enabled
+					 * 15:	Obsolete
+					 * 14:	NOP command
+					 * 13:	READ_BUFFER
+					 * 12:	WRITE_BUFFER
+					 * 11:	Obsolete
+					 * 10:	Host Protected Area
+					 *  9:	DEVICE Reset
+					 *  8:	SERVICE Interrupt
+					 *  7:	Release Interrupt
+					 *  6:	look-ahead
+					 *  5:	write cache
+					 *  4:	PACKET Command
+					 *  3:	Power Management Feature Set
+					 *  2:	Removable Feature Set
+					 *  1:	Security Feature Set
+					 *  0:	SMART Feature Set
+					 */
+	unsigned short  cfs_enable_2;	/* (word 86)
+					 * command set-feature enabled
+					 * 15:	Shall be ZERO
+					 * 14:	Shall be ONE
+					 * 13:	FLUSH CACHE EXT
+					 * 12:	FLUSH CACHE
+					 * 11:	Device Configuration Overlay
+					 * 10:	48-bit Address Feature Set
+					 *  9:	Automatic Acoustic Management
+					 *  8:	SET MAX security
+					 *  7:	reserved 1407DT PARTIES
+					 *  6:	SetF sub-command Power-Up
+					 *  5:	Power-Up in Standby Feature Set
+					 *  4:	Removable Media Notification
+					 *  3:	APM Feature Set
+					 *  2:	CFA Feature Set
+					 *  1:	READ/WRITE DMA QUEUED
+					 *  0:	Download MicroCode
+					 */
+	unsigned short  csf_default;	/* (word 87)
+					 * command set-feature default
+					 * 15:	Shall be ZERO
+					 * 14:	Shall be ONE
+					 * 13:6	reserved
+					 *  5:	General Purpose Logging enabled
+					 *  4:	Valid CONFIGURE STREAM executed
+					 *  3:	Media Card Pass Through enabled
+					 *  2:	Media Serial Number Valid
+					 *  1:	SMART selt-test supported
+					 *  0:	SMART error logging
+					 */
+	unsigned short  dma_ultra;	/* (word 88) */
+	unsigned short	trseuc;		/* time required for security erase */
+	unsigned short	trsEuc;		/* time required for enhanced erase */
+	unsigned short	CurAPMvalues;	/* current APM values */
+	unsigned short	mprc;		/* master password revision code */
+	unsigned short	hw_config;	/* hardware config (word 93)
+					 * 15:	Shall be ZERO
+					 * 14:	Shall be ONE
+					 * 13:
+					 * 12:
+					 * 11:
+					 * 10:
+					 *  9:
+					 *  8:
+					 *  7:
+					 *  6:
+					 *  5:
+					 *  4:
+					 *  3:
+					 *  2:
+					 *  1:
+					 *  0:	Shall be ONE
+					 */
+	unsigned short	acoustic;	/* (word 94)
+					 * 15:8	Vendor's recommended value
+					 *  7:0	current value
+					 */
+	unsigned short	msrqs;		/* min stream request size */
+	unsigned short	sxfert;		/* stream transfer time */
+	unsigned short	sal;		/* stream access latency */
+	unsigned int	spg;		/* stream performance granularity */
+	unsigned long long lba_capacity_2;/* 48-bit total number of sectors */
+	unsigned short	words104_125[22];/* reserved words 104-125 */
+	unsigned short	last_lun;	/* (word 126) */
+	unsigned short	word127;	/* (word 127) Feature Set
+					 * Removable Media Notification
+					 * 15:2	reserved
+					 *  1:0	00 = not supported
+					 *	01 = supported
+					 *	10 = reserved
+					 *	11 = reserved
+					 */
+	unsigned short	dlf;		/* (word 128)
+					 * device lock function
+					 * 15:9	reserved
+					 *  8	security level 1:max 0:high
+					 *  7:6	reserved
+					 *  5	enhanced erase
+					 *  4	expire
+					 *  3	frozen
+					 *  2	locked
+					 *  1	en/disabled
+					 *  0	capability
+					 */
+	unsigned short  csfo;		/*  (word 129)
+					 * current set features options
+					 * 15:4	reserved
+					 *  3:	auto reassign
+					 *  2:	reverting
+					 *  1:	read-look-ahead
+					 *  0:	write cache
+					 */
+	unsigned short	words130_155[26];/* reserved vendor words 130-155 */
+	unsigned short	word156;	/* reserved vendor word 156 */
+	unsigned short	words157_159[3];/* reserved vendor words 157-159 */
+	unsigned short	cfa_power;	/* (word 160) CFA Power Mode
+					 * 15 word 160 supported
+					 * 14 reserved
+					 * 13
+					 * 12
+					 * 11:0
+					 */
+	unsigned short	words161_175[15];/* Reserved for CFA */
+	unsigned short	words176_205[30];/* Current Media Serial Number */
+	unsigned short	words206_254[49];/* reserved words 206-254 */
+	unsigned short	integrity_word;	/* (word 255)
+					 * 15:8 Checksum
+					 *  7:0 Signature
+					 */
+};
+
+/*
+ * IDE "nice" flags. These are used on a per drive basis to determine
+ * when to be nice and give more bandwidth to the other devices which
+ * share the same IDE bus.
+ */
+#define IDE_NICE_DSC_OVERLAP	(0)	/* per the DSC overlap protocol */
+#define IDE_NICE_ATAPI_OVERLAP	(1)	/* not supported yet */
+#define IDE_NICE_0		(2)	/* when sure that it won't affect us */
+#define IDE_NICE_1		(3)	/* when probably won't affect us much */
+#define IDE_NICE_2		(4)	/* when we know it's on our expense */
+
+#endif	/* _LINUX_HDREG_H */
diff -pruwN busybox-1.01/include2/linux/if_ether.h busybox-1.01-livebox/include2/linux/if_ether.h
--- busybox-1.01/include2/linux/if_ether.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/if_ether.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,121 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Ethernet IEEE 802.3 interface.
+ *
+ * Version:	@(#)if_ether.h	1.0.1a	02/08/94
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Alan Cox, <alan@redhat.com>
+ *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+#include <linux/types.h>
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence). 
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_WCCP	0x883E		/* Web-cache coordination protocol
+					 * defined in draft-wilson-wrec-wccp-v2-00.txt */
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_MPLS_UC	0x8847		/* MPLS Unicast traffic		*/
+#define ETH_P_MPLS_MC	0x8848		/* MPLS Multicast traffic	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+#define ETH_P_AOE	0x88A2		/* ATA over Ethernet		*/
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+ 
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+#define ETH_P_HDLC	0x0019		/* HDLC frames			*/
+#define ETH_P_ARCNET	0x001A		/* 1A for ArcNet :-)            */
+
+/*
+ *	This is an Ethernet frame header.
+ */
+ 
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	__be16		h_proto;		/* packet type ID field	*/
+} __attribute__((packed));
+
+#ifdef __KERNEL__
+#include <linux/skbuff.h>
+
+static inline struct ethhdr *eth_hdr(const struct sk_buff *skb)
+{
+	return (struct ethhdr *)skb->mac.raw;
+}
+
+#ifdef CONFIG_SYSCTL
+extern struct ctl_table ether_table[];
+#endif
+#endif
+
+#endif	/* _LINUX_IF_ETHER_H */
diff -pruwN busybox-1.01/include2/linux/ioctl.h busybox-1.01-livebox/include2/linux/ioctl.h
--- busybox-1.01/include2/linux/ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/ioctl.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,7 @@
+#ifndef _LINUX_IOCTL_H
+#define _LINUX_IOCTL_H
+
+#include <asm/ioctl.h>
+
+#endif /* _LINUX_IOCTL_H */
+
diff -pruwN busybox-1.01/include2/linux/limits.h busybox-1.01-livebox/include2/linux/limits.h
--- busybox-1.01/include2/linux/limits.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/limits.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,22 @@
+#ifndef _LINUX_LIMITS_H
+#define _LINUX_LIMITS_H
+
+#define NR_OPEN	        1024
+
+#define NGROUPS_MAX    65536	/* supplemental group IDs are available */
+#define ARG_MAX       131072	/* # bytes of args + environ for exec() */
+#define CHILD_MAX        999    /* no limit :-) */
+#define OPEN_MAX         256	/* # open files a process may have */
+#define LINK_MAX         127	/* # links a file may have */
+#define MAX_CANON        255	/* size of the canonical input queue */
+#define MAX_INPUT        255	/* size of the type-ahead buffer */
+#define NAME_MAX         255	/* # chars in a file name */
+#define PATH_MAX        4096	/* # chars in a path name including nul */
+#define PIPE_BUF        4096	/* # bytes in atomic write to a pipe */
+#define XATTR_NAME_MAX   255	/* # chars in an extended attribute name */
+#define XATTR_SIZE_MAX 65536	/* size of an extended attribute value (64k) */
+#define XATTR_LIST_MAX 65536	/* size of extended attribute namelist (64k) */
+
+#define RTSIG_MAX	  32
+
+#endif
diff -pruwN busybox-1.01/include2/linux/msdos_fs.h busybox-1.01-livebox/include2/linux/msdos_fs.h
--- busybox-1.01/include2/linux/msdos_fs.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/msdos_fs.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,423 @@
+#ifndef _LINUX_MSDOS_FS_H
+#define _LINUX_MSDOS_FS_H
+
+/*
+ * The MS-DOS filesystem constants/structures
+ */
+#include <asm/byteorder.h>
+
+#define SECTOR_SIZE	512		/* sector size (bytes) */
+#define SECTOR_BITS	9		/* log2(SECTOR_SIZE) */
+#define MSDOS_DPB	(MSDOS_DPS)	/* dir entries per block */
+#define MSDOS_DPB_BITS	4		/* log2(MSDOS_DPB) */
+#define MSDOS_DPS	(SECTOR_SIZE / sizeof(struct msdos_dir_entry))
+#define MSDOS_DPS_BITS	4		/* log2(MSDOS_DPS) */
+#define CF_LE_W(v)	le16_to_cpu(v)
+#define CF_LE_L(v)	le32_to_cpu(v)
+#define CT_LE_W(v)	cpu_to_le16(v)
+#define CT_LE_L(v)	cpu_to_le32(v)
+
+
+#define MSDOS_SUPER_MAGIC 0x4d44 /* MD */
+
+#define MSDOS_ROOT_INO	1	/* == MINIX_ROOT_INO */
+#define MSDOS_DIR_BITS	5	/* log2(sizeof(struct msdos_dir_entry)) */
+
+/* directory limit */
+#define FAT_MAX_DIR_ENTRIES	(65536)
+#define FAT_MAX_DIR_SIZE	(FAT_MAX_DIR_ENTRIES << MSDOS_DIR_BITS)
+
+#define ATTR_NONE	0	/* no attribute bits */
+#define ATTR_RO		1	/* read-only */
+#define ATTR_HIDDEN	2	/* hidden */
+#define ATTR_SYS	4	/* system */
+#define ATTR_VOLUME	8	/* volume label */
+#define ATTR_DIR	16	/* directory */
+#define ATTR_ARCH	32	/* archived */
+
+/* attribute bits that are copied "as is" */
+#define ATTR_UNUSED	(ATTR_VOLUME | ATTR_ARCH | ATTR_SYS | ATTR_HIDDEN)
+/* bits that are used by the Windows 95/Windows NT extended FAT */
+#define ATTR_EXT	(ATTR_RO | ATTR_HIDDEN | ATTR_SYS | ATTR_VOLUME)
+
+#define CASE_LOWER_BASE	8	/* base is lower case */
+#define CASE_LOWER_EXT	16	/* extension is lower case */
+
+#define DELETED_FLAG	0xe5	/* marks file as deleted when in name[0] */
+#define IS_FREE(n)	(!*(n) || *(const unsigned char *)(n) == DELETED_FLAG)
+
+/* valid file mode bits */
+#define MSDOS_VALID_MODE (S_IFREG | S_IFDIR | S_IRWXU | S_IRWXG | S_IRWXO)
+/* Convert attribute bits and a mask to the UNIX mode. */
+#define MSDOS_MKMODE(a, m) (m & (a & ATTR_RO ? S_IRUGO|S_IXUGO : S_IRWXUGO))
+
+#define MSDOS_NAME	11	/* maximum name length */
+#define MSDOS_LONGNAME	256	/* maximum name length */
+#define MSDOS_SLOTS	21	/* max # of slots for short and long names */
+#define MSDOS_DOT	".          "	/* ".", padded to MSDOS_NAME chars */
+#define MSDOS_DOTDOT	"..         "	/* "..", padded to MSDOS_NAME chars */
+
+/* media of boot sector */
+#define FAT_VALID_MEDIA(x)	((0xF8 <= (x) && (x) <= 0xFF) || (x) == 0xF0)
+#define FAT_FIRST_ENT(s, x)	((MSDOS_SB(s)->fat_bits == 32 ? 0x0FFFFF00 : \
+	MSDOS_SB(s)->fat_bits == 16 ? 0xFF00 : 0xF00) | (x))
+
+/* start of data cluster's entry (number of reserved clusters) */
+#define FAT_START_ENT	2
+
+/* maximum number of clusters */
+#define MAX_FAT12	0xFF4
+#define MAX_FAT16	0xFFF4
+#define MAX_FAT32	0x0FFFFFF6
+#define MAX_FAT(s)	(MSDOS_SB(s)->fat_bits == 32 ? MAX_FAT32 : \
+	MSDOS_SB(s)->fat_bits == 16 ? MAX_FAT16 : MAX_FAT12)
+
+/* bad cluster mark */
+#define BAD_FAT12	0xFF7
+#define BAD_FAT16	0xFFF7
+#define BAD_FAT32	0x0FFFFFF7
+
+/* standard EOF */
+#define EOF_FAT12	0xFFF
+#define EOF_FAT16	0xFFFF
+#define EOF_FAT32	0x0FFFFFFF
+
+#define FAT_ENT_FREE	(0)
+#define FAT_ENT_BAD	(BAD_FAT32)
+#define FAT_ENT_EOF	(EOF_FAT32)
+
+#define FAT_FSINFO_SIG1	0x41615252
+#define FAT_FSINFO_SIG2	0x61417272
+#define IS_FSINFO(x)	(le32_to_cpu((x)->signature1) == FAT_FSINFO_SIG1 \
+			 && le32_to_cpu((x)->signature2) == FAT_FSINFO_SIG2)
+
+/*
+ * ioctl commands
+ */
+#define VFAT_IOCTL_READDIR_BOTH		_IOR('r', 1, struct dirent [2])
+#define VFAT_IOCTL_READDIR_SHORT	_IOR('r', 2, struct dirent [2])
+/* <linux/videotext.h> has used 0x72 ('r') in collision, so skip a few */
+#define FAT_IOCTL_GET_ATTRIBUTES	_IOR('r', 0x10, __u32)
+#define FAT_IOCTL_SET_ATTRIBUTES	_IOW('r', 0x11, __u32)
+
+/*
+ * vfat shortname flags
+ */
+#define VFAT_SFN_DISPLAY_LOWER	0x0001 /* convert to lowercase for display */
+#define VFAT_SFN_DISPLAY_WIN95	0x0002 /* emulate win95 rule for display */
+#define VFAT_SFN_DISPLAY_WINNT	0x0004 /* emulate winnt rule for display */
+#define VFAT_SFN_CREATE_WIN95	0x0100 /* emulate win95 rule for create */
+#define VFAT_SFN_CREATE_WINNT	0x0200 /* emulate winnt rule for create */
+
+struct fat_boot_sector {
+	__u8	ignored[3];	/* Boot strap short or near jump */
+	__u8	system_id[8];	/* Name - can be used to special case
+				   partition manager volumes */
+	__u8	sector_size[2];	/* bytes per logical sector */
+	__u8	sec_per_clus;	/* sectors/cluster */
+	__le16	reserved;	/* reserved sectors */
+	__u8	fats;		/* number of FATs */
+	__u8	dir_entries[2];	/* root directory entries */
+	__u8	sectors[2];	/* number of sectors */
+	__u8	media;		/* media code */
+	__le16	fat_length;	/* sectors/FAT */
+	__le16	secs_track;	/* sectors per track */
+	__le16	heads;		/* number of heads */
+	__le32	hidden;		/* hidden sectors (unused) */
+	__le32	total_sect;	/* number of sectors (if sectors == 0) */
+
+	/* The following fields are only used by FAT32 */
+	__le32	fat32_length;	/* sectors/FAT */
+	__le16	flags;		/* bit 8: fat mirroring, low 4: active fat */
+	__u8	version[2];	/* major, minor filesystem version */
+	__le32	root_cluster;	/* first cluster in root directory */
+	__le16	info_sector;	/* filesystem info sector */
+	__le16	backup_boot;	/* backup boot sector */
+	__le16	reserved2[6];	/* Unused */
+};
+
+struct fat_boot_fsinfo {
+	__le32   signature1;	/* 0x41615252L */
+	__le32   reserved1[120];	/* Nothing as far as I can tell */
+	__le32   signature2;	/* 0x61417272L */
+	__le32   free_clusters;	/* Free cluster count.  -1 if unknown */
+	__le32   next_cluster;	/* Most recently allocated cluster */
+	__le32   reserved2[4];
+};
+
+struct msdos_dir_entry {
+	__u8	name[8],ext[3];	/* name and extension */
+	__u8	attr;		/* attribute bits */
+	__u8    lcase;		/* Case for base and extension */
+	__u8	ctime_cs;	/* Creation time, centiseconds (0-199) */
+	__le16	ctime;		/* Creation time */
+	__le16	cdate;		/* Creation date */
+	__le16	adate;		/* Last access date */
+	__le16	starthi;	/* High 16 bits of cluster in FAT32 */
+	__le16	time,date,start;/* time, date and first cluster */
+	__le32	size;		/* file size (in bytes) */
+};
+
+/* Up to 13 characters of the name */
+struct msdos_dir_slot {
+	__u8    id;		/* sequence number for slot */
+	__u8    name0_4[10];	/* first 5 characters in name */
+	__u8    attr;		/* attribute byte */
+	__u8    reserved;	/* always 0 */
+	__u8    alias_checksum;	/* checksum for 8.3 alias */
+	__u8    name5_10[12];	/* 6 more characters in name */
+	__le16   start;		/* starting cluster number, 0 in long slots */
+	__u8    name11_12[4];	/* last 2 characters in name */
+};
+
+struct fat_slot_info {
+	loff_t i_pos;		/* on-disk position of directory entry */
+	loff_t slot_off;	/* offset for slot or de start */
+	int nr_slots;		/* number of slots + 1(de) in filename */
+	struct msdos_dir_entry *de;
+	struct buffer_head *bh;
+};
+
+#ifdef __KERNEL__
+
+#include <linux/buffer_head.h>
+#include <linux/string.h>
+#include <linux/nls.h>
+#include <linux/fs.h>
+
+struct fat_mount_options {
+	uid_t fs_uid;
+	gid_t fs_gid;
+	unsigned short fs_fmask;
+	unsigned short fs_dmask;
+	unsigned short codepage;  /* Codepage for shortname conversions */
+	char *iocharset;          /* Charset used for filename input/display */
+	unsigned short shortname; /* flags for shortname display/create rule */
+	unsigned char name_check; /* r = relaxed, n = normal, s = strict */
+	unsigned quiet:1,         /* set = fake successful chmods and chowns */
+		 showexec:1,      /* set = only set x bit for com/exe/bat */
+		 sys_immutable:1, /* set = system files are immutable */
+		 dotsOK:1,        /* set = hidden and system files are named '.filename' */
+		 isvfat:1,        /* 0=no vfat long filename support, 1=vfat support */
+		 utf8:1,	  /* Use of UTF8 character set (Default) */
+		 unicode_xlate:1, /* create escape sequences for unhandled Unicode */
+		 numtail:1,       /* Does first alias have a numeric '~1' type tail? */
+		 atari:1,         /* Use Atari GEMDOS variation of MS-DOS fs */
+		 nocase:1;	  /* Does this need case conversion? 0=need case conversion*/
+};
+
+#define FAT_HASH_BITS	8
+#define FAT_HASH_SIZE	(1UL << FAT_HASH_BITS)
+#define FAT_HASH_MASK	(FAT_HASH_SIZE-1)
+
+/*
+ * MS-DOS file system in-core superblock data
+ */
+struct msdos_sb_info {
+	unsigned short sec_per_clus; /* sectors/cluster */
+	unsigned short cluster_bits; /* log2(cluster_size) */
+	unsigned int cluster_size;   /* cluster size */
+	unsigned char fats,fat_bits; /* number of FATs, FAT bits (12 or 16) */
+	unsigned short fat_start;
+	unsigned long fat_length;    /* FAT start & length (sec.) */
+	unsigned long dir_start;
+	unsigned short dir_entries;  /* root dir start & entries */
+	unsigned long data_start;    /* first data sector */
+	unsigned long max_cluster;   /* maximum cluster number */
+	unsigned long root_cluster;  /* first cluster of the root directory */
+	unsigned long fsinfo_sector; /* sector number of FAT32 fsinfo */
+	struct semaphore fat_lock;
+	unsigned int prev_free;      /* previously allocated cluster number */
+	unsigned int free_clusters;  /* -1 if undefined */
+	struct fat_mount_options options;
+	struct nls_table *nls_disk;  /* Codepage used on disk */
+	struct nls_table *nls_io;    /* Charset used for input and display */
+	void *dir_ops;		     /* Opaque; default directory operations */
+	int dir_per_block;	     /* dir entries per block */
+	int dir_per_block_bits;	     /* log2(dir_per_block) */
+
+	int fatent_shift;
+	struct fatent_operations *fatent_ops;
+
+	spinlock_t inode_hash_lock;
+	struct hlist_head inode_hashtable[FAT_HASH_SIZE];
+};
+
+#define FAT_CACHE_VALID	0	/* special case for valid cache */
+
+/*
+ * MS-DOS file system inode data in memory
+ */
+struct msdos_inode_info {
+	spinlock_t cache_lru_lock;
+	struct list_head cache_lru;
+	int nr_caches;
+	/* for avoiding the race between fat_free() and fat_get_cluster() */
+	unsigned int cache_valid_id;
+
+	loff_t mmu_private;
+	int i_start;		/* first cluster or 0 */
+	int i_logstart;		/* logical first cluster */
+	int i_attrs;		/* unused attribute bits */
+	loff_t i_pos;		/* on-disk position of directory entry or 0 */
+	struct hlist_node i_fat_hash;	/* hash by i_location */
+	struct inode vfs_inode;
+};
+
+static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+
+static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)
+{
+	return container_of(inode, struct msdos_inode_info, vfs_inode);
+}
+
+/* Return the FAT attribute byte for this inode */
+static inline u8 fat_attr(struct inode *inode)
+{
+	return ((inode->i_mode & S_IWUGO) ? ATTR_NONE : ATTR_RO) |
+		(S_ISDIR(inode->i_mode) ? ATTR_DIR : ATTR_NONE) |
+		MSDOS_I(inode)->i_attrs;
+}
+
+static inline unsigned char fat_checksum(const __u8 *name)
+{
+	unsigned char s = name[0];
+	s = (s<<7) + (s>>1) + name[1];	s = (s<<7) + (s>>1) + name[2];
+	s = (s<<7) + (s>>1) + name[3];	s = (s<<7) + (s>>1) + name[4];
+	s = (s<<7) + (s>>1) + name[5];	s = (s<<7) + (s>>1) + name[6];
+	s = (s<<7) + (s>>1) + name[7];	s = (s<<7) + (s>>1) + name[8];
+	s = (s<<7) + (s>>1) + name[9];	s = (s<<7) + (s>>1) + name[10];
+	return s;
+}
+
+static inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)
+{
+	return ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus
+		+ sbi->data_start;
+}
+
+static inline void fat16_towchar(wchar_t *dst, const __u8 *src, size_t len)
+{
+#ifdef __BIG_ENDIAN
+	while (len--) {
+		*dst++ = src[0] | (src[1] << 8);
+		src += 2;
+	}
+#else
+	memcpy(dst, src, len * 2);
+#endif
+}
+
+static inline void fatwchar_to16(__u8 *dst, const wchar_t *src, size_t len)
+{
+#ifdef __BIG_ENDIAN
+	while (len--) {
+		dst[0] = *src & 0x00FF;
+		dst[1] = (*src & 0xFF00) >> 8;
+		dst += 2;
+		src++;
+	}
+#else
+	memcpy(dst, src, len * 2);
+#endif
+}
+
+/* fat/cache.c */
+extern void fat_cache_inval_inode(struct inode *inode);
+extern int fat_get_cluster(struct inode *inode, int cluster,
+			   int *fclus, int *dclus);
+extern int fat_bmap(struct inode *inode, sector_t sector, sector_t *phys);
+
+/* fat/dir.c */
+extern struct file_operations fat_dir_operations;
+extern int fat_search_long(struct inode *inode, const unsigned char *name,
+			   int name_len, struct fat_slot_info *sinfo);
+extern int fat_dir_empty(struct inode *dir);
+extern int fat_subdirs(struct inode *dir);
+extern int fat_scan(struct inode *dir, const unsigned char *name,
+		    struct fat_slot_info *sinfo);
+extern int fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,
+				struct msdos_dir_entry **de, loff_t *i_pos);
+extern int fat_alloc_new_dir(struct inode *dir, struct timespec *ts);
+extern int fat_add_entries(struct inode *dir, void *slots, int nr_slots,
+			   struct fat_slot_info *sinfo);
+extern int fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo);
+
+/* fat/fatent.c */
+struct fat_entry {
+	int entry;
+	union {
+		u8 *ent12_p[2];
+		__le16 *ent16_p;
+		__le32 *ent32_p;
+	} u;
+	int nr_bhs;
+	struct buffer_head *bhs[2];
+};
+
+static inline void fatent_init(struct fat_entry *fatent)
+{
+	fatent->nr_bhs = 0;
+	fatent->entry = 0;
+	fatent->u.ent32_p = NULL;
+	fatent->bhs[0] = fatent->bhs[1] = NULL;
+}
+
+static inline void fatent_set_entry(struct fat_entry *fatent, int entry)
+{
+	fatent->entry = entry;
+	fatent->u.ent32_p = NULL;
+}
+
+static inline void fatent_brelse(struct fat_entry *fatent)
+{
+	int i;
+	fatent->u.ent32_p = NULL;
+	for (i = 0; i < fatent->nr_bhs; i++)
+		brelse(fatent->bhs[i]);
+	fatent->nr_bhs = 0;
+	fatent->bhs[0] = fatent->bhs[1] = NULL;
+}
+
+extern void fat_ent_access_init(struct super_block *sb);
+extern int fat_ent_read(struct inode *inode, struct fat_entry *fatent,
+			int entry);
+extern int fat_ent_write(struct inode *inode, struct fat_entry *fatent,
+			 int new, int wait);
+extern int fat_alloc_clusters(struct inode *inode, int *cluster,
+			      int nr_cluster);
+extern int fat_free_clusters(struct inode *inode, int cluster);
+extern int fat_count_free_clusters(struct super_block *sb);
+
+/* fat/file.c */
+extern int fat_generic_ioctl(struct inode *inode, struct file *filp,
+			     unsigned int cmd, unsigned long arg);
+extern struct file_operations fat_file_operations;
+extern struct inode_operations fat_file_inode_operations;
+extern int fat_notify_change(struct dentry * dentry, struct iattr * attr);
+extern void fat_truncate(struct inode *inode);
+
+/* fat/inode.c */
+extern void fat_attach(struct inode *inode, loff_t i_pos);
+extern void fat_detach(struct inode *inode);
+extern struct inode *fat_iget(struct super_block *sb, loff_t i_pos);
+extern struct inode *fat_build_inode(struct super_block *sb,
+			struct msdos_dir_entry *de, loff_t i_pos);
+extern int fat_sync_inode(struct inode *inode);
+extern int fat_fill_super(struct super_block *sb, void *data, int silent,
+			struct inode_operations *fs_dir_inode_ops, int isvfat);
+
+/* fat/misc.c */
+extern void fat_fs_panic(struct super_block *s, const char *fmt, ...);
+extern void fat_clusters_flush(struct super_block *sb);
+extern int fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster);
+extern int date_dos2unix(unsigned short time, unsigned short date);
+extern void fat_date_unix2dos(int unix_date, __le16 *time, __le16 *date);
+extern int fat_sync_bhs(struct buffer_head **bhs, int nr_bhs);
+
+#endif /* __KERNEL__ */
+
+#endif
diff -pruwN busybox-1.01/include2/linux/param.h busybox-1.01-livebox/include2/linux/param.h
--- busybox-1.01/include2/linux/param.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/param.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef _LINUX_PARAM_H
+#define _LINUX_PARAM_H
+
+#include <asm/param.h>
+
+#endif
diff -pruwN busybox-1.01/include2/linux/posix_types.h busybox-1.01-livebox/include2/linux/posix_types.h
--- busybox-1.01/include2/linux/posix_types.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/posix_types.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,49 @@
+#ifndef _LINUX_POSIX_TYPES_H
+#define _LINUX_POSIX_TYPES_H
+
+#include <linux/stddef.h>
+
+/*
+ * This allows for 1024 file descriptors: if NR_OPEN is ever grown
+ * beyond that you'll have to change this too. But 1024 fd's seem to be
+ * enough even for such "real" unices like OSF/1, so hopefully this is
+ * one limit that doesn't have to be changed [again].
+ *
+ * Note that POSIX wants the FD_CLEAR(fd,fdsetp) defines to be in
+ * <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
+ * place for them. Solved by having dummy defines in <sys/time.h>.
+ */
+
+/*
+ * Those macros may have been defined in <gnu/types.h>. But we always
+ * use the ones here. 
+ */
+#undef __NFDBITS
+#define __NFDBITS	(8 * sizeof(unsigned long))
+
+#undef __FD_SETSIZE
+#define __FD_SETSIZE	1024
+
+#undef __FDSET_LONGS
+#define __FDSET_LONGS	(__FD_SETSIZE/__NFDBITS)
+
+#undef __FDELT
+#define	__FDELT(d)	((d) / __NFDBITS)
+
+#undef __FDMASK
+#define	__FDMASK(d)	(1UL << ((d) % __NFDBITS))
+
+typedef struct {
+	unsigned long fds_bits [__FDSET_LONGS];
+} __kernel_fd_set;
+
+/* Type of a signal handler.  */
+typedef void (*__kernel_sighandler_t)(int);
+
+/* Type of a SYSV IPC key.  */
+typedef int __kernel_key_t;
+typedef int __kernel_mqd_t;
+
+#include <asm/posix_types.h>
+
+#endif /* _LINUX_POSIX_TYPES_H */
diff -pruwN busybox-1.01/include2/linux/rcuref.h busybox-1.01-livebox/include2/linux/rcuref.h
--- busybox-1.01/include2/linux/rcuref.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/rcuref.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,220 @@
+/*
+ * rcuref.h
+ *
+ * Reference counting for elements of lists/arrays protected by
+ * RCU.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2005
+ *
+ * Author: Dipankar Sarma <dipankar@in.ibm.com>
+ *	   Ravikiran Thirumalai <kiran_th@gmail.com>
+ *
+ * See Documentation/RCU/rcuref.txt for detailed user guide.
+ *
+ */
+
+#ifndef _RCUREF_H_
+#define _RCUREF_H_
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+
+/*
+ * These APIs work on traditional atomic_t counters used in the
+ * kernel for reference counting. Under special circumstances
+ * where a lock-free get() operation races with a put() operation
+ * these APIs can be used. See Documentation/RCU/rcuref.txt.
+ */
+
+#ifdef __HAVE_ARCH_CMPXCHG
+
+/**
+ * rcuref_inc - increment refcount for object.
+ * @rcuref: reference counter in the object in question.
+ *
+ * This should be used only for objects where we use RCU and
+ * use the rcuref_inc_lf() api to acquire a reference
+ * in a lock-free reader-side critical section.
+ */
+static inline void rcuref_inc(atomic_t *rcuref)
+{
+	atomic_inc(rcuref);
+}
+
+/**
+ * rcuref_dec - decrement refcount for object.
+ * @rcuref: reference counter in the object in question.
+ *
+ * This should be used only for objects where we use RCU and
+ * use the rcuref_inc_lf() api to acquire a reference
+ * in a lock-free reader-side critical section.
+ */
+static inline void rcuref_dec(atomic_t *rcuref)
+{
+	atomic_dec(rcuref);
+}
+
+/**
+ * rcuref_dec_and_test - decrement refcount for object and test
+ * @rcuref: reference counter in the object.
+ * @release: pointer to the function that will clean up the object
+ *	     when the last reference to the object is released.
+ *	     This pointer is required.
+ *
+ * Decrement the refcount, and if 0, return 1. Else return 0.
+ *
+ * This should be used only for objects where we use RCU and
+ * use the rcuref_inc_lf() api to acquire a reference
+ * in a lock-free reader-side critical section.
+ */
+static inline int rcuref_dec_and_test(atomic_t *rcuref)
+{
+	return atomic_dec_and_test(rcuref);
+}
+
+/*
+ * cmpxchg is needed on UP too, if deletions to the list/array can happen
+ * in interrupt context.
+ */
+
+/**
+ * rcuref_inc_lf - Take reference to an object in a read-side
+ * critical section protected by RCU.
+ * @rcuref: reference counter in the object in question.
+ *
+ * Try and increment the refcount by 1.  The increment might fail if
+ * the reference counter has been through a 1 to 0 transition and
+ * is no longer part of the lock-free list.
+ * Returns non-zero on successful increment and zero otherwise.
+ */
+static inline int rcuref_inc_lf(atomic_t *rcuref)
+{
+	int c, old;
+	c = atomic_read(rcuref);
+	while (c && (old = cmpxchg(&rcuref->counter, c, c + 1)) != c)
+		c = old;
+	return c;
+}
+
+#else				/* !__HAVE_ARCH_CMPXCHG */
+
+extern spinlock_t __rcuref_hash[];
+
+/*
+ * Use a hash table of locks to protect the reference count
+ * since cmpxchg is not available in this arch.
+ */
+#ifdef	CONFIG_SMP
+#define RCUREF_HASH_SIZE	4
+#define RCUREF_HASH(k) \
+	(&__rcuref_hash[(((unsigned long)k)>>8) & (RCUREF_HASH_SIZE-1)])
+#else
+#define	RCUREF_HASH_SIZE	1
+#define RCUREF_HASH(k) 	&__rcuref_hash[0]
+#endif				/* CONFIG_SMP */
+
+/**
+ * rcuref_inc - increment refcount for object.
+ * @rcuref: reference counter in the object in question.
+ *
+ * This should be used only for objects where we use RCU and
+ * use the rcuref_inc_lf() api to acquire a reference in a lock-free
+ * reader-side critical section.
+ */
+static inline void rcuref_inc(atomic_t *rcuref)
+{
+	unsigned long flags;
+	spin_lock_irqsave(RCUREF_HASH(rcuref), flags);
+	rcuref->counter += 1;
+	spin_unlock_irqrestore(RCUREF_HASH(rcuref), flags);
+}
+
+/**
+ * rcuref_dec - decrement refcount for object.
+ * @rcuref: reference counter in the object in question.
+ *
+ * This should be used only for objects where we use RCU and
+ * use the rcuref_inc_lf() api to acquire a reference in a lock-free
+ * reader-side critical section.
+ */
+static inline void rcuref_dec(atomic_t *rcuref)
+{
+	unsigned long flags;
+	spin_lock_irqsave(RCUREF_HASH(rcuref), flags);
+	rcuref->counter -= 1;
+	spin_unlock_irqrestore(RCUREF_HASH(rcuref), flags);
+}
+
+/**
+ * rcuref_dec_and_test - decrement refcount for object and test
+ * @rcuref: reference counter in the object.
+ * @release: pointer to the function that will clean up the object
+ *	     when the last reference to the object is released.
+ *	     This pointer is required.
+ *
+ * Decrement the refcount, and if 0, return 1. Else return 0.
+ *
+ * This should be used only for objects where we use RCU and
+ * use the rcuref_inc_lf() api to acquire a reference in a lock-free
+ * reader-side critical section.
+ */
+static inline int rcuref_dec_and_test(atomic_t *rcuref)
+{
+	unsigned long flags;
+	spin_lock_irqsave(RCUREF_HASH(rcuref), flags);
+	rcuref->counter--;
+	if (!rcuref->counter) {
+		spin_unlock_irqrestore(RCUREF_HASH(rcuref), flags);
+		return 1;
+	} else {
+		spin_unlock_irqrestore(RCUREF_HASH(rcuref), flags);
+		return 0;
+	}
+}
+
+/**
+ * rcuref_inc_lf - Take reference to an object of a lock-free collection
+ * by traversing a lock-free list/array.
+ * @rcuref: reference counter in the object in question.
+ *
+ * Try and increment the refcount by 1.  The increment might fail if
+ * the reference counter has been through a 1 to 0 transition and
+ * object is no longer part of the lock-free list.
+ * Returns non-zero on successful increment and zero otherwise.
+ */
+static inline int rcuref_inc_lf(atomic_t *rcuref)
+{
+	int ret;
+	unsigned long flags;
+	spin_lock_irqsave(RCUREF_HASH(rcuref), flags);
+	if (rcuref->counter)
+		ret = rcuref->counter++;
+	else
+		ret = 0;
+	spin_unlock_irqrestore(RCUREF_HASH(rcuref), flags);
+	return ret;
+}
+
+
+#endif /* !__HAVE_ARCH_CMPXCHG */
+
+#endif /* __KERNEL__ */
+#endif /* _RCUREF_H_ */
diff -pruwN busybox-1.01/include2/linux/stddef.h busybox-1.01-livebox/include2/linux/stddef.h
--- busybox-1.01/include2/linux/stddef.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/stddef.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,20 @@
+#ifndef _LINUX_STDDEF_H
+#define _LINUX_STDDEF_H
+
+#include <linux/compiler.h>
+
+#undef NULL
+#if defined(__cplusplus)
+#define NULL 0
+#else
+#define NULL ((void *)0)
+#endif
+
+#undef offsetof
+#ifdef __compiler_offsetof
+#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
+#else
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+#endif
diff -pruwN busybox-1.01/include2/linux/types.h busybox-1.01-livebox/include2/linux/types.h
--- busybox-1.01/include2/linux/types.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/types.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,184 @@
+#ifndef _LINUX_TYPES_H
+#define _LINUX_TYPES_H
+
+#ifdef	__KERNEL__
+#include <linux/config.h>
+
+#define BITS_TO_LONGS(bits) \
+	(((bits)+BITS_PER_LONG-1)/BITS_PER_LONG)
+#define DECLARE_BITMAP(name,bits) \
+	unsigned long name[BITS_TO_LONGS(bits)]
+#endif
+
+#include <linux/posix_types.h>
+#include <asm/types.h>
+
+#ifndef __KERNEL_STRICT_NAMES
+
+typedef __u32 __kernel_dev_t;
+
+typedef __kernel_fd_set		fd_set;
+typedef __kernel_dev_t		dev_t;
+typedef __kernel_ino_t		ino_t;
+typedef __kernel_mode_t		mode_t;
+typedef __kernel_nlink_t	nlink_t;
+typedef __kernel_off_t		off_t;
+typedef __kernel_pid_t		pid_t;
+typedef __kernel_daddr_t	daddr_t;
+typedef __kernel_key_t		key_t;
+typedef __kernel_suseconds_t	suseconds_t;
+typedef __kernel_timer_t	timer_t;
+typedef __kernel_clockid_t	clockid_t;
+typedef __kernel_mqd_t		mqd_t;
+
+#ifdef __KERNEL__
+typedef __kernel_uid32_t	uid_t;
+typedef __kernel_gid32_t	gid_t;
+typedef __kernel_uid16_t        uid16_t;
+typedef __kernel_gid16_t        gid16_t;
+
+#ifdef CONFIG_UID16
+/* This is defined by include/asm-{arch}/posix_types.h */
+typedef __kernel_old_uid_t	old_uid_t;
+typedef __kernel_old_gid_t	old_gid_t;
+#endif /* CONFIG_UID16 */
+
+/* libc5 includes this file to define uid_t, thus uid_t can never change
+ * when it is included by non-kernel code
+ */
+#else
+typedef __kernel_uid_t		uid_t;
+typedef __kernel_gid_t		gid_t;
+#endif /* __KERNEL__ */
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __kernel_loff_t		loff_t;
+#endif
+
+/*
+ * The following typedefs are also protected by individual ifdefs for
+ * historical reasons:
+ */
+#ifndef _SIZE_T
+#define _SIZE_T
+typedef __kernel_size_t		size_t;
+#endif
+
+#ifndef _SSIZE_T
+#define _SSIZE_T
+typedef __kernel_ssize_t	ssize_t;
+#endif
+
+#ifndef _PTRDIFF_T
+#define _PTRDIFF_T
+typedef __kernel_ptrdiff_t	ptrdiff_t;
+#endif
+
+#ifndef _TIME_T
+#define _TIME_T
+typedef __kernel_time_t		time_t;
+#endif
+
+#ifndef _CLOCK_T
+#define _CLOCK_T
+typedef __kernel_clock_t	clock_t;
+#endif
+
+#ifndef _CADDR_T
+#define _CADDR_T
+typedef __kernel_caddr_t	caddr_t;
+#endif
+
+/* bsd */
+typedef unsigned char		u_char;
+typedef unsigned short		u_short;
+typedef unsigned int		u_int;
+typedef unsigned long		u_long;
+
+/* sysv */
+typedef unsigned char		unchar;
+typedef unsigned short		ushort;
+typedef unsigned int		uint;
+typedef unsigned long		ulong;
+
+#ifndef __BIT_TYPES_DEFINED__
+#define __BIT_TYPES_DEFINED__
+
+typedef		__u8		u_int8_t;
+typedef		__s8		int8_t;
+typedef		__u16		u_int16_t;
+typedef		__s16		int16_t;
+typedef		__u32		u_int32_t;
+typedef		__s32		int32_t;
+
+#endif /* !(__BIT_TYPES_DEFINED__) */
+
+typedef		__u8		uint8_t;
+typedef		__u16		uint16_t;
+typedef		__u32		uint32_t;
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef		__u64		uint64_t;
+typedef		__u64		u_int64_t;
+typedef		__s64		int64_t;
+#endif
+
+/* this is a special 64bit data type that is 8-byte aligned */
+#define aligned_u64 unsigned long long __attribute__((aligned(8)))
+
+/*
+ * The type used for indexing onto a disc or disc partition.
+ * If required, asm/types.h can override it and define
+ * HAVE_SECTOR_T
+ */
+#ifndef HAVE_SECTOR_T
+typedef unsigned long sector_t;
+#endif
+
+/*
+ * The type of an index into the pagecache.  Use a #define so asm/types.h
+ * can override it.
+ */
+#ifndef pgoff_t
+#define pgoff_t unsigned long
+#endif
+
+#endif /* __KERNEL_STRICT_NAMES */
+
+/*
+ * Below are truly Linux-specific types that should never collide with
+ * any application/library that wants linux/types.h.
+ */
+
+#ifdef __CHECKER__
+#define __bitwise__ __attribute__((bitwise))
+#else
+#define __bitwise__
+#endif
+#ifdef __CHECK_ENDIAN__
+#define __bitwise __bitwise__
+#else
+#define __bitwise
+#endif
+
+typedef __u16 __bitwise __le16;
+typedef __u16 __bitwise __be16;
+typedef __u32 __bitwise __le32;
+typedef __u32 __bitwise __be32;
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __u64 __bitwise __le64;
+typedef __u64 __bitwise __be64;
+#endif
+
+#ifdef __KERNEL__
+typedef unsigned __bitwise__ gfp_t;
+#endif
+
+struct ustat {
+	__kernel_daddr_t	f_tfree;
+	__kernel_ino_t		f_tinode;
+	char			f_fname[6];
+	char			f_fpack[6];
+};
+
+#endif /* _LINUX_TYPES_H */
diff -pruwN busybox-1.01/include2/linux/version.h busybox-1.01-livebox/include2/linux/version.h
--- busybox-1.01/include2/linux/version.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/linux/version.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,3 @@
+#define UTS_RELEASE "2.6.15"
+#define LINUX_VERSION_CODE 132623
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff -pruwN busybox-1.01/include2/memory.h busybox-1.01-livebox/include2/memory.h
--- busybox-1.01/include2/memory.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/memory.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,34 @@
+/* Copyright (C) 1991, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * SVID
+ */
+
+#ifndef	_MEMORY_H
+#define	_MEMORY_H	1
+
+#include <features.h>
+
+
+#ifndef	_STRING_H
+# include <string.h>
+#endif	/* string.h  */
+
+
+#endif	/* memory.h  */
diff -pruwN busybox-1.01/include2/mntent.h busybox-1.01-livebox/include2/mntent.h
--- busybox-1.01/include2/mntent.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/mntent.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,98 @@
+/* Utilities for reading/writing fstab, mtab, etc.
+   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_MNTENT_H
+#define	_MNTENT_H	1
+
+#include <features.h>
+#define __need_FILE
+#include <stdio.h>
+#include <paths.h>
+
+
+/* File listing canonical interesting mount points.  */
+#define	MNTTAB		_PATH_MNTTAB	/* Deprecated alias.  */
+
+/* File listing currently active mount points.  */
+#define	MOUNTED		_PATH_MOUNTED	/* Deprecated alias.  */
+
+
+/* General filesystem types.  */
+#define MNTTYPE_IGNORE	"ignore"	/* Ignore this entry.  */
+#define MNTTYPE_NFS	"nfs"		/* Network file system.  */
+#define MNTTYPE_SWAP	"swap"		/* Swap device.  */
+
+
+/* Generic mount options.  */
+#define MNTOPT_DEFAULTS	"defaults"	/* Use all default options.  */
+#define MNTOPT_RO	"ro"		/* Read only.  */
+#define MNTOPT_RW	"rw"		/* Read/write.  */
+#define MNTOPT_SUID	"suid"		/* Set uid allowed.  */
+#define MNTOPT_NOSUID	"nosuid"	/* No set uid allowed.  */
+#define MNTOPT_NOAUTO	"noauto"	/* Do not auto mount.  */
+
+
+__BEGIN_DECLS
+
+/* Structure describing a mount table entry.  */
+struct mntent
+  {
+    char *mnt_fsname;		/* Device or server for filesystem.  */
+    char *mnt_dir;		/* Directory mounted on.  */
+    char *mnt_type;		/* Type of filesystem: ufs, nfs, etc.  */
+    char *mnt_opts;		/* Comma-separated options for fs.  */
+    int mnt_freq;		/* Dump frequency (in days).  */
+    int mnt_passno;		/* Pass number for `fsck'.  */
+  };
+
+
+/* Prepare to begin reading and/or writing mount table entries from the
+   beginning of FILE.  MODE is as for `fopen'.  */
+extern FILE *setmntent (__const char *__file, __const char *__mode) __THROW;
+
+/* Read one mount table entry from STREAM.  Returns a pointer to storage
+   reused on the next call, or null for EOF or error (use feof/ferror to
+   check).  */
+extern struct mntent *getmntent (FILE *__stream) __THROW;
+
+#ifdef __USE_MISC
+/* Reentrant version of the above function.  */
+extern struct mntent *getmntent_r (FILE *__restrict __stream,
+				   struct mntent *__restrict __result,
+				   char *__restrict __buffer,
+				   int __bufsize) __THROW;
+#endif
+
+/* Write the mount table entry described by MNT to STREAM.
+   Return zero on success, nonzero on failure.  */
+extern int addmntent (FILE *__restrict __stream,
+		      __const struct mntent *__restrict __mnt) __THROW;
+
+/* Close a stream opened with `setmntent'.  */
+extern int endmntent (FILE *__stream) __THROW;
+
+/* Search MNT->mnt_opts for an option matching OPT.
+   Returns the address of the substring, or null if none found.  */
+extern char *hasmntopt (__const struct mntent *__mnt,
+			__const char *__opt) __THROW;
+
+
+__END_DECLS
+
+#endif	/* mntent.h */
diff -pruwN busybox-1.01/include2/net/ethernet.h busybox-1.01-livebox/include2/net/ethernet.h
--- busybox-1.01/include2/net/ethernet.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/net/ethernet.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,76 @@
+/* Copyright (C) 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Based on the FreeBSD version of this file. Curiously, that file
+   lacks a copyright in the header. */
+
+#ifndef __NET_ETHERNET_H
+#define __NET_ETHERNET_H 1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <linux/if_ether.h>     /* IEEE 802.3 Ethernet constants */
+
+__BEGIN_DECLS
+
+/* This is a name for the 48 bit ethernet address available on many
+   systems.  */
+struct ether_addr
+{
+  u_int8_t ether_addr_octet[ETH_ALEN];
+} __attribute__ ((__packed__));
+
+/* 10Mb/s ethernet header */
+struct ether_header
+{
+  u_int8_t  ether_dhost[ETH_ALEN];	/* destination eth addr	*/
+  u_int8_t  ether_shost[ETH_ALEN];	/* source ether addr	*/
+  u_int16_t ether_type;		        /* packet type ID field	*/
+} __attribute__ ((__packed__));
+
+/* Ethernet protocol ID's */
+#define	ETHERTYPE_PUP		0x0200          /* Xerox PUP */
+#define	ETHERTYPE_IP		0x0800		/* IP */
+#define	ETHERTYPE_ARP		0x0806		/* Address resolution */
+#define	ETHERTYPE_REVARP	0x8035		/* Reverse ARP */
+
+#define	ETHER_ADDR_LEN	ETH_ALEN                 /* size of ethernet addr */
+#define	ETHER_TYPE_LEN	2                        /* bytes in type field */
+#define	ETHER_CRC_LEN	4                        /* bytes in CRC field */
+#define	ETHER_HDR_LEN	ETH_HLEN                 /* total octets in header */
+#define	ETHER_MIN_LEN	(ETH_ZLEN + ETHER_CRC_LEN) /* min packet length */
+#define	ETHER_MAX_LEN	(ETH_FRAME_LEN + ETHER_CRC_LEN) /* max packet length */
+
+/* make sure ethenet length is valid */
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+/*
+ * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
+ * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
+ * by an ETHER type (as given above) and then the (variable-length) header.
+ */
+#define	ETHERTYPE_TRAIL		0x1000		/* Trailer packet */
+#define	ETHERTYPE_NTRAILER	16
+
+#define	ETHERMTU	ETH_DATA_LEN
+#define	ETHERMIN	(ETHER_MIN_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
+
+__END_DECLS
+
+#endif	/* net/ethernet.h */
diff -pruwN busybox-1.01/include2/net/if_arp.h busybox-1.01-livebox/include2/net/if_arp.h
--- busybox-1.01/include2/net/if_arp.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/net/if_arp.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,176 @@
+/* Definitions for Address Resolution Protocol.
+   Copyright (C) 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Based on the 4.4BSD and Linux version of this file.  */
+
+#ifndef _NET_IF_ARP_H
+
+#define _NET_IF_ARP_H 1
+#include <sys/cdefs.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+__BEGIN_DECLS
+
+/* Some internals from deep down in the kernel.  */
+#define MAX_ADDR_LEN	7
+
+
+/* This structure defines an ethernet arp header.  */
+
+/* ARP protocol opcodes. */
+#define	ARPOP_REQUEST	1		/* ARP request.  */
+#define	ARPOP_REPLY	2		/* ARP reply.  */
+#define	ARPOP_RREQUEST	3		/* RARP request.  */
+#define	ARPOP_RREPLY	4		/* RARP reply.  */
+#define	ARPOP_InREQUEST	8		/* InARP request.  */
+#define	ARPOP_InREPLY	9		/* InARP reply.  */
+#define	ARPOP_NAK	10		/* (ATM)ARP NAK.  */
+
+/* See RFC 826 for protocol description.  ARP packets are variable
+   in size; the arphdr structure defines the fixed-length portion.
+   Protocol type values are the same as those for 10 Mb/s Ethernet.
+   It is followed by the variable-sized fields ar_sha, arp_spa,
+   arp_tha and arp_tpa in that order, according to the lengths
+   specified.  Field names used correspond to RFC 826.  */
+
+struct arphdr
+  {
+    unsigned short int ar_hrd;		/* Format of hardware address.  */
+    unsigned short int ar_pro;		/* Format of protocol address.  */
+    unsigned char ar_hln;		/* Length of hardware address.  */
+    unsigned char ar_pln;		/* Length of protocol address.  */
+    unsigned short int ar_op;		/* ARP opcode (command).  */
+#if 0
+    /* Ethernet looks like this : This bit is variable sized
+       however...  */
+    unsigned char __ar_sha[ETH_ALEN];	/* Sender hardware address.  */
+    unsigned char __ar_sip[4];		/* Sender IP address.  */
+    unsigned char __ar_tha[ETH_ALEN];	/* Target hardware address.  */
+    unsigned char __ar_tip[4];		/* Target IP address.  */
+#endif
+  };
+
+
+/* ARP protocol HARDWARE identifiers. */
+#define ARPHRD_NETROM	0		/* From KA9Q: NET/ROM pseudo. */
+#define ARPHRD_ETHER 	1		/* Ethernet 10/100Mbps.  */
+#define	ARPHRD_EETHER	2		/* Experimental Ethernet.  */
+#define	ARPHRD_AX25	3		/* AX.25 Level 2.  */
+#define	ARPHRD_PRONET	4		/* PROnet token ring.  */
+#define	ARPHRD_CHAOS	5		/* Chaosnet.  */
+#define	ARPHRD_IEEE802	6		/* IEEE 802.2 Ethernet/TR/TB.  */
+#define	ARPHRD_ARCNET	7		/* ARCnet.  */
+#define	ARPHRD_APPLETLK	8		/* APPLEtalk.  */
+#define	ARPHRD_DLCI	15		/* Frame Relay DLCI.  */
+#define	ARPHRD_ATM	19		/* ATM.  */
+#define	ARPHRD_METRICOM	23		/* Metricom STRIP (new IANA id).  */
+#define ARPHRD_IEEE1394	24		/* IEEE 1394 IPv4 - RFC 2734.  */
+#define ARPHRD_EUI64		27		/* EUI-64.  */
+#define ARPHRD_INFINIBAND	32		/* InfiniBand.  */
+
+/* Dummy types for non ARP hardware */
+#define ARPHRD_SLIP	256
+#define ARPHRD_CSLIP	257
+#define ARPHRD_SLIP6	258
+#define ARPHRD_CSLIP6	259
+#define ARPHRD_RSRVD	260		/* Notional KISS type.  */
+#define ARPHRD_ADAPT	264
+#define ARPHRD_ROSE	270
+#define ARPHRD_X25	271		/* CCITT X.25.  */
+#define ARPHDR_HWX25	272		/* Boards with X.25 in firmware.  */
+#define ARPHRD_PPP	512
+#define ARPHRD_CISCO	513		/* Cisco HDLC.  */
+#define ARPHRD_HDLC	ARPHRD_CISCO
+#define ARPHRD_LAPB	516		/* LAPB.  */
+#define ARPHRD_DDCMP	517		/* Digital's DDCMP.  */
+#define	ARPHRD_RAWHDLC	518		/* Raw HDLC.  */
+
+#define ARPHRD_TUNNEL	768		/* IPIP tunnel.  */
+#define ARPHRD_TUNNEL6	769		/* IPIP6 tunnel.  */
+#define ARPHRD_FRAD	770             /* Frame Relay Access Device.  */
+#define ARPHRD_SKIP	771		/* SKIP vif.  */
+#define ARPHRD_LOOPBACK	772		/* Loopback device.  */
+#define ARPHRD_LOCALTLK 773		/* Localtalk device.  */
+#define ARPHRD_FDDI	774		/* Fiber Distributed Data Interface. */
+#define ARPHRD_BIF	775             /* AP1000 BIF.  */
+#define ARPHRD_SIT	776		/* sit0 device - IPv6-in-IPv4.  */
+#define ARPHRD_IPDDP	777		/* IP-in-DDP tunnel.  */
+#define ARPHRD_IPGRE	778		/* GRE over IP.  */
+#define ARPHRD_PIMREG	779		/* PIMSM register interface.  */
+#define ARPHRD_HIPPI	780		/* High Performance Parallel I'face. */
+#define ARPHRD_ASH	781		/* (Nexus Electronics) Ash.  */
+#define ARPHRD_ECONET	782		/* Acorn Econet.  */
+#define ARPHRD_IRDA	783		/* Linux-IrDA.  */
+#define ARPHRD_FCPP	784		/* Point to point fibrechanel.  */
+#define ARPHRD_FCAL	785		/* Fibrechanel arbitrated loop.  */
+#define ARPHRD_FCPL	786		/* Fibrechanel public loop.  */
+#define ARPHRD_FCFABRIC 787		/* Fibrechanel fabric.  */
+#define ARPHRD_IEEE802_TR 800		/* Magic type ident for TR.  */
+#define ARPHRD_IEEE80211 801		/* IEEE 802.11.  */
+
+/* ARP ioctl request.  */
+struct arpreq
+  {
+    struct sockaddr arp_pa;		/* Protocol address.  */
+    struct sockaddr arp_ha;		/* Hardware address.  */
+    int arp_flags;			/* Flags.  */
+    struct sockaddr arp_netmask;	/* Netmask (only for proxy arps).  */
+    char arp_dev[16];
+  };
+
+struct arpreq_old
+  {
+    struct sockaddr arp_pa;		/* Protocol address.  */
+    struct sockaddr arp_ha;		/* Hardware address.  */
+    int arp_flags;			/* Flags.  */
+    struct sockaddr arp_netmask;	/* Netmask (only for proxy arps).  */
+  };
+
+/* ARP Flag values.  */
+#define ATF_COM		0x02		/* Completed entry (ha valid).  */
+#define	ATF_PERM	0x04		/* Permanent entry.  */
+#define	ATF_PUBL	0x08		/* Publish entry.  */
+#define	ATF_USETRAILERS	0x10		/* Has requested trailers.  */
+#define ATF_NETMASK     0x20            /* Want to use a netmask (only
+					   for proxy entries).  */
+#define ATF_DONTPUB	0x40		/* Don't answer this addresses.  */
+#define ATF_MAGIC	0x80		/* Automatically added entry.  */
+
+
+/* Support for the user space arp daemon, arpd.  */
+#define ARPD_UPDATE	0x01
+#define ARPD_LOOKUP	0x02
+#define ARPD_FLUSH	0x03
+
+struct arpd_request
+  {
+    unsigned short int req;		/* Request type.  */
+    u_int32_t ip;			/* IP address of entry.  */
+    unsigned long int dev;		/* Device entry is tied to.  */
+    unsigned long int stamp;
+    unsigned long int updated;
+    unsigned char ha[MAX_ADDR_LEN];	/* Hardware address.  */
+  };
+
+__END_DECLS
+
+#endif	/* net/if_arp.h */
diff -pruwN busybox-1.01/include2/net/if.h busybox-1.01-livebox/include2/net/if.h
--- busybox-1.01/include2/net/if.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/net/if.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,203 @@
+/* net/if.h -- declarations for inquiring about network interfaces
+   Copyright (C) 1997,98,99,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _NET_IF_H
+#define _NET_IF_H	1
+
+#include <features.h>
+
+#ifdef __USE_MISC
+# include <sys/types.h>
+# include <sys/socket.h>
+#endif
+
+
+/* Length of interface name.  */
+#define IF_NAMESIZE	16
+
+struct if_nameindex
+  {
+    unsigned int if_index;	/* 1, 2, ... */
+    char *if_name;		/* null terminated name: "eth0", ... */
+  };
+
+
+#ifdef __USE_MISC
+/* Standard interface flags. */
+enum
+  {
+    IFF_UP = 0x1,		/* Interface is up.  */
+# define IFF_UP	IFF_UP
+    IFF_BROADCAST = 0x2,	/* Broadcast address valid.  */
+# define IFF_BROADCAST	IFF_BROADCAST
+    IFF_DEBUG = 0x4,		/* Turn on debugging.  */
+# define IFF_DEBUG	IFF_DEBUG
+    IFF_LOOPBACK = 0x8,		/* Is a loopback net.  */
+# define IFF_LOOPBACK	IFF_LOOPBACK
+    IFF_POINTOPOINT = 0x10,	/* Interface is point-to-point link.  */
+# define IFF_POINTOPOINT IFF_POINTOPOINT
+    IFF_NOTRAILERS = 0x20,	/* Avoid use of trailers.  */
+# define IFF_NOTRAILERS	IFF_NOTRAILERS
+    IFF_RUNNING = 0x40,		/* Resources allocated.  */
+# define IFF_RUNNING	IFF_RUNNING
+    IFF_NOARP = 0x80,		/* No address resolution protocol.  */
+# define IFF_NOARP	IFF_NOARP
+    IFF_PROMISC = 0x100,	/* Receive all packets.  */
+# define IFF_PROMISC	IFF_PROMISC
+
+    /* Not supported */
+    IFF_ALLMULTI = 0x200,	/* Receive all multicast packets.  */
+# define IFF_ALLMULTI	IFF_ALLMULTI
+
+    IFF_MASTER = 0x400,		/* Master of a load balancer.  */
+# define IFF_MASTER	IFF_MASTER
+    IFF_SLAVE = 0x800,		/* Slave of a load balancer.  */
+# define IFF_SLAVE	IFF_SLAVE
+
+    IFF_MULTICAST = 0x1000,	/* Supports multicast.  */
+# define IFF_MULTICAST	IFF_MULTICAST
+
+    IFF_PORTSEL = 0x2000,	/* Can set media type.  */
+# define IFF_PORTSEL	IFF_PORTSEL
+    IFF_AUTOMEDIA = 0x4000	/* Auto media select active.  */
+# define IFF_AUTOMEDIA	IFF_AUTOMEDIA
+  };
+
+/* The ifaddr structure contains information about one address of an
+   interface.  They are maintained by the different address families,
+   are allocated and attached when an address is set, and are linked
+   together so all addresses for an interface can be located.  */
+
+struct ifaddr
+  {
+    struct sockaddr ifa_addr;	/* Address of interface.  */
+    union
+      {
+	struct sockaddr	ifu_broadaddr;
+	struct sockaddr	ifu_dstaddr;
+      } ifa_ifu;
+    struct iface *ifa_ifp;	/* Back-pointer to interface.  */
+    struct ifaddr *ifa_next;	/* Next address for interface.  */
+  };
+
+# define ifa_broadaddr	ifa_ifu.ifu_broadaddr	/* broadcast address	*/
+# define ifa_dstaddr	ifa_ifu.ifu_dstaddr	/* other end of link	*/
+
+/* Device mapping structure. I'd just gone off and designed a
+   beautiful scheme using only loadable modules with arguments for
+   driver options and along come the PCMCIA people 8)
+
+   Ah well. The get() side of this is good for WDSETUP, and it'll be
+   handy for debugging things. The set side is fine for now and being
+   very small might be worth keeping for clean configuration.  */
+
+struct ifmap
+  {
+    unsigned long int mem_start;
+    unsigned long int mem_end;
+    unsigned short int base_addr;
+    unsigned char irq;
+    unsigned char dma;
+    unsigned char port;
+    /* 3 bytes spare */
+  };
+
+/* Interface request structure used for socket ioctl's.  All interface
+   ioctl's must have parameter definitions which begin with ifr_name.
+   The remainder may be interface specific.  */
+
+struct ifreq
+  {
+# define IFHWADDRLEN	6
+# define IFNAMSIZ	IF_NAMESIZE
+    union
+      {
+	char ifrn_name[IFNAMSIZ];	/* Interface name, e.g. "en0".  */
+      } ifr_ifrn;
+
+    union
+      {
+	struct sockaddr ifru_addr;
+	struct sockaddr ifru_dstaddr;
+	struct sockaddr ifru_broadaddr;
+	struct sockaddr ifru_netmask;
+	struct sockaddr ifru_hwaddr;
+	short int ifru_flags;
+	int ifru_ivalue;
+	int ifru_mtu;
+	struct ifmap ifru_map;
+	char ifru_slave[IFNAMSIZ];	/* Just fits the size */
+	char ifru_newname[IFNAMSIZ];
+	__caddr_t ifru_data;
+      } ifr_ifru;
+  };
+# define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
+# define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* MAC address 		*/
+# define ifr_addr	ifr_ifru.ifru_addr	/* address		*/
+# define ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk	*/
+# define ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address	*/
+# define ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask	*/
+# define ifr_flags	ifr_ifru.ifru_flags	/* flags		*/
+# define ifr_metric	ifr_ifru.ifru_ivalue	/* metric		*/
+# define ifr_mtu	ifr_ifru.ifru_mtu	/* mtu			*/
+# define ifr_map	ifr_ifru.ifru_map	/* device map		*/
+# define ifr_slave	ifr_ifru.ifru_slave	/* slave device		*/
+# define ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
+# define ifr_ifindex	ifr_ifru.ifru_ivalue    /* interface index      */
+# define ifr_bandwidth	ifr_ifru.ifru_ivalue	/* link bandwidth	*/
+# define ifr_qlen	ifr_ifru.ifru_ivalue	/* queue length		*/
+# define ifr_newname	ifr_ifru.ifru_newname	/* New name		*/
+# define _IOT_ifreq	_IOT(_IOTS(char),IFNAMSIZ,_IOTS(char),16,0,0)
+# define _IOT_ifreq_short _IOT(_IOTS(char),IFNAMSIZ,_IOTS(short),1,0,0)
+# define _IOT_ifreq_int	_IOT(_IOTS(char),IFNAMSIZ,_IOTS(int),1,0,0)
+
+
+/* Structure used in SIOCGIFCONF request.  Used to retrieve interface
+   configuration for machine (useful for programs which must know all
+   networks accessible).  */
+
+struct ifconf
+  {
+    int	ifc_len;			/* Size of buffer.  */
+    union
+      {
+	__caddr_t ifcu_buf;
+	struct ifreq *ifcu_req;
+      } ifc_ifcu;
+  };
+# define ifc_buf	ifc_ifcu.ifcu_buf	/* Buffer address.  */
+# define ifc_req	ifc_ifcu.ifcu_req	/* Array of structures.  */
+# define _IOT_ifconf _IOT(_IOTS(struct ifconf),1,0,0,0,0) /* not right */
+#endif	/* Misc.  */
+
+__BEGIN_DECLS
+
+/* Convert an interface name to an index, and vice versa.  */
+extern unsigned int if_nametoindex (__const char *__ifname) __THROW;
+extern char *if_indextoname (unsigned int __ifindex, char *__ifname) __THROW;
+
+/* Return a list of all interfaces and their indices.  */
+extern struct if_nameindex *if_nameindex (void) __THROW;
+
+/* Free the data returned from if_nameindex.  */
+extern void if_freenameindex (struct if_nameindex *__ptr) __THROW;
+
+__END_DECLS
+
+#endif /* net/if.h */
diff -pruwN busybox-1.01/include2/net/route.h busybox-1.01-livebox/include2/net/route.h
--- busybox-1.01/include2/net/route.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/net/route.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,145 @@
+/* Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Based on the 4.4BSD and Linux version of this file.  */
+
+#ifndef _NET_ROUTE_H
+#define _NET_ROUTE_H	1
+
+#include <features.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <bits/wordsize.h>
+
+
+/* This structure gets passed by the SIOCADDRT and SIOCDELRT calls. */
+struct rtentry
+  {
+    unsigned long int rt_pad1;
+    struct sockaddr rt_dst;		/* Target address.  */
+    struct sockaddr rt_gateway;		/* Gateway addr (RTF_GATEWAY).  */
+    struct sockaddr rt_genmask;		/* Target network mask (IP).  */
+    unsigned short int rt_flags;
+    short int rt_pad2;
+    unsigned long int rt_pad3;
+    unsigned char rt_tos;
+    unsigned char rt_class;
+#if __WORDSIZE == 64
+    short int rt_pad4[3];
+#else
+    short int rt_pad4;
+#endif
+    short int rt_metric;		/* +1 for binary compatibility!  */
+    char *rt_dev;			/* Forcing the device at add.  */
+    unsigned long int rt_mtu;		/* Per route MTU/Window.  */
+    unsigned long int rt_window;	/* Window clamping.  */
+    unsigned short int rt_irtt;		/* Initial RTT.  */
+  };
+/* Compatibility hack.  */
+#define rt_mss	rt_mtu
+
+
+struct in6_rtmsg
+  {
+    struct in6_addr rtmsg_dst;
+    struct in6_addr rtmsg_src;
+    struct in6_addr rtmsg_gateway;
+    u_int32_t rtmsg_type;
+    u_int16_t rtmsg_dst_len;
+    u_int16_t rtmsg_src_len;
+    u_int32_t rtmsg_metric;
+    unsigned long int rtmsg_info;
+    u_int32_t rtmsg_flags;
+    int rtmsg_ifindex;
+  };
+
+
+#define	RTF_UP		0x0001		/* Route usable.  */
+#define	RTF_GATEWAY	0x0002		/* Destination is a gateway.  */
+
+#define	RTF_HOST	0x0004		/* Host entry (net otherwise).  */
+#define RTF_REINSTATE	0x0008		/* Reinstate route after timeout.  */
+#define	RTF_DYNAMIC	0x0010		/* Created dyn. (by redirect).  */
+#define	RTF_MODIFIED	0x0020		/* Modified dyn. (by redirect).  */
+#define RTF_MTU		0x0040		/* Specific MTU for this route.  */
+#define RTF_MSS		RTF_MTU		/* Compatibility.  */
+#define RTF_WINDOW	0x0080		/* Per route window clamping.  */
+#define RTF_IRTT	0x0100		/* Initial round trip time.  */
+#define RTF_REJECT	0x0200		/* Reject route.  */
+#define	RTF_STATIC	0x0400		/* Manually injected route.  */
+#define	RTF_XRESOLVE	0x0800		/* External resolver.  */
+#define RTF_NOFORWARD   0x1000		/* Forwarding inhibited.  */
+#define RTF_THROW	0x2000		/* Go to next class.  */
+#define RTF_NOPMTUDISC  0x4000		/* Do not send packets with DF.  */
+
+/* for IPv6 */
+#define RTF_DEFAULT	0x00010000	/* default - learned via ND	*/
+#define RTF_ALLONLINK	0x00020000	/* fallback, no routers on link	*/
+#define RTF_ADDRCONF	0x00040000	/* addrconf route - RA		*/
+
+#define RTF_LINKRT	0x00100000	/* link specific - device match	*/
+#define RTF_NONEXTHOP	0x00200000	/* route with no nexthop	*/
+
+#define RTF_CACHE	0x01000000	/* cache entry			*/
+#define RTF_FLOW	0x02000000	/* flow significant route	*/
+#define RTF_POLICY	0x04000000	/* policy route			*/
+
+#define RTCF_VALVE	0x00200000
+#define RTCF_MASQ	0x00400000
+#define RTCF_NAT	0x00800000
+#define RTCF_DOREDIRECT 0x01000000
+#define RTCF_LOG	0x02000000
+#define RTCF_DIRECTSRC	0x04000000
+
+#define RTF_LOCAL	0x80000000
+#define RTF_INTERFACE	0x40000000
+#define RTF_MULTICAST	0x20000000
+#define RTF_BROADCAST	0x10000000
+#define RTF_NAT		0x08000000
+
+#define RTF_ADDRCLASSMASK	0xF8000000
+#define RT_ADDRCLASS(flags)	((__u_int32_t) flags >> 23)
+
+#define RT_TOS(tos)		((tos) & IPTOS_TOS_MASK)
+
+#define RT_LOCALADDR(flags)	((flags & RTF_ADDRCLASSMASK) \
+				 == (RTF_LOCAL|RTF_INTERFACE))
+
+#define RT_CLASS_UNSPEC		0
+#define RT_CLASS_DEFAULT	253
+
+#define RT_CLASS_MAIN		254
+#define RT_CLASS_LOCAL		255
+#define RT_CLASS_MAX		255
+
+
+#define RTMSG_ACK		NLMSG_ACK
+#define RTMSG_OVERRUN		NLMSG_OVERRUN
+
+#define RTMSG_NEWDEVICE		0x11
+#define RTMSG_DELDEVICE		0x12
+#define RTMSG_NEWROUTE		0x21
+#define RTMSG_DELROUTE		0x22
+#define RTMSG_NEWRULE		0x31
+#define RTMSG_DELRULE		0x32
+#define RTMSG_CONTROL		0x40
+
+#define RTMSG_AR_FAILED		0x51	/* Address Resolution failed.  */
+
+#endif /* net/route.h */
diff -pruwN busybox-1.01/include2/netdb.h busybox-1.01-livebox/include2/netdb.h
--- busybox-1.01/include2/netdb.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/netdb.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,457 @@
+/* Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* All data returned by the network data base library are supplied in
+   host order and returned in network order (suitable for use in
+   system calls).  */
+
+#ifndef	_NETDB_H
+#define	_NETDB_H	1
+
+#include <features.h>
+
+#include <netinet/in.h>
+#include <stdint.h>
+#ifdef __USE_MISC
+/* This is necessary to make this include file properly replace the
+   Sun version.  */
+# include <rpc/netdb.h>
+#endif
+
+#ifdef __USE_GNU
+# define __need_sigevent_t
+# include <bits/siginfo.h>
+# define __need_timespec
+# include <time.h>
+#endif
+
+#include <bits/netdb.h>
+
+/* Absolute file name for network data base files.  */
+#define	_PATH_HEQUIV		"/etc/hosts.equiv"
+#define	_PATH_HOSTS		"/etc/hosts"
+#define	_PATH_NETWORKS		"/etc/networks"
+#define	_PATH_NSSWITCH_CONF	"/etc/nsswitch.conf"
+#define	_PATH_PROTOCOLS		"/etc/protocols"
+#define	_PATH_SERVICES		"/etc/services"
+
+
+__BEGIN_DECLS
+
+/* Error status for non-reentrant lookup functions.  */
+extern int h_errno;
+
+/* Function to get address of global `h_errno' variable.  */
+extern int *__h_errno_location (void) __THROW __attribute__ ((__const__));
+
+#ifdef _LIBC
+# define __set_h_errno(x) (h_errno = (x))
+#endif
+
+#if defined __UCLIBC_HAS_THREADS__
+/* Use a macro to access always the thread specific `h_errno' variable.  */
+# define h_errno (*__h_errno_location ())
+#endif
+
+
+/* Possible values left in `h_errno'.  */
+#define	NETDB_INTERNAL	-1	/* See errno.  */
+#define	NETDB_SUCCESS	0	/* No problem.  */
+#define	HOST_NOT_FOUND	1	/* Authoritative Answer Host not found.  */
+#define	TRY_AGAIN	2	/* Non-Authoritative Host not found,
+				   or SERVERFAIL.  */
+#define	NO_RECOVERY	3	/* Non recoverable errors, FORMERR, REFUSED,
+				   NOTIMP.  */
+#define	NO_DATA		4	/* Valid name, no data record of requested
+				   type.  */
+#define	NO_ADDRESS	NO_DATA	/* No address, look for MX record.  */
+
+#ifdef __USE_XOPEN2K
+/* Highest reserved Internet port number.  */
+# define IPPORT_RESERVED	1024
+#endif
+
+#ifdef __USE_GNU
+/* Scope delimiter for getaddrinfo(), getnameinfo().  */
+# define SCOPE_DELIMITER	'%'
+#endif
+
+/* Print error indicated by `h_errno' variable on standard error.  STR
+   if non-null is printed before the error string.  */
+extern void herror (__const char *__str) __THROW;
+
+/* Return string associated with error ERR_NUM.  */
+extern __const char *hstrerror (int __err_num) __THROW;
+
+
+
+/* Description of data base entry for a single host.  */
+struct hostent
+{
+  char *h_name;			/* Official name of host.  */
+  char **h_aliases;		/* Alias list.  */
+  int h_addrtype;		/* Host address type.  */
+  int h_length;			/* Length of address.  */
+  char **h_addr_list;		/* List of addresses from name server.  */
+#define	h_addr	h_addr_list[0]	/* Address, for backward compatibility.  */
+};
+
+/* Open host data base files and mark them as staying open even after
+   a later search if STAY_OPEN is non-zero.  */
+extern void sethostent (int __stay_open) __THROW;
+
+/* Close host data base files and clear `stay open' flag.  */
+extern void endhostent (void) __THROW;
+
+/* Get next entry from host data base file.  Open data base if
+   necessary.  */
+extern struct hostent *gethostent (void) __THROW;
+
+/* Return entry from host data base which address match ADDR with
+   length LEN and type TYPE.  */
+extern struct hostent *gethostbyaddr (__const void *__addr, __socklen_t __len,
+				      int __type) __THROW;
+
+/* Return entry from host data base for host with NAME.  */
+extern struct hostent *gethostbyname (__const char *__name) __THROW;
+
+#ifdef __USE_MISC
+/* Return entry from host data base for host with NAME.  AF must be
+   set to the address type which is `AF_INET' for IPv4 or `AF_INET6'
+   for IPv6.  */
+extern struct hostent *gethostbyname2 (__const char *__name, int __af) __THROW;
+
+/* Reentrant versions of the functions above.  The additional
+   arguments specify a buffer of BUFLEN starting at BUF.  The last
+   argument is a pointer to a variable which gets the value which
+   would be stored in the global variable `herrno' by the
+   non-reentrant functions.  */
+extern int gethostent_r (struct hostent *__restrict __result_buf,
+			 char *__restrict __buf, size_t __buflen,
+			 struct hostent **__restrict __result,
+			 int *__restrict __h_errnop) __THROW;
+
+extern int gethostbyaddr_r (__const void *__restrict __addr, __socklen_t __len,
+			    int __type,
+			    struct hostent *__restrict __result_buf,
+			    char *__restrict __buf, size_t __buflen,
+			    struct hostent **__restrict __result,
+			    int *__restrict __h_errnop) __THROW;
+
+extern int gethostbyname_r (__const char *__restrict __name,
+			    struct hostent *__restrict __result_buf,
+			    char *__restrict __buf, size_t __buflen,
+			    struct hostent **__restrict __result,
+			    int *__restrict __h_errnop) __THROW;
+
+extern int gethostbyname2_r (__const char *__restrict __name, int __af,
+			     struct hostent *__restrict __result_buf,
+			     char *__restrict __buf, size_t __buflen,
+			     struct hostent **__restrict __result,
+			     int *__restrict __h_errnop) __THROW;
+#endif	/* misc */
+
+
+/* Open network data base files and mark them as staying open even
+   after a later search if STAY_OPEN is non-zero.  */
+extern void setnetent (int __stay_open) __THROW;
+
+/* Close network data base files and clear `stay open' flag.  */
+extern void endnetent (void) __THROW;
+
+/* Get next entry from network data base file.  Open data base if
+   necessary.  */
+extern struct netent *getnetent (void) __THROW;
+
+/* Return entry from network data base which address match NET and
+   type TYPE.  */
+extern struct netent *getnetbyaddr (uint32_t __net, int __type)
+     __THROW;
+
+/* Return entry from network data base for network with NAME.  */
+extern struct netent *getnetbyname (__const char *__name) __THROW;
+
+#if 0
+/* FIXME */
+#ifdef	__USE_MISC
+/* Reentrant versions of the functions above.  The additional
+   arguments specify a buffer of BUFLEN starting at BUF.  The last
+   argument is a pointer to a variable which gets the value which
+   would be stored in the global variable `herrno' by the
+   non-reentrant functions.  */
+extern int getnetent_r (struct netent *__restrict __result_buf,
+			char *__restrict __buf, size_t __buflen,
+			struct netent **__restrict __result,
+			int *__restrict __h_errnop) __THROW;
+
+extern int getnetbyaddr_r (uint32_t __net, int __type,
+			   struct netent *__restrict __result_buf,
+			   char *__restrict __buf, size_t __buflen,
+			   struct netent **__restrict __result,
+			   int *__restrict __h_errnop) __THROW;
+
+extern int getnetbyname_r (__const char *__restrict __name,
+			   struct netent *__restrict __result_buf,
+			   char *__restrict __buf, size_t __buflen,
+			   struct netent **__restrict __result,
+			   int *__restrict __h_errnop) __THROW;
+#endif	/* misc */
+#endif
+
+
+/* Description of data base entry for a single service.  */
+struct servent
+{
+  char *s_name;			/* Official service name.  */
+  char **s_aliases;		/* Alias list.  */
+  int s_port;			/* Port number.  */
+  char *s_proto;		/* Protocol to use.  */
+};
+
+/* Open service data base files and mark them as staying open even
+   after a later search if STAY_OPEN is non-zero.  */
+extern void setservent (int __stay_open) __THROW;
+
+/* Close service data base files and clear `stay open' flag.  */
+extern void endservent (void) __THROW;
+
+/* Get next entry from service data base file.  Open data base if
+   necessary.  */
+extern struct servent *getservent (void) __THROW;
+
+/* Return entry from network data base for network with NAME and
+   protocol PROTO.  */
+extern struct servent *getservbyname (__const char *__name,
+				      __const char *__proto) __THROW;
+
+/* Return entry from service data base which matches port PORT and
+   protocol PROTO.  */
+extern struct servent *getservbyport (int __port, __const char *__proto)
+     __THROW;
+
+
+#ifdef	__USE_MISC
+/* Reentrant versions of the functions above.  The additional
+   arguments specify a buffer of BUFLEN starting at BUF.  */
+extern int getservent_r (struct servent *__restrict __result_buf,
+			 char *__restrict __buf, size_t __buflen,
+			 struct servent **__restrict __result) __THROW;
+
+extern int getservbyname_r (__const char *__restrict __name,
+			    __const char *__restrict __proto,
+			    struct servent *__restrict __result_buf,
+			    char *__restrict __buf, size_t __buflen,
+			    struct servent **__restrict __result) __THROW;
+
+extern int getservbyport_r (int __port, __const char *__restrict __proto,
+			    struct servent *__restrict __result_buf,
+			    char *__restrict __buf, size_t __buflen,
+			    struct servent **__restrict __result) __THROW;
+#endif	/* misc */
+
+
+/* Description of data base entry for a single service.  */
+struct protoent
+{
+  char *p_name;			/* Official protocol name.  */
+  char **p_aliases;		/* Alias list.  */
+  int p_proto;			/* Protocol number.  */
+};
+
+/* Open protocol data base files and mark them as staying open even
+   after a later search if STAY_OPEN is non-zero.  */
+extern void setprotoent (int __stay_open) __THROW;
+
+/* Close protocol data base files and clear `stay open' flag.  */
+extern void endprotoent (void) __THROW;
+
+/* Get next entry from protocol data base file.  Open data base if
+   necessary.  */
+extern struct protoent *getprotoent (void) __THROW;
+
+/* Return entry from protocol data base for network with NAME.  */
+extern struct protoent *getprotobyname (__const char *__name) __THROW;
+
+/* Return entry from protocol data base which number is PROTO.  */
+extern struct protoent *getprotobynumber (int __proto) __THROW;
+
+
+#ifdef	__USE_MISC
+/* Reentrant versions of the functions above.  The additional
+   arguments specify a buffer of BUFLEN starting at BUF.  */
+extern int getprotoent_r (struct protoent *__restrict __result_buf,
+			  char *__restrict __buf, size_t __buflen,
+			  struct protoent **__restrict __result) __THROW;
+
+extern int getprotobyname_r (__const char *__restrict __name,
+			     struct protoent *__restrict __result_buf,
+			     char *__restrict __buf, size_t __buflen,
+			     struct protoent **__restrict __result) __THROW;
+
+extern int getprotobynumber_r (int __proto,
+			       struct protoent *__restrict __result_buf,
+			       char *__restrict __buf, size_t __buflen,
+			       struct protoent **__restrict __result) __THROW;
+#endif	/* misc */
+
+
+#ifdef __USE_BSD
+/* Call `rshd' at port RPORT on remote machine *AHOST to execute CMD.
+   The local user is LOCUSER, on the remote machine the command is
+   executed as REMUSER.  In *FD2P the descriptor to the socket for the
+   connection is returned.  The caller must have the right to use a
+   reserved port.  When the function returns *AHOST contains the
+   official host name.  */
+extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
+		 __const char *__restrict __locuser,
+		 __const char *__restrict __remuser,
+		 __const char *__restrict __cmd, int *__restrict __fd2p)
+     __THROW;
+
+#if 0
+/* FIXME */
+/* This is the equivalent function where the protocol can be selected
+   and which therefore can be used for IPv6.  */
+extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
+		    __const char *__restrict __locuser,
+		    __const char *__restrict __remuser,
+		    __const char *__restrict __cmd, int *__restrict __fd2p,
+		    sa_family_t __af) __THROW;
+#endif
+
+/* Call `rexecd' at port RPORT on remote machine *AHOST to execute
+   CMD.  The process runs at the remote machine using the ID of user
+   NAME whose cleartext password is PASSWD.  In *FD2P the descriptor
+   to the socket for the connection is returned.  When the function
+   returns *AHOST contains the official host name.  */
+extern int rexec (char **__restrict __ahost, int __rport,
+		  __const char *__restrict __name,
+		  __const char *__restrict __pass,
+		  __const char *__restrict __cmd, int *__restrict __fd2p)
+     __THROW;
+
+/* This is the equivalent function where the protocol can be selected
+   and which therefore can be used for IPv6.  */
+extern int rexec_af (char **__restrict __ahost, int __rport,
+		     __const char *__restrict __name,
+		     __const char *__restrict __pass,
+		     __const char *__restrict __cmd, int *__restrict __fd2p,
+		     sa_family_t __af) __THROW;
+
+/* Check whether user REMUSER on system RHOST is allowed to login as LOCUSER.
+   If SUSER is not zero the user tries to become superuser.  Return 0 if
+   it is possible.  */
+extern int ruserok (__const char *__rhost, int __suser,
+		    __const char *__remuser, __const char *__locuser) __THROW;
+
+#if 0
+/* FIXME */
+/* This is the equivalent function where the protocol can be selected
+   and which therefore can be used for IPv6.  */
+extern int ruserok_af (__const char *__rhost, int __suser,
+		       __const char *__remuser, __const char *__locuser,
+		       sa_family_t __af) __THROW;
+#endif
+
+/* Try to allocate reserved port, returning a descriptor for a socket opened
+   at this port or -1 if unsuccessful.  The search for an available port
+   will start at ALPORT and continues with lower numbers.  */
+extern int rresvport (int *__alport) __THROW;
+
+#if 0
+/* FIXME */
+/* This is the equivalent function where the protocol can be selected
+   and which therefore can be used for IPv6.  */
+extern int rresvport_af (int *__alport, sa_family_t __af) __THROW;
+#endif
+#endif
+
+
+/* Extension from POSIX.1g.  */
+#ifdef	__USE_POSIX
+/* Structure to contain information about address of a service provider.  */
+struct addrinfo
+{
+  int ai_flags;			/* Input flags.  */
+  int ai_family;		/* Protocol family for socket.  */
+  int ai_socktype;		/* Socket type.  */
+  int ai_protocol;		/* Protocol for socket.  */
+  socklen_t ai_addrlen;		/* Length of socket address.  */
+  struct sockaddr *ai_addr;	/* Socket address for socket.  */
+  char *ai_canonname;		/* Canonical name for service location.  */
+  struct addrinfo *ai_next;	/* Pointer to next in list.  */
+};
+
+/* Possible values for `ai_flags' field in `addrinfo' structure.  */
+# define AI_PASSIVE	0x0001	/* Socket address is intended for `bind'.  */
+# define AI_CANONNAME	0x0002	/* Request for canonical name.  */
+# define AI_NUMERICHOST	0x0004	/* Don't use name resolution.  */
+
+/* Error values for `getaddrinfo' function.  */
+# define EAI_BADFLAGS	  -1	/* Invalid value for `ai_flags' field.  */
+# define EAI_NONAME	  -2	/* NAME or SERVICE is unknown.  */
+# define EAI_AGAIN	  -3	/* Temporary failure in name resolution.  */
+# define EAI_FAIL	  -4	/* Non-recoverable failure in name res.  */
+# define EAI_NODATA	  -5	/* No address associated with NAME.  */
+# define EAI_FAMILY	  -6	/* `ai_family' not supported.  */
+# define EAI_SOCKTYPE	  -7	/* `ai_socktype' not supported.  */
+# define EAI_SERVICE	  -8	/* SERVICE not supported for `ai_socktype'.  */
+# define EAI_ADDRFAMILY	  -9	/* Address family for NAME not supported.  */
+# define EAI_MEMORY	  -10	/* Memory allocation failure.  */
+# define EAI_SYSTEM	  -11	/* System error returned in `errno'.  */
+# ifdef __USE_GNU
+#  define EAI_INPROGRESS  -100	/* Processing request in progress.  */
+#  define EAI_CANCELED	  -101	/* Request canceled.  */
+#  define EAI_NOTCANCELED -102	/* Request not canceled.  */
+#  define EAI_ALLDONE	  -103	/* All requests done.  */
+#  define EAI_INTR	  -104	/* Interrupted by a signal.  */
+# endif
+
+# define NI_MAXHOST      1025
+# define NI_MAXSERV      32
+
+# define NI_NUMERICHOST	1	/* Don't try to look up hostname.  */
+# define NI_NUMERICSERV 2	/* Don't convert port number to name.  */
+# define NI_NOFQDN	4	/* Only return nodename portion.  */
+# define NI_NAMEREQD	8	/* Don't return numeric addresses.  */
+# define NI_DGRAM	16	/* Look up UDP service rather than TCP.  */
+
+/* Translate name of a service location and/or a service name to set of
+   socket addresses.  */
+extern int getaddrinfo (__const char *__restrict __name,
+			__const char *__restrict __service,
+			__const struct addrinfo *__restrict __req,
+			struct addrinfo **__restrict __pai) __THROW;
+
+/* Free `addrinfo' structure AI including associated storage.  */
+extern void freeaddrinfo (struct addrinfo *__ai) __THROW;
+
+/* Convert error return from getaddrinfo() to a string.  */
+extern __const char *gai_strerror (int __ecode) __THROW;
+
+/* Translate a socket address to a location and service name.  */
+extern int getnameinfo (__const struct sockaddr *__restrict __sa,
+			socklen_t __salen, char *__restrict __host,
+			socklen_t __hostlen, char *__restrict __serv,
+			socklen_t __servlen, unsigned int __flags) __THROW;
+
+#endif	/* POSIX */
+
+__END_DECLS
+
+#endif	/* netdb.h */
diff -pruwN busybox-1.01/include2/netinet/if_ether.h busybox-1.01-livebox/include2/netinet/if_ether.h
--- busybox-1.01/include2/netinet/if_ether.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/netinet/if_ether.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,105 @@
+/* Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __NETINET_IF_ETHER_H
+
+#define __NETINET_IF_ETHER_H	1
+#include <features.h>
+#include <sys/types.h>
+
+/* Get definitions from kernel header file.  */
+#include <linux/if_ether.h>
+
+#ifdef __USE_BSD
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if_ether.h	8.3 (Berkeley) 5/2/95
+ *	$FreeBSD$
+ */
+
+#include <net/ethernet.h>
+#include <net/if_arp.h>
+
+__BEGIN_DECLS
+/*
+ * Ethernet Address Resolution Protocol.
+ *
+ * See RFC 826 for protocol description.  Structure below is adapted
+ * to resolving internet addresses.  Field names used correspond to
+ * RFC 826.
+ */
+struct	ether_arp {
+	struct	arphdr ea_hdr;		/* fixed-size header */
+	u_int8_t arp_sha[ETH_ALEN];	/* sender hardware address */
+	u_int8_t arp_spa[4];		/* sender protocol address */
+	u_int8_t arp_tha[ETH_ALEN];	/* target hardware address */
+	u_int8_t arp_tpa[4];		/* target protocol address */
+};
+#define	arp_hrd	ea_hdr.ar_hrd
+#define	arp_pro	ea_hdr.ar_pro
+#define	arp_hln	ea_hdr.ar_hln
+#define	arp_pln	ea_hdr.ar_pln
+#define	arp_op	ea_hdr.ar_op
+
+/*
+ * Macro to map an IP multicast address to an Ethernet multicast address.
+ * The high-order 25 bits of the Ethernet address are statically assigned,
+ * and the low-order 23 bits are taken from the low end of the IP address.
+ */
+#define ETHER_MAP_IP_MULTICAST(ipaddr, enaddr) \
+	/* struct in_addr *ipaddr; */ \
+	/* u_char enaddr[ETH_ALEN];	   */ \
+{ \
+	(enaddr)[0] = 0x01; \
+	(enaddr)[1] = 0x00; \
+	(enaddr)[2] = 0x5e; \
+	(enaddr)[3] = ((u_int8_t *)ipaddr)[1] & 0x7f; \
+	(enaddr)[4] = ((u_int8_t *)ipaddr)[2]; \
+	(enaddr)[5] = ((u_int8_t *)ipaddr)[3]; \
+}
+
+__END_DECLS
+#endif /* __USE_BSD */
+
+#endif /* netinet/if_ether.h */
diff -pruwN busybox-1.01/include2/netinet/in.h busybox-1.01-livebox/include2/netinet/in.h
--- busybox-1.01/include2/netinet/in.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/netinet/in.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,372 @@
+/* Copyright (C) 1991-1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_NETINET_IN_H
+#define	_NETINET_IN_H	1
+
+#include <features.h>
+#include <stdint.h>
+#include <bits/types.h>
+
+
+__BEGIN_DECLS
+
+/* Standard well-defined IP protocols.  */
+enum
+  {
+    IPPROTO_IP = 0,	   /* Dummy protocol for TCP.  */
+#define IPPROTO_IP		IPPROTO_IP
+    IPPROTO_HOPOPTS = 0,   /* IPv6 Hop-by-Hop options.  */
+#define IPPROTO_HOPOPTS		IPPROTO_HOPOPTS
+    IPPROTO_ICMP = 1,	   /* Internet Control Message Protocol.  */
+#define IPPROTO_ICMP		IPPROTO_ICMP
+    IPPROTO_IGMP = 2,	   /* Internet Group Management Protocol. */
+#define IPPROTO_IGMP		IPPROTO_IGMP
+    IPPROTO_IPIP = 4,	   /* IPIP tunnels (older KA9Q tunnels use 94).  */
+#define IPPROTO_IPIP		IPPROTO_IPIP
+    IPPROTO_TCP = 6,	   /* Transmission Control Protocol.  */
+#define IPPROTO_TCP		IPPROTO_TCP
+    IPPROTO_EGP = 8,	   /* Exterior Gateway Protocol.  */
+#define IPPROTO_EGP		IPPROTO_EGP
+    IPPROTO_PUP = 12,	   /* PUP protocol.  */
+#define IPPROTO_PUP		IPPROTO_PUP
+    IPPROTO_UDP = 17,	   /* User Datagram Protocol.  */
+#define IPPROTO_UDP		IPPROTO_UDP
+    IPPROTO_IDP = 22,	   /* XNS IDP protocol.  */
+#define IPPROTO_IDP		IPPROTO_IDP
+    IPPROTO_TP = 29,	   /* SO Transport Protocol Class 4.  */
+#define IPPROTO_TP		IPPROTO_TP
+    IPPROTO_IPV6 = 41,     /* IPv6 header.  */
+#define IPPROTO_IPV6		IPPROTO_IPV6
+    IPPROTO_ROUTING = 43,  /* IPv6 routing header.  */
+#define IPPROTO_ROUTING		IPPROTO_ROUTING
+    IPPROTO_FRAGMENT = 44, /* IPv6 fragmentation header.  */
+#define IPPROTO_FRAGMENT	IPPROTO_FRAGMENT
+    IPPROTO_RSVP = 46,	   /* Reservation Protocol.  */
+#define IPPROTO_RSVP		IPPROTO_RSVP
+    IPPROTO_GRE = 47,	   /* General Routing Encapsulation.  */
+#define IPPROTO_GRE		IPPROTO_GRE
+    IPPROTO_ESP = 50,      /* encapsulating security payload.  */
+#define IPPROTO_ESP		IPPROTO_ESP
+    IPPROTO_AH = 51,       /* authentication header.  */
+#define IPPROTO_AH		IPPROTO_AH
+    IPPROTO_ICMPV6 = 58,   /* ICMPv6.  */
+#define IPPROTO_ICMPV6		IPPROTO_ICMPV6
+    IPPROTO_NONE = 59,     /* IPv6 no next header.  */
+#define IPPROTO_NONE		IPPROTO_NONE
+    IPPROTO_DSTOPTS = 60,  /* IPv6 destination options.  */
+#define IPPROTO_DSTOPTS		IPPROTO_DSTOPTS
+    IPPROTO_MTP = 92,	   /* Multicast Transport Protocol.  */
+#define IPPROTO_MTP		IPPROTO_MTP
+    IPPROTO_ENCAP = 98,	   /* Encapsulation Header.  */
+#define IPPROTO_ENCAP		IPPROTO_ENCAP
+    IPPROTO_PIM = 103,	   /* Protocol Independent Multicast.  */
+#define IPPROTO_PIM		IPPROTO_PIM
+    IPPROTO_COMP = 108,	   /* Compression Header Protocol.  */
+#define IPPROTO_COMP		IPPROTO_COMP
+    IPPROTO_RAW = 255,	   /* Raw IP packets.  */
+#define IPPROTO_RAW		IPPROTO_RAW
+    IPPROTO_MAX
+  };
+
+
+/* Type to represent a port.  */
+typedef uint16_t in_port_t;
+
+/* Standard well-known ports.  */
+enum
+  {
+    IPPORT_ECHO = 7,		/* Echo service.  */
+    IPPORT_DISCARD = 9,		/* Discard transmissions service.  */
+    IPPORT_SYSTAT = 11,		/* System status service.  */
+    IPPORT_DAYTIME = 13,	/* Time of day service.  */
+    IPPORT_NETSTAT = 15,	/* Network status service.  */
+    IPPORT_FTP = 21,		/* File Transfer Protocol.  */
+    IPPORT_TELNET = 23,		/* Telnet protocol.  */
+    IPPORT_SMTP = 25,		/* Simple Mail Transfer Protocol.  */
+    IPPORT_TIMESERVER = 37,	/* Timeserver service.  */
+    IPPORT_NAMESERVER = 42,	/* Domain Name Service.  */
+    IPPORT_WHOIS = 43,		/* Internet Whois service.  */
+    IPPORT_MTP = 57,
+
+    IPPORT_TFTP = 69,		/* Trivial File Transfer Protocol.  */
+    IPPORT_RJE = 77,
+    IPPORT_FINGER = 79,		/* Finger service.  */
+    IPPORT_TTYLINK = 87,
+    IPPORT_SUPDUP = 95,		/* SUPDUP protocol.  */
+
+
+    IPPORT_EXECSERVER = 512,	/* execd service.  */
+    IPPORT_LOGINSERVER = 513,	/* rlogind service.  */
+    IPPORT_CMDSERVER = 514,
+    IPPORT_EFSSERVER = 520,
+
+    /* UDP ports.  */
+    IPPORT_BIFFUDP = 512,
+    IPPORT_WHOSERVER = 513,
+    IPPORT_ROUTESERVER = 520,
+
+    /* Ports less than this value are reserved for privileged processes.  */
+    IPPORT_RESERVED = 1024,
+
+    /* Ports greater this value are reserved for (non-privileged) servers.  */
+    IPPORT_USERRESERVED = 5000
+  };
+
+
+/* Internet address.  */
+typedef uint32_t in_addr_t;
+struct in_addr
+  {
+    in_addr_t s_addr;
+  };
+
+
+/* Definitions of the bits in an Internet address integer.
+
+   On subnets, host and network parts are found according to
+   the subnet mask, not these masks.  */
+
+#define	IN_CLASSA(a)		((((in_addr_t)(a)) & 0x80000000) == 0)
+#define	IN_CLASSA_NET		0xff000000
+#define	IN_CLASSA_NSHIFT	24
+#define	IN_CLASSA_HOST		(0xffffffff & ~IN_CLASSA_NET)
+#define	IN_CLASSA_MAX		128
+
+#define	IN_CLASSB(a)		((((in_addr_t)(a)) & 0xc0000000) == 0x80000000)
+#define	IN_CLASSB_NET		0xffff0000
+#define	IN_CLASSB_NSHIFT	16
+#define	IN_CLASSB_HOST		(0xffffffff & ~IN_CLASSB_NET)
+#define	IN_CLASSB_MAX		65536
+
+#define	IN_CLASSC(a)		((((in_addr_t)(a)) & 0xe0000000) == 0xc0000000)
+#define	IN_CLASSC_NET		0xffffff00
+#define	IN_CLASSC_NSHIFT	8
+#define	IN_CLASSC_HOST		(0xffffffff & ~IN_CLASSC_NET)
+
+#define	IN_CLASSD(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xe0000000)
+#define	IN_MULTICAST(a)		IN_CLASSD(a)
+
+#define	IN_EXPERIMENTAL(a)	((((in_addr_t)(a)) & 0xe0000000) == 0xe0000000)
+#define	IN_BADCLASS(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xf0000000)
+
+/* Address to accept any incoming messages.  */
+#define	INADDR_ANY		((in_addr_t) 0x00000000)
+/* Address to send to all hosts.  */
+#define	INADDR_BROADCAST	((in_addr_t) 0xffffffff)
+/* Address indicating an error return.  */
+#define	INADDR_NONE		((in_addr_t) 0xffffffff)
+
+/* Network number for local host loopback.  */
+#define	IN_LOOPBACKNET		127
+/* Address to loopback in software to local host.  */
+#ifndef INADDR_LOOPBACK
+# define INADDR_LOOPBACK	((in_addr_t) 0x7f000001) /* Inet 127.0.0.1.  */
+#endif
+
+/* Defines for Multicast INADDR.  */
+#define INADDR_UNSPEC_GROUP	((in_addr_t) 0xe0000000) /* 224.0.0.0 */
+#define INADDR_ALLHOSTS_GROUP	((in_addr_t) 0xe0000001) /* 224.0.0.1 */
+#define INADDR_ALLRTRS_GROUP    ((in_addr_t) 0xe0000002) /* 224.0.0.2 */
+#define INADDR_MAX_LOCAL_GROUP  ((in_addr_t) 0xe00000ff) /* 224.0.0.255 */
+
+
+/* IPv6 address */
+struct in6_addr
+  {
+    union
+      {
+	uint8_t	u6_addr8[16];
+	uint16_t u6_addr16[8];
+	uint32_t u6_addr32[4];
+      } in6_u;
+#define s6_addr			in6_u.u6_addr8
+#define s6_addr16		in6_u.u6_addr16
+#define s6_addr32		in6_u.u6_addr32
+  };
+
+extern const struct in6_addr in6addr_any;        /* :: */
+extern const struct in6_addr in6addr_loopback;   /* ::1 */
+#define IN6ADDR_ANY_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
+#define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }
+
+#define INET_ADDRSTRLEN 16
+#define INET6_ADDRSTRLEN 46
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/socket.h>
+
+
+/* Structure describing an Internet socket address.  */
+struct sockaddr_in
+  {
+    __SOCKADDR_COMMON (sin_);
+    in_port_t sin_port;			/* Port number.  */
+    struct in_addr sin_addr;		/* Internet address.  */
+
+    /* Pad to size of `struct sockaddr'.  */
+    unsigned char sin_zero[sizeof (struct sockaddr) -
+			   __SOCKADDR_COMMON_SIZE -
+			   sizeof (in_port_t) -
+			   sizeof (struct in_addr)];
+  };
+
+/* Ditto, for IPv6.  */
+struct sockaddr_in6
+  {
+    __SOCKADDR_COMMON (sin6_);
+    in_port_t sin6_port;	/* Transport layer port # */
+    uint32_t sin6_flowinfo;	/* IPv6 flow information */
+    struct in6_addr sin6_addr;	/* IPv6 address */
+    uint32_t sin6_scope_id;	/* IPv6 scope-id */
+  };
+
+/* IPv6 multicast request.  */
+struct ipv6_mreq
+  {
+    /* IPv6 multicast address of group */
+    struct in6_addr ipv6mr_multiaddr;
+
+    /* local interface */
+    unsigned int ipv6mr_interface;
+  };
+
+/* Get system-specific definitions.  */
+#include <bits/in.h>
+
+/* Functions to convert between host and network byte order.
+
+   Please note that these functions normally take `unsigned long int' or
+   `unsigned short int' values as arguments and also return them.  But
+   this was a short-sighted decision since on different systems the types
+   may have different representations but the values are always the same.  */
+
+extern uint32_t ntohl (uint32_t __netlong) __THROW __attribute__ ((__const__));
+extern uint16_t ntohs (uint16_t __netshort)
+     __THROW __attribute__ ((__const__));
+extern uint32_t htonl (uint32_t __hostlong)
+     __THROW __attribute__ ((__const__));
+extern uint16_t htons (uint16_t __hostshort)
+     __THROW __attribute__ ((__const__));
+
+#include <endian.h>
+
+/* Get machine dependent optimized versions of byte swapping functions.  */
+#include <bits/byteswap.h>
+
+#ifndef __OPTIMIZE__
+#define __OPTIMIZE__
+#endif
+#ifdef __OPTIMIZE__
+/* We can optimize calls to the conversion functions.  Either nothing has
+   to be done or we are using directly the byte-swapping functions which
+   often can be inlined.  */
+# if __BYTE_ORDER == __BIG_ENDIAN
+/* The host byte order is the same as network byte order,
+   so these functions are all just identity.  */
+# define ntohl(x)	(x)
+# define ntohs(x)	(x)
+# define htonl(x)	(x)
+# define htons(x)	(x)
+# else
+#  if __BYTE_ORDER == __LITTLE_ENDIAN
+#   define ntohl(x)	__bswap_32 (x)
+#   define ntohs(x)	__bswap_16 (x)
+#   define htonl(x)	__bswap_32 (x)
+#   define htons(x)	__bswap_16 (x)
+#  endif
+# endif
+#endif
+
+#define IN6_IS_ADDR_UNSPECIFIED(a) \
+	(((__const uint32_t *) (a))[0] == 0				      \
+	 && ((__const uint32_t *) (a))[1] == 0				      \
+	 && ((__const uint32_t *) (a))[2] == 0				      \
+	 && ((__const uint32_t *) (a))[3] == 0)
+
+#define IN6_IS_ADDR_LOOPBACK(a) \
+	(((__const uint32_t *) (a))[0] == 0				      \
+	 && ((__const uint32_t *) (a))[1] == 0				      \
+	 && ((__const uint32_t *) (a))[2] == 0				      \
+	 && ((__const uint32_t *) (a))[3] == htonl (1))
+
+#define IN6_IS_ADDR_MULTICAST(a) (((__const uint8_t *) (a))[0] == 0xff)
+
+#define IN6_IS_ADDR_LINKLOCAL(a) \
+	((((__const uint32_t *) (a))[0] & htonl (0xffc00000))		      \
+	 == htonl (0xfe800000))
+
+#define IN6_IS_ADDR_SITELOCAL(a) \
+	((((__const uint32_t *) (a))[0] & htonl (0xffc00000))		      \
+	 == htonl (0xfec00000))
+
+#define IN6_IS_ADDR_V4MAPPED(a) \
+	((((__const uint32_t *) (a))[0] == 0)				      \
+	 && (((__const uint32_t *) (a))[1] == 0)			      \
+	 && (((__const uint32_t *) (a))[2] == htonl (0xffff)))
+
+#define IN6_IS_ADDR_V4COMPAT(a) \
+	((((__const uint32_t *) (a))[0] == 0)				      \
+	 && (((__const uint32_t *) (a))[1] == 0)			      \
+	 && (((__const uint32_t *) (a))[2] == 0)			      \
+	 && (ntohl (((__const uint32_t *) (a))[3]) > 1))
+
+#define IN6_ARE_ADDR_EQUAL(a,b) \
+	((((__const uint32_t *) (a))[0] == ((__const uint32_t *) (b))[0])     \
+	 && (((__const uint32_t *) (a))[1] == ((__const uint32_t *) (b))[1])  \
+	 && (((__const uint32_t *) (a))[2] == ((__const uint32_t *) (b))[2])  \
+	 && (((__const uint32_t *) (a))[3] == ((__const uint32_t *) (b))[3]))
+
+/* Bind socket to a privileged IP port.  */
+extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __THROW;
+
+/* The IPv6 version of this function.  */
+extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
+     __THROW;
+
+
+#define IN6_IS_ADDR_MC_NODELOCAL(a) \
+	(IN6_IS_ADDR_MULTICAST(a)					      \
+	 && ((((__const uint8_t *) (a))[1] & 0xf) == 0x1))
+
+#define IN6_IS_ADDR_MC_LINKLOCAL(a) \
+	(IN6_IS_ADDR_MULTICAST(a)					      \
+	 && ((((__const uint8_t *) (a))[1] & 0xf) == 0x2))
+
+#define IN6_IS_ADDR_MC_SITELOCAL(a) \
+	(IN6_IS_ADDR_MULTICAST(a)					      \
+	 && ((((__const uint8_t *) (a))[1] & 0xf) == 0x5))
+
+#define IN6_IS_ADDR_MC_ORGLOCAL(a) \
+	(IN6_IS_ADDR_MULTICAST(a)					      \
+	 && ((((__const uint8_t *) (a))[1] & 0xf) == 0x8))
+
+#define IN6_IS_ADDR_MC_GLOBAL(a) \
+	(IN6_IS_ADDR_MULTICAST(a)					      \
+	 && ((((__const uint8_t *) (a))[1] & 0xf) == 0xe))
+
+/* IPv6 packet information.  */
+struct in6_pktinfo
+  {
+    struct in6_addr	ipi6_addr;    /* src/dst IPv6 address */
+    unsigned int	ipi6_ifindex; /* send/recv interface index */
+  };
+
+__END_DECLS
+
+#endif	/* netinet/in.h */
diff -pruwN busybox-1.01/include2/netinet/ip.h busybox-1.01-livebox/include2/netinet/ip.h
--- busybox-1.01/include2/netinet/ip.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/netinet/ip.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,249 @@
+/* Copyright (C) 1991,92,93,95,96,97,98,99,2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __NETINET_IP_H
+#define __NETINET_IP_H 1
+
+#include <features.h>
+#include <sys/types.h>
+
+#include <netinet/in.h>
+
+__BEGIN_DECLS
+
+struct timestamp
+  {
+    u_int8_t len;
+    u_int8_t ptr;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+    unsigned int flags:4;
+    unsigned int overflow:4;
+#elif __BYTE_ORDER == __BIG_ENDIAN
+    unsigned int overflow:4;
+    unsigned int flags:4;
+#else
+# error	"Please fix <bits/endian.h>"
+#endif
+    u_int32_t data[9];
+  };
+
+struct iphdr
+  {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+    unsigned int ihl:4;
+    unsigned int version:4;
+#elif __BYTE_ORDER == __BIG_ENDIAN
+    unsigned int version:4;
+    unsigned int ihl:4;
+#else
+# error	"Please fix <bits/endian.h>"
+#endif
+    u_int8_t tos;
+    u_int16_t tot_len;
+    u_int16_t id;
+    u_int16_t frag_off;
+    u_int8_t ttl;
+    u_int8_t protocol;
+    u_int16_t check;
+    u_int32_t saddr;
+    u_int32_t daddr;
+    /*The options start here. */
+  };
+
+#ifdef __USE_BSD
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip.h	8.1 (Berkeley) 6/10/93
+ */
+
+/*
+ * Definitions for internet protocol version 4.
+ * Per RFC 791, September 1981.
+ */
+
+/*
+ * Structure of an internet header, naked of options.
+ */
+struct ip
+  {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+    unsigned int ip_hl:4;		/* header length */
+    unsigned int ip_v:4;		/* version */
+#endif
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned int ip_v:4;		/* version */
+    unsigned int ip_hl:4;		/* header length */
+#endif
+    u_int8_t ip_tos;			/* type of service */
+    u_short ip_len;			/* total length */
+    u_short ip_id;			/* identification */
+    u_short ip_off;			/* fragment offset field */
+#define	IP_RF 0x8000			/* reserved fragment flag */
+#define	IP_DF 0x4000			/* dont fragment flag */
+#define	IP_MF 0x2000			/* more fragments flag */
+#define	IP_OFFMASK 0x1fff		/* mask for fragmenting bits */
+    u_int8_t ip_ttl;			/* time to live */
+    u_int8_t ip_p;			/* protocol */
+    u_short ip_sum;			/* checksum */
+    struct in_addr ip_src, ip_dst;	/* source and dest address */
+  };
+
+/*
+ * Time stamp option structure.
+ */
+struct ip_timestamp
+  {
+    u_int8_t ipt_code;			/* IPOPT_TS */
+    u_int8_t ipt_len;			/* size of structure (variable) */
+    u_int8_t ipt_ptr;			/* index of current entry */
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+    unsigned int ipt_flg:4;		/* flags, see below */
+    unsigned int ipt_oflw:4;		/* overflow counter */
+#endif
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned int ipt_oflw:4;		/* overflow counter */
+    unsigned int ipt_flg:4;		/* flags, see below */
+#endif
+    u_int32_t data[9];
+  };
+#endif /* __USE_BSD */
+
+#define	IPVERSION	4               /* IP version number */
+#define	IP_MAXPACKET	65535		/* maximum packet size */
+
+/*
+ * Definitions for IP type of service (ip_tos)
+ */
+#define	IPTOS_TOS_MASK		0x1E
+#define	IPTOS_TOS(tos)		((tos) & IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_LOWCOST		0x02
+#define	IPTOS_MINCOST		IPTOS_LOWCOST
+
+/*
+ * Definitions for IP precedence (also in ip_tos) (hopefully unused)
+ */
+#define	IPTOS_PREC_MASK			0xe0
+#define	IPTOS_PREC(tos)                ((tos) & IPTOS_PREC_MASK)
+#define	IPTOS_PREC_NETCONTROL		0xe0
+#define	IPTOS_PREC_INTERNETCONTROL	0xc0
+#define	IPTOS_PREC_CRITIC_ECP		0xa0
+#define	IPTOS_PREC_FLASHOVERRIDE	0x80
+#define	IPTOS_PREC_FLASH		0x60
+#define	IPTOS_PREC_IMMEDIATE		0x40
+#define	IPTOS_PREC_PRIORITY		0x20
+#define	IPTOS_PREC_ROUTINE		0x00
+
+/*
+ * Definitions for options.
+ */
+#define	IPOPT_COPY		0x80
+#define	IPOPT_CLASS_MASK	0x60
+#define	IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o) & IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o) & IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o) & IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_DEBMEAS		0x40
+#define	IPOPT_MEASUREMENT       IPOPT_DEBMEAS
+#define	IPOPT_RESERVED2		0x60
+
+#define	IPOPT_EOL		0		/* end of option list */
+#define	IPOPT_END		IPOPT_EOL
+#define	IPOPT_NOP		1		/* no operation */
+#define	IPOPT_NOOP		IPOPT_NOP
+
+#define	IPOPT_RR		7		/* record packet route */
+#define	IPOPT_TS		68		/* timestamp */
+#define	IPOPT_TIMESTAMP		IPOPT_TS
+#define	IPOPT_SECURITY		130		/* provide s,c,h,tcc */
+#define	IPOPT_SEC		IPOPT_SECURITY
+#define	IPOPT_LSRR		131		/* loose source route */
+#define	IPOPT_SATID		136		/* satnet id */
+#define	IPOPT_SID		IPOPT_SATID
+#define	IPOPT_SSRR		137		/* strict source route */
+#define	IPOPT_RA		148		/* router alert */
+
+/*
+ * Offsets to fields in options other than EOL and NOP.
+ */
+#define	IPOPT_OPTVAL		0		/* option ID */
+#define	IPOPT_OLEN		1		/* option length */
+#define	IPOPT_OFFSET		2		/* offset within option */
+#define	IPOPT_MINOFF		4		/* min value of above */
+
+#define	MAX_IPOPTLEN		40
+
+/* flag bits for ipt_flg */
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+/* bits for security (not byte swapped) */
+#define	IPOPT_SECUR_UNCLASS	0x0000
+#define	IPOPT_SECUR_CONFID	0xf135
+#define	IPOPT_SECUR_EFTO	0x789a
+#define	IPOPT_SECUR_MMMM	0xbc4d
+#define	IPOPT_SECUR_RESTR	0xaf13
+#define	IPOPT_SECUR_SECRET	0xd788
+#define	IPOPT_SECUR_TOPSECRET	0x6bc5
+
+/*
+ * Internet implementation parameters.
+ */
+#define	MAXTTL		255		/* maximum time to live (seconds) */
+#define	IPDEFTTL	64		/* default ttl, from RFC 1340 */
+#define	IPFRAGTTL	60		/* time to live for frags, slowhz */
+#define	IPTTLDEC	1		/* subtracted when forwarding */
+
+#define	IP_MSS		576		/* default maximum segment size */
+
+__END_DECLS
+
+#endif /* netinet/ip.h */
diff -pruwN busybox-1.01/include2/netinet/ip_icmp.h busybox-1.01-livebox/include2/netinet/ip_icmp.h
--- busybox-1.01/include2/netinet/ip_icmp.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/netinet/ip_icmp.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,283 @@
+/* Copyright (C) 1991, 92, 93, 95, 96, 97, 99 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __NETINET_IP_ICMP_H
+#define __NETINET_IP_ICMP_H    1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+struct icmphdr
+{
+  u_int8_t type;		/* message type */
+  u_int8_t code;		/* type sub-code */
+  u_int16_t checksum;
+  union
+  {
+    struct
+    {
+      u_int16_t	id;
+      u_int16_t	sequence;
+    } echo;			/* echo datagram */
+    u_int32_t	gateway;	/* gateway address */
+    struct
+    {
+      u_int16_t	__unused;
+      u_int16_t	mtu;
+    } frag;			/* path mtu discovery */
+  } un;
+};
+
+#define ICMP_ECHOREPLY		0	/* Echo Reply			*/
+#define ICMP_DEST_UNREACH	3	/* Destination Unreachable	*/
+#define ICMP_SOURCE_QUENCH	4	/* Source Quench		*/
+#define ICMP_REDIRECT		5	/* Redirect (change route)	*/
+#define ICMP_ECHO		8	/* Echo Request			*/
+#define ICMP_TIME_EXCEEDED	11	/* Time Exceeded		*/
+#define ICMP_PARAMETERPROB	12	/* Parameter Problem		*/
+#define ICMP_TIMESTAMP		13	/* Timestamp Request		*/
+#define ICMP_TIMESTAMPREPLY	14	/* Timestamp Reply		*/
+#define ICMP_INFO_REQUEST	15	/* Information Request		*/
+#define ICMP_INFO_REPLY		16	/* Information Reply		*/
+#define ICMP_ADDRESS		17	/* Address Mask Request		*/
+#define ICMP_ADDRESSREPLY	18	/* Address Mask Reply		*/
+#define NR_ICMP_TYPES		18
+
+
+/* Codes for UNREACH. */
+#define ICMP_NET_UNREACH	0	/* Network Unreachable		*/
+#define ICMP_HOST_UNREACH	1	/* Host Unreachable		*/
+#define ICMP_PROT_UNREACH	2	/* Protocol Unreachable		*/
+#define ICMP_PORT_UNREACH	3	/* Port Unreachable		*/
+#define ICMP_FRAG_NEEDED	4	/* Fragmentation Needed/DF set	*/
+#define ICMP_SR_FAILED		5	/* Source Route failed		*/
+#define ICMP_NET_UNKNOWN	6
+#define ICMP_HOST_UNKNOWN	7
+#define ICMP_HOST_ISOLATED	8
+#define ICMP_NET_ANO		9
+#define ICMP_HOST_ANO		10
+#define ICMP_NET_UNR_TOS	11
+#define ICMP_HOST_UNR_TOS	12
+#define ICMP_PKT_FILTERED	13	/* Packet filtered */
+#define ICMP_PREC_VIOLATION	14	/* Precedence violation */
+#define ICMP_PREC_CUTOFF	15	/* Precedence cut off */
+#define NR_ICMP_UNREACH		15	/* instead of hardcoding immediate value */
+
+/* Codes for REDIRECT. */
+#define ICMP_REDIR_NET		0	/* Redirect Net			*/
+#define ICMP_REDIR_HOST		1	/* Redirect Host		*/
+#define ICMP_REDIR_NETTOS	2	/* Redirect Net for TOS		*/
+#define ICMP_REDIR_HOSTTOS	3	/* Redirect Host for TOS	*/
+
+/* Codes for TIME_EXCEEDED. */
+#define ICMP_EXC_TTL		0	/* TTL count exceeded		*/
+#define ICMP_EXC_FRAGTIME	1	/* Fragment Reass time exceeded	*/
+
+
+#ifdef __USE_BSD
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip_icmp.h	8.1 (Berkeley) 6/10/93
+ */
+
+#include <netinet/in.h>
+#include <netinet/ip.h>
+
+/*
+ * Internal of an ICMP Router Advertisement
+ */
+struct icmp_ra_addr
+{
+  u_int32_t ira_addr;
+  u_int32_t ira_preference;
+};
+
+struct icmp
+{
+  u_int8_t  icmp_type;	/* type of message, see below */
+  u_int8_t  icmp_code;	/* type sub code */
+  u_int16_t icmp_cksum;	/* ones complement checksum of struct */
+  union
+  {
+    u_char ih_pptr;		/* ICMP_PARAMPROB */
+    struct in_addr ih_gwaddr;	/* gateway address */
+    struct ih_idseq		/* echo datagram */
+    {
+      u_int16_t icd_id;
+      u_int16_t icd_seq;
+    } ih_idseq;
+    u_int32_t ih_void;
+
+    /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */
+    struct ih_pmtu
+    {
+      u_int16_t ipm_void;
+      u_int16_t ipm_nextmtu;
+    } ih_pmtu;
+
+    struct ih_rtradv
+    {
+      u_int8_t irt_num_addrs;
+      u_int8_t irt_wpa;
+      u_int16_t irt_lifetime;
+    } ih_rtradv;
+  } icmp_hun;
+#define	icmp_pptr	icmp_hun.ih_pptr
+#define	icmp_gwaddr	icmp_hun.ih_gwaddr
+#define	icmp_id		icmp_hun.ih_idseq.icd_id
+#define	icmp_seq	icmp_hun.ih_idseq.icd_seq
+#define	icmp_void	icmp_hun.ih_void
+#define	icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
+#define	icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
+#define	icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
+#define	icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
+#define	icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
+  union
+  {
+    struct
+    {
+      u_int32_t its_otime;
+      u_int32_t its_rtime;
+      u_int32_t its_ttime;
+    } id_ts;
+    struct
+    {
+      struct ip idi_ip;
+      /* options and then 64 bits of data */
+    } id_ip;
+    struct icmp_ra_addr id_radv;
+    u_int32_t   id_mask;
+    u_int8_t    id_data[1];
+  } icmp_dun;
+#define	icmp_otime	icmp_dun.id_ts.its_otime
+#define	icmp_rtime	icmp_dun.id_ts.its_rtime
+#define	icmp_ttime	icmp_dun.id_ts.its_ttime
+#define	icmp_ip		icmp_dun.id_ip.idi_ip
+#define	icmp_radv	icmp_dun.id_radv
+#define	icmp_mask	icmp_dun.id_mask
+#define	icmp_data	icmp_dun.id_data
+};
+
+/*
+ * Lower bounds on packet lengths for various types.
+ * For the error advice packets must first insure that the
+ * packet is large enough to contain the returned ip header.
+ * Only then can we do the check to see if 64 bits of packet
+ * data have been returned, since we need to check the returned
+ * ip header length.
+ */
+#define	ICMP_MINLEN	8				/* abs minimum */
+#define	ICMP_TSLEN	(8 + 3 * sizeof (n_time))	/* timestamp */
+#define	ICMP_MASKLEN	12				/* address mask */
+#define	ICMP_ADVLENMIN	(8 + sizeof (struct ip) + 8)	/* min */
+#ifndef _IP_VHL
+#define	ICMP_ADVLEN(p)	(8 + ((p)->icmp_ip.ip_hl << 2) + 8)
+	/* N.B.: must separately check that ip_hl >= 5 */
+#else
+#define	ICMP_ADVLEN(p)	(8 + (IP_VHL_HL((p)->icmp_ip.ip_vhl) << 2) + 8)
+	/* N.B.: must separately check that header length >= 5 */
+#endif
+
+/* Definition of type and code fields. */
+/* defined above: ICMP_ECHOREPLY, ICMP_REDIRECT, ICMP_ECHO */
+#define	ICMP_UNREACH		3		/* dest unreachable, codes: */
+#define	ICMP_SOURCEQUENCH	4		/* packet lost, slow down */
+#define	ICMP_ROUTERADVERT	9		/* router advertisement */
+#define	ICMP_ROUTERSOLICIT	10		/* router solicitation */
+#define	ICMP_TIMXCEED		11		/* time exceeded, code: */
+#define	ICMP_PARAMPROB		12		/* ip header bad */
+#define	ICMP_TSTAMP		13		/* timestamp request */
+#define	ICMP_TSTAMPREPLY	14		/* timestamp reply */
+#define	ICMP_IREQ		15		/* information request */
+#define	ICMP_IREQREPLY		16		/* information reply */
+#define	ICMP_MASKREQ		17		/* address mask request */
+#define	ICMP_MASKREPLY		18		/* address mask reply */
+
+#define	ICMP_MAXTYPE		18
+
+/* UNREACH codes */
+#define	ICMP_UNREACH_NET	        0	/* bad net */
+#define	ICMP_UNREACH_HOST	        1	/* bad host */
+#define	ICMP_UNREACH_PROTOCOL	        2	/* bad protocol */
+#define	ICMP_UNREACH_PORT	        3	/* bad port */
+#define	ICMP_UNREACH_NEEDFRAG	        4	/* IP_DF caused drop */
+#define	ICMP_UNREACH_SRCFAIL	        5	/* src route failed */
+#define	ICMP_UNREACH_NET_UNKNOWN        6	/* unknown net */
+#define	ICMP_UNREACH_HOST_UNKNOWN       7	/* unknown host */
+#define	ICMP_UNREACH_ISOLATED	        8	/* src host isolated */
+#define	ICMP_UNREACH_NET_PROHIB	        9	/* net denied */
+#define	ICMP_UNREACH_HOST_PROHIB        10	/* host denied */
+#define	ICMP_UNREACH_TOSNET	        11	/* bad tos for net */
+#define	ICMP_UNREACH_TOSHOST	        12	/* bad tos for host */
+#define	ICMP_UNREACH_FILTER_PROHIB      13	/* admin prohib */
+#define	ICMP_UNREACH_HOST_PRECEDENCE    14	/* host prec vio. */
+#define	ICMP_UNREACH_PRECEDENCE_CUTOFF  15	/* prec cutoff */
+
+/* REDIRECT codes */
+#define	ICMP_REDIRECT_NET	0		/* for network */
+#define	ICMP_REDIRECT_HOST	1		/* for host */
+#define	ICMP_REDIRECT_TOSNET	2		/* for tos and net */
+#define	ICMP_REDIRECT_TOSHOST	3		/* for tos and host */
+
+/* TIMEXCEED codes */
+#define	ICMP_TIMXCEED_INTRANS	0		/* ttl==0 in transit */
+#define	ICMP_TIMXCEED_REASS	1		/* ttl==0 in reass */
+
+/* PARAMPROB code */
+#define	ICMP_PARAMPROB_OPTABSENT 1		/* req. opt. absent */
+
+#define	ICMP_INFOTYPE(type) \
+	((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || \
+	(type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || \
+	(type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || \
+	(type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || \
+	(type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)
+
+#endif /* __USE_BSD */
+
+__END_DECLS
+
+#endif /* netinet/ip_icmp.h */
diff -pruwN busybox-1.01/include2/paths.h busybox-1.01-livebox/include2/paths.h
--- busybox-1.01/include2/paths.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/paths.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)paths.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _PATHS_H_
+#define	_PATHS_H_
+
+/* Default search path. */
+#define	_PATH_DEFPATH	"/usr/bin:/bin"
+/* All standard utilities path. */
+#define	_PATH_STDPATH \
+	"/usr/bin:/bin:/usr/sbin:/sbin"
+
+#define	_PATH_BSHELL	"/bin/sh"
+#define	_PATH_CONSOLE	"/dev/console"
+#define	_PATH_CSHELL	"/bin/csh"
+#define	_PATH_DEVDB	"/var/run/dev.db"
+#define	_PATH_DEVNULL	"/dev/null"
+#define	_PATH_DRUM	"/dev/drum"
+#define	_PATH_KLOG	"/proc/kmsg"
+#define	_PATH_KMEM	"/dev/kmem"
+#define	_PATH_LASTLOG	"/var/log/lastlog"
+#define	_PATH_MAILDIR	"/var/mail"
+#define	_PATH_MAN	"/usr/share/man"
+#define	_PATH_MEM	"/dev/mem"
+#define	_PATH_MNTTAB	"/etc/fstab"
+#define	_PATH_MOUNTED	"/etc/mtab"
+#define	_PATH_NOLOGIN	"/etc/nologin"
+#define	_PATH_PRESERVE	"/var/lib"
+#define	_PATH_RWHODIR	"/var/spool/rwho"
+#define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
+#define	_PATH_SHELLS	"/etc/shells"
+#define	_PATH_TTY	"/dev/tty"
+#define	_PATH_UNIX	"/boot/vmlinux"
+#define	_PATH_UTMP	"/var/run/utmp"
+#define	_PATH_VI	"/usr/bin/vi"
+#define	_PATH_WTMP	"/var/log/wtmp"
+#define	_PATH_LOCALE	"/usr/lib/locale"
+#define	_PATH_LASTLOG	"/var/log/lastlog"
+#define	_PATH_SHADOW	"/etc/shadow"
+#define	_PATH_PASSWD	"/etc/passwd"
+#define	_PATH_GROUP	"/etc/group"
+
+/* Provide trailing slash, since mostly used for building pathnames. */
+#define	_PATH_DEV	"/dev/"
+#define	_PATH_TMP	"/tmp/"
+#define	_PATH_VARDB	"/var/lib/misc/"
+#define	_PATH_VARRUN	"/var/run/"
+#define	_PATH_VARTMP	"/var/tmp/"
+
+#endif /* !_PATHS_H_ */
diff -pruwN busybox-1.01/include2/pwd.h busybox-1.01-livebox/include2/pwd.h
--- busybox-1.01/include2/pwd.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/pwd.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,147 @@
+/* Copyright (C) 1991,92,95,96,97,98,99,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 9.2.2 User Database Access	<pwd.h>
+ */
+
+#ifndef	_PWD_H
+#define	_PWD_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/types.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+#ifdef __USE_XOPEN
+/* The Single Unix specification says that some more types are
+   available here.  */
+# ifndef __gid_t_defined
+typedef __gid_t gid_t;
+#  define __gid_t_defined
+# endif
+
+# ifndef __uid_t_defined
+typedef __uid_t uid_t;
+#  define __uid_t_defined
+# endif
+#endif
+
+/* The passwd structure.  */
+struct passwd
+{
+  char *pw_name;		/* Username.  */
+  char *pw_passwd;		/* Password.  */
+  __uid_t pw_uid;		/* User ID.  */
+  __gid_t pw_gid;		/* Group ID.  */
+  char *pw_gecos;		/* Real name.  */
+  char *pw_dir;			/* Home directory.  */
+  char *pw_shell;		/* Shell program.  */
+};
+
+
+#if defined __USE_SVID || defined __USE_GNU
+# define __need_FILE
+# include <stdio.h>
+#endif
+
+
+#if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN_EXTENDED
+/* Rewind the password-file stream.  */
+extern void setpwent (void) __THROW;
+
+/* Close the password-file stream.  */
+extern void endpwent (void) __THROW;
+
+/* Read an entry from the password-file stream, opening it if necessary.  */
+extern struct passwd *getpwent (void) __THROW;
+#endif
+
+#ifdef	__USE_SVID
+/* Read an entry from STREAM.  */
+extern struct passwd *fgetpwent (FILE *__stream) __THROW;
+
+/* Write the given entry onto the given stream.  */
+extern int putpwent (__const struct passwd *__restrict __p,
+		     FILE *__restrict __f) __THROW;
+#endif
+
+/* Search for an entry with a matching user ID.  */
+extern struct passwd *getpwuid (__uid_t __uid) __THROW;
+
+/* Search for an entry with a matching username.  */
+extern struct passwd *getpwnam (__const char *__name) __THROW;
+
+#if defined __USE_POSIX || defined __USE_MISC
+
+# ifdef __USE_MISC
+/* Reasonable value for the buffer sized used in the reentrant
+   functions below.  But better use `sysconf'.  */
+#  define NSS_BUFLEN_PASSWD	1024
+# endif
+
+/* Reentrant versions of some of the functions above.
+
+   PLEASE NOTE: the `getpwent_r' function is not (yet) standardized.
+   The interface may change in later versions of this library.  But
+   the interface is designed following the principals used for the
+   other reentrant functions so the chances are good this is what the
+   POSIX people would choose.  */
+
+# if defined __USE_SVID || defined __USE_MISC
+extern int getpwent_r (struct passwd *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct passwd **__restrict __result) __THROW;
+# endif
+
+extern int getpwuid_r (__uid_t __uid,
+		       struct passwd *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct passwd **__restrict __result) __THROW;
+
+extern int getpwnam_r (__const char *__restrict __name,
+		       struct passwd *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct passwd **__restrict __result) __THROW;
+
+
+# ifdef	__USE_SVID
+/* Read an entry from STREAM.  This function is not standardized and
+   probably never will.  */
+extern int fgetpwent_r (FILE *__restrict __stream,
+			struct passwd *__restrict __resultbuf,
+			char *__restrict __buffer, size_t __buflen,
+			struct passwd **__restrict __result) __THROW;
+# endif
+
+#endif	/* POSIX or reentrant */
+
+#ifdef __USE_GNU
+/* Re-construct the password-file line for the given uid
+   in the given buffer.  This knows the format that the caller
+   will expect, but this need not be the format of the password file.  */
+extern int getpw (__uid_t __uid, char *__buffer) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* pwd.h  */
diff -pruwN busybox-1.01/include2/regex.h busybox-1.01-livebox/include2/regex.h
--- busybox-1.01/include2/regex.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/regex.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,574 @@
+/* Definitions for data structures and routines for the regular
+   expression library.
+   Copyright (C) 1985,1989-93,1995-98,2000,2001,2002
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _REGEX_H
+#define _REGEX_H 1
+
+/* Allow the use in C++ code.  */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* POSIX says that <sys/types.h> must be included (by the caller) before
+   <regex.h>.  */
+
+#if !defined _POSIX_C_SOURCE && !defined _POSIX_SOURCE && defined VMS
+/* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it
+   should be there.  */
+# include <stddef.h>
+#endif
+
+/* The following two types have to be signed and unsigned integer type
+   wide enough to hold a value of a pointer.  For most ANSI compilers
+   ptrdiff_t and size_t should be likely OK.  Still size of these two
+   types is 2 for Microsoft C.  Ugh... */
+typedef long int s_reg_t;
+typedef unsigned long int active_reg_t;
+
+/* The following bits are used to determine the regexp syntax we
+   recognize.  The set/not-set meanings are chosen so that Emacs syntax
+   remains the value 0.  The bits are given in alphabetical order, and
+   the definitions shifted by one from the previous bit; thus, when we
+   add or remove a bit, only one other definition need change.  */
+typedef unsigned long int reg_syntax_t;
+
+/* If this bit is not set, then \ inside a bracket expression is literal.
+   If set, then such a \ quotes the following character.  */
+#define RE_BACKSLASH_ESCAPE_IN_LISTS ((unsigned long int) 1)
+
+/* If this bit is not set, then + and ? are operators, and \+ and \? are
+     literals.
+   If set, then \+ and \? are operators and + and ? are literals.  */
+#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
+
+/* If this bit is set, then character classes are supported.  They are:
+     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
+     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
+   If not set, then character classes are not supported.  */
+#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
+
+/* If this bit is set, then ^ and $ are always anchors (outside bracket
+     expressions, of course).
+   If this bit is not set, then it depends:
+        ^  is an anchor if it is at the beginning of a regular
+           expression or after an open-group or an alternation operator;
+        $  is an anchor if it is at the end of a regular expression, or
+           before a close-group or an alternation operator.
+
+   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
+   POSIX draft 11.2 says that * etc. in leading positions is undefined.
+   We already implemented a previous draft which made those constructs
+   invalid, though, so we haven't changed the code back.  */
+#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
+
+/* If this bit is set, then special characters are always special
+     regardless of where they are in the pattern.
+   If this bit is not set, then special characters are special only in
+     some contexts; otherwise they are ordinary.  Specifically,
+     * + ? and intervals are only special when not after the beginning,
+     open-group, or alternation operator.  */
+#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
+
+/* If this bit is set, then *, +, ?, and { cannot be first in an re or
+     immediately after an alternation or begin-group operator.  */
+#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
+
+/* If this bit is set, then . matches newline.
+   If not set, then it doesn't.  */
+#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
+
+/* If this bit is set, then . doesn't match NUL.
+   If not set, then it does.  */
+#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
+
+/* If this bit is set, nonmatching lists [^...] do not match newline.
+   If not set, they do.  */
+#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
+
+/* If this bit is set, either \{...\} or {...} defines an
+     interval, depending on RE_NO_BK_BRACES.
+   If not set, \{, \}, {, and } are literals.  */
+#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
+
+/* If this bit is set, +, ? and | aren't recognized as operators.
+   If not set, they are.  */
+#define RE_LIMITED_OPS (RE_INTERVALS << 1)
+
+/* If this bit is set, newline is an alternation operator.
+   If not set, newline is literal.  */
+#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
+
+/* If this bit is set, then `{...}' defines an interval, and \{ and \}
+     are literals.
+  If not set, then `\{...\}' defines an interval.  */
+#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
+
+/* If this bit is set, (...) defines a group, and \( and \) are literals.
+   If not set, \(...\) defines a group, and ( and ) are literals.  */
+#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
+
+/* If this bit is set, then \<digit> matches <digit>.
+   If not set, then \<digit> is a back-reference.  */
+#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
+
+/* If this bit is set, then | is an alternation operator, and \| is literal.
+   If not set, then \| is an alternation operator, and | is literal.  */
+#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
+
+/* If this bit is set, then an ending range point collating higher
+     than the starting range point, as in [z-a], is invalid.
+   If not set, then when ending range point collates higher than the
+     starting range point, the range is ignored.  */
+#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
+
+/* If this bit is set, then an unmatched ) is ordinary.
+   If not set, then an unmatched ) is invalid.  */
+#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
+
+/* If this bit is set, succeed as soon as we match the whole pattern,
+   without further backtracking.  */
+#define RE_NO_POSIX_BACKTRACKING (RE_UNMATCHED_RIGHT_PAREN_ORD << 1)
+
+/* If this bit is set, do not process the GNU regex operators.
+   If not set, then the GNU regex operators are recognized. */
+#define RE_NO_GNU_OPS (RE_NO_POSIX_BACKTRACKING << 1)
+
+/* If this bit is set, turn on internal regex debugging.
+   If not set, and debugging was on, turn it off.
+   This only works if regex.c is compiled -DDEBUG.
+   We define this bit always, so that all that's needed to turn on
+   debugging is to recompile regex.c; the calling code can always have
+   this bit set, and it won't affect anything in the normal case. */
+#define RE_DEBUG (RE_NO_GNU_OPS << 1)
+
+/* If this bit is set, a syntactically invalid interval is treated as
+   a string of ordinary characters.  For example, the ERE 'a{1' is
+   treated as 'a\{1'.  */
+#define RE_INVALID_INTERVAL_ORD (RE_DEBUG << 1)
+
+/* If this bit is set, then ignore case when matching.
+   If not set, then case is significant.  */
+#define RE_ICASE (RE_INVALID_INTERVAL_ORD << 1)
+
+/* This global variable defines the particular regexp syntax to use (for
+   some interfaces).  When a regexp is compiled, the syntax used is
+   stored in the pattern buffer, so changing this does not affect
+   already-compiled regexps.  */
+extern reg_syntax_t re_syntax_options;
+
+/* Define combinations of the above bits for the standard possibilities.
+   (The [[[ comments delimit what gets put into the Texinfo file, so
+   don't delete them!)  */
+/* [[[begin syntaxes]]] */
+#define RE_SYNTAX_EMACS 0
+
+#define RE_SYNTAX_AWK							\
+  (RE_BACKSLASH_ESCAPE_IN_LISTS   | RE_DOT_NOT_NULL			\
+   | RE_NO_BK_PARENS              | RE_NO_BK_REFS			\
+   | RE_NO_BK_VBAR                | RE_NO_EMPTY_RANGES			\
+   | RE_DOT_NEWLINE		  | RE_CONTEXT_INDEP_ANCHORS		\
+   | RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS)
+
+#define RE_SYNTAX_GNU_AWK						\
+  ((RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DEBUG)	\
+   & ~(RE_DOT_NOT_NULL | RE_INTERVALS | RE_CONTEXT_INDEP_OPS		\
+       | RE_CONTEXT_INVALID_OPS ))
+
+#define RE_SYNTAX_POSIX_AWK 						\
+  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS		\
+   | RE_INTERVALS	    | RE_NO_GNU_OPS)
+
+#define RE_SYNTAX_GREP							\
+  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES				\
+   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS				\
+   | RE_NEWLINE_ALT)
+
+#define RE_SYNTAX_EGREP							\
+  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE			\
+   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS				\
+   | RE_NO_BK_VBAR)
+
+#define RE_SYNTAX_POSIX_EGREP						\
+  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES			\
+   | RE_INVALID_INTERVAL_ORD)
+
+/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
+#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
+
+#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
+
+/* Syntax bits common to both basic and extended POSIX regex syntax.  */
+#define _RE_SYNTAX_POSIX_COMMON						\
+  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL		\
+   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
+
+#define RE_SYNTAX_POSIX_BASIC						\
+  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
+
+/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
+   RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
+   isn't minimal, since other operators, such as \`, aren't disabled.  */
+#define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
+  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
+
+#define RE_SYNTAX_POSIX_EXTENDED					\
+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INDEP_OPS   | RE_NO_BK_BRACES				\
+   | RE_NO_BK_PARENS        | RE_NO_BK_VBAR				\
+   | RE_CONTEXT_INVALID_OPS | RE_UNMATCHED_RIGHT_PAREN_ORD)
+
+/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INDEP_OPS is
+   removed and RE_NO_BK_REFS is added.  */
+#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\
+   | RE_NO_BK_PARENS        | RE_NO_BK_REFS				\
+   | RE_NO_BK_VBAR	    | RE_UNMATCHED_RIGHT_PAREN_ORD)
+/* [[[end syntaxes]]] */
+
+/* Maximum number of duplicates an interval can allow.  Some systems
+   (erroneously) define this in other header files, but we want our
+   value, so remove any previous define.  */
+#ifdef RE_DUP_MAX
+# undef RE_DUP_MAX
+#endif
+/* If sizeof(int) == 2, then ((1 << 15) - 1) overflows.  */
+#define RE_DUP_MAX (0x7fff)
+
+
+/* POSIX `cflags' bits (i.e., information for `regcomp').  */
+
+/* If this bit is set, then use extended regular expression syntax.
+   If not set, then use basic regular expression syntax.  */
+#define REG_EXTENDED 1
+
+/* If this bit is set, then ignore case when matching.
+   If not set, then case is significant.  */
+#define REG_ICASE (REG_EXTENDED << 1)
+
+/* If this bit is set, then anchors do not match at newline
+     characters in the string.
+   If not set, then anchors do match at newlines.  */
+#define REG_NEWLINE (REG_ICASE << 1)
+
+/* If this bit is set, then report only success or fail in regexec.
+   If not set, then returns differ between not matching and errors.  */
+#define REG_NOSUB (REG_NEWLINE << 1)
+
+
+/* POSIX `eflags' bits (i.e., information for regexec).  */
+
+/* If this bit is set, then the beginning-of-line operator doesn't match
+     the beginning of the string (presumably because it's not the
+     beginning of a line).
+   If not set, then the beginning-of-line operator does match the
+     beginning of the string.  */
+#define REG_NOTBOL 1
+
+/* Like REG_NOTBOL, except for the end-of-line.  */
+#define REG_NOTEOL (1 << 1)
+
+
+/* If any error codes are removed, changed, or added, update the
+   `re_error_msg' table in regex.c.  */
+typedef enum
+{
+#ifdef _XOPEN_SOURCE
+  REG_ENOSYS = -1,	/* This will never happen for this implementation.  */
+#endif
+
+  REG_NOERROR = 0,	/* Success.  */
+  REG_NOMATCH,		/* Didn't find a match (for regexec).  */
+
+  /* POSIX regcomp return error codes.  (In the order listed in the
+     standard.)  */
+  REG_BADPAT,		/* Invalid pattern.  */
+  REG_ECOLLATE,		/* Not implemented.  */
+  REG_ECTYPE,		/* Invalid character class name.  */
+  REG_EESCAPE,		/* Trailing backslash.  */
+  REG_ESUBREG,		/* Invalid back reference.  */
+  REG_EBRACK,		/* Unmatched left bracket.  */
+  REG_EPAREN,		/* Parenthesis imbalance.  */
+  REG_EBRACE,		/* Unmatched \{.  */
+  REG_BADBR,		/* Invalid contents of \{\}.  */
+  REG_ERANGE,		/* Invalid range end.  */
+  REG_ESPACE,		/* Ran out of memory.  */
+  REG_BADRPT,		/* No preceding re for repetition op.  */
+
+  /* Error codes we've added.  */
+  REG_EEND,		/* Premature end.  */
+  REG_ESIZE,		/* Compiled pattern bigger than 2^16 bytes.  */
+  REG_ERPAREN		/* Unmatched ) or \); not returned from regcomp.  */
+} reg_errcode_t;
+
+/* This data structure represents a compiled pattern.  Before calling
+   the pattern compiler, the fields `buffer', `allocated', `fastmap',
+   `translate', and `no_sub' can be set.  After the pattern has been
+   compiled, the `re_nsub' field is available.  All other fields are
+   private to the regex routines.  */
+
+#ifndef RE_TRANSLATE_TYPE
+# define RE_TRANSLATE_TYPE char *
+#endif
+
+struct re_pattern_buffer
+{
+/* [[[begin pattern_buffer]]] */
+	/* Space that holds the compiled pattern.  It is declared as
+          `unsigned char *' because its elements are
+           sometimes used as array indexes.  */
+  unsigned char *buffer;
+
+	/* Number of bytes to which `buffer' points.  */
+  unsigned long int allocated;
+
+	/* Number of bytes actually used in `buffer'.  */
+  unsigned long int used;
+
+        /* Syntax setting with which the pattern was compiled.  */
+  reg_syntax_t syntax;
+
+        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
+           the fastmap, if there is one, to skip over impossible
+           starting points for matches.  */
+  char *fastmap;
+
+        /* Either a translate table to apply to all characters before
+           comparing them, or zero for no translation.  The translation
+           is applied to a pattern when it is compiled and to a string
+           when it is matched.  */
+  RE_TRANSLATE_TYPE translate;
+
+	/* Number of subexpressions found by the compiler.  */
+  size_t re_nsub;
+
+        /* Zero if this pattern cannot match the empty string, one else.
+           Well, in truth it's used only in `re_search_2', to see
+           whether or not we should use the fastmap, so we don't set
+           this absolutely perfectly; see `re_compile_fastmap' (the
+           `duplicate' case).  */
+  unsigned can_be_null : 1;
+
+        /* If REGS_UNALLOCATED, allocate space in the `regs' structure
+             for `max (RE_NREGS, re_nsub + 1)' groups.
+           If REGS_REALLOCATE, reallocate space if necessary.
+           If REGS_FIXED, use what's there.  */
+#define REGS_UNALLOCATED 0
+#define REGS_REALLOCATE 1
+#define REGS_FIXED 2
+  unsigned regs_allocated : 2;
+
+        /* Set to zero when `regex_compile' compiles a pattern; set to one
+           by `re_compile_fastmap' if it updates the fastmap.  */
+  unsigned fastmap_accurate : 1;
+
+        /* If set, `re_match_2' does not return information about
+           subexpressions.  */
+  unsigned no_sub : 1;
+
+        /* If set, a beginning-of-line anchor doesn't match at the
+           beginning of the string.  */
+  unsigned not_bol : 1;
+
+        /* Similarly for an end-of-line anchor.  */
+  unsigned not_eol : 1;
+
+        /* If true, an anchor at a newline matches.  */
+  unsigned newline_anchor : 1;
+
+/* [[[end pattern_buffer]]] */
+};
+
+typedef struct re_pattern_buffer regex_t;
+
+/* Type for byte offsets within the string.  POSIX mandates this.  */
+typedef int regoff_t;
+
+
+/* This is the structure we store register match data in.  See
+   regex.texinfo for a full description of what registers match.  */
+struct re_registers
+{
+  unsigned num_regs;
+  regoff_t *start;
+  regoff_t *end;
+};
+
+
+/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
+   `re_match_2' returns information about at least this many registers
+   the first time a `regs' structure is passed.  */
+#ifndef RE_NREGS
+# define RE_NREGS 30
+#endif
+
+
+/* POSIX specification for registers.  Aside from the different names than
+   `re_registers', POSIX uses an array of structures, instead of a
+   structure of arrays.  */
+typedef struct
+{
+  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */
+  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */
+} regmatch_t;
+
+/* Declarations for routines.  */
+
+/* To avoid duplicating every routine declaration -- once with a
+   prototype (if we are ANSI), and once without (if we aren't) -- we
+   use the following macro to declare argument types.  This
+   unfortunately clutters up the declarations a bit, but I think it's
+   worth it.  */
+
+#if __STDC__
+
+# define _RE_ARGS(args) args
+
+#else /* not __STDC__ */
+
+# define _RE_ARGS(args) ()
+
+#endif /* not __STDC__ */
+
+/* Sets the current default syntax to SYNTAX, and return the old syntax.
+   You can also simply assign to the `re_syntax_options' variable.  */
+extern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));
+
+/* Compile the regular expression PATTERN, with length LENGTH
+   and syntax given by the global `re_syntax_options', into the buffer
+   BUFFER.  Return NULL if successful, and an error string if not.  */
+extern const char *re_compile_pattern
+  _RE_ARGS ((const char *pattern, size_t length,
+             struct re_pattern_buffer *buffer));
+
+
+/* Compile a fastmap for the compiled pattern in BUFFER; used to
+   accelerate searches.  Return 0 if successful and -2 if was an
+   internal error.  */
+extern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));
+
+
+/* Search in the string STRING (with length LENGTH) for the pattern
+   compiled into BUFFER.  Start searching at position START, for RANGE
+   characters.  Return the starting position of the match, -1 for no
+   match, or -2 for an internal error.  Also return register
+   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */
+extern int re_search
+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,
+            int length, int start, int range, struct re_registers *regs));
+
+
+/* Like `re_search', but search in the concatenation of STRING1 and
+   STRING2.  Also, stop searching at index START + STOP.  */
+extern int re_search_2
+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,
+             int length1, const char *string2, int length2,
+             int start, int range, struct re_registers *regs, int stop));
+
+
+/* Like `re_search', but return how many characters in STRING the regexp
+   in BUFFER matched, starting at position START.  */
+extern int re_match
+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,
+             int length, int start, struct re_registers *regs));
+
+
+/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */
+extern int re_match_2
+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,
+             int length1, const char *string2, int length2,
+             int start, struct re_registers *regs, int stop));
+
+
+/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
+   ENDS.  Subsequent matches using BUFFER and REGS will use this memory
+   for recording register information.  STARTS and ENDS must be
+   allocated with malloc, and must each be at least `NUM_REGS * sizeof
+   (regoff_t)' bytes long.
+
+   If NUM_REGS == 0, then subsequent matches should allocate their own
+   register data.
+
+   Unless this function is called, the first search or match using
+   PATTERN_BUFFER will allocate its own register data, without
+   freeing the old data.  */
+extern void re_set_registers
+  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,
+             unsigned num_regs, regoff_t *starts, regoff_t *ends));
+
+#if defined _REGEX_RE_COMP || defined _LIBC
+# ifndef _CRAY
+/* 4.2 bsd compatibility.  */
+extern char *re_comp _RE_ARGS ((const char *));
+extern int re_exec _RE_ARGS ((const char *));
+# endif
+#endif
+
+/* GCC 2.95 and later have "__restrict"; C99 compilers have
+   "restrict", and "configure" may have defined "restrict".  */
+#ifndef __restrict
+# if ! (2 < __GNUC__ || (2 == __GNUC__ && 95 <= __GNUC_MINOR__))
+#  if defined restrict || 199901L <= __STDC_VERSION__
+#   define __restrict restrict
+#  else
+#   define __restrict
+#  endif
+# endif
+#endif
+/* gcc 3.1 and up support the [restrict] syntax.  */
+#ifndef __restrict_arr
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
+#  define __restrict_arr __restrict
+# else
+#  define __restrict_arr
+# endif
+#endif
+
+/* POSIX compatibility.  */
+extern int regcomp _RE_ARGS ((regex_t *__restrict __preg,
+			      const char *__restrict __pattern,
+			      int __cflags));
+
+extern int regexec _RE_ARGS ((const regex_t *__restrict __preg,
+			      const char *__restrict __string, size_t __nmatch,
+			      regmatch_t __pmatch[__restrict_arr],
+			      int __eflags));
+
+extern size_t regerror _RE_ARGS ((int __errcode, const regex_t *__preg,
+				  char *__errbuf, size_t __errbuf_size));
+
+extern void regfree _RE_ARGS ((regex_t *__preg));
+
+
+#ifdef __cplusplus
+}
+#endif	/* C++ */
+
+#endif /* regex.h */
+
+/*
+Local variables:
+make-backup-files: t
+version-control: t
+trim-versions-without-asking: nil
+End:
+*/
diff -pruwN busybox-1.01/include2/rpc/netdb.h busybox-1.01-livebox/include2/rpc/netdb.h
--- busybox-1.01/include2/rpc/netdb.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/rpc/netdb.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,74 @@
+/* @(#)netdb.h	2.1 88/07/29 3.9 RPCSRC */
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+/*	@(#)rpc.h 1.8 87/07/24 SMI	*/
+
+/* Cleaned up for GNU C library roland@gnu.ai.mit.edu:
+   added multiple inclusion protection and use of <sys/cdefs.h>.
+   In GNU this file is #include'd by <netdb.h>.  */
+
+#ifndef _RPC_NETDB_H
+#define _RPC_NETDB_H	1
+
+#include <features.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+__BEGIN_DECLS
+
+struct rpcent
+{
+  char *r_name;		/* Name of server for this rpc program.  */
+  char **r_aliases;	/* Alias list.  */
+  int r_number;		/* RPC program number.  */
+};
+
+extern void setrpcent (int __stayopen) __THROW;
+extern void endrpcent (void) __THROW;
+extern struct rpcent *getrpcbyname (__const char *__name) __THROW;
+extern struct rpcent *getrpcbynumber (int __number) __THROW;
+extern struct rpcent *getrpcent (void) __THROW;
+
+#ifdef __USE_MISC
+extern int getrpcbyname_r (__const char *__name, struct rpcent *__result_buf,
+			   char *__buffer, size_t __buflen,
+			   struct rpcent **__result) __THROW;
+
+extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
+			     char *__buffer, size_t __buflen,
+			     struct rpcent **__result) __THROW;
+
+extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
+			size_t __buflen, struct rpcent **__result) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* rpc/netdb.h */
diff -pruwN busybox-1.01/include2/setjmp.h busybox-1.01-livebox/include2/setjmp.h
--- busybox-1.01/include2/setjmp.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/setjmp.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,104 @@
+/* Copyright (C) 1991-1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99 Standard: 7.13 Nonlocal jumps	<setjmp.h>
+ */
+
+#ifndef	_SETJMP_H
+#define	_SETJMP_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/setjmp.h>		/* Get `__jmp_buf'.  */
+#include <bits/sigset.h>		/* Get `__sigset_t'.  */
+
+/* Calling environment, plus possibly a saved signal mask.  */
+typedef struct __jmp_buf_tag	/* C++ doesn't like tagless structs.  */
+  {
+    /* NOTE: The machine-dependent definitions of `__sigsetjmp'
+       assume that a `jmp_buf' begins with a `__jmp_buf' and that
+       `__mask_was_saved' follows it.  Do not move these members
+       or add others before it.  */
+    __jmp_buf __jmpbuf;		/* Calling environment.  */
+    int __mask_was_saved;	/* Saved the signal mask?  */
+    __sigset_t __saved_mask;	/* Saved signal mask.  */
+  } jmp_buf[1];
+
+
+/* Store the calling environment in ENV, also saving the signal mask.
+   Return 0.  */
+extern int setjmp (jmp_buf __env) __THROW;
+
+/* Store the calling environment in ENV, not saving the signal mask.
+   Return 0.  */
+extern int _setjmp (jmp_buf __env) __THROW;
+
+/* Store the calling environment in ENV, also saving the
+   signal mask if SAVEMASK is nonzero.  Return 0.
+   This is the internal name for `sigsetjmp'.  */
+extern int __sigsetjmp (jmp_buf __env, int __savemask) __THROW;
+
+#ifndef	__FAVOR_BSD
+/* Do not save the signal mask.  This is equivalent to the `_setjmp'
+   BSD function.  */
+# define setjmp(env)	_setjmp (env)
+#else
+/* We are in 4.3 BSD-compatibility mode in which `setjmp'
+   saves the signal mask like `sigsetjmp (ENV, 1)'.  We have to
+   define a macro since ISO C says `setjmp' is one.  */
+# define setjmp(env)	setjmp (env)
+#endif /* Favor BSD.  */
+
+
+/* Jump to the environment saved in ENV, making the
+   `setjmp' call there return VAL, or 1 if VAL is 0.  */
+extern void longjmp (jmp_buf __env, int __val)
+     __THROW __attribute__ ((__noreturn__));
+#if defined __USE_BSD || defined __USE_XOPEN
+/* Same.  Usually `_longjmp' is used with `_setjmp', which does not save
+   the signal mask.  But it is how ENV was saved that determines whether
+   `longjmp' restores the mask; `_longjmp' is just an alias.  */
+extern void _longjmp (jmp_buf __env, int __val)
+     __THROW __attribute__ ((__noreturn__));
+#endif
+
+
+#ifdef	__USE_POSIX
+/* Use the same type for `jmp_buf' and `sigjmp_buf'.
+   The `__mask_was_saved' flag determines whether
+   or not `longjmp' will restore the signal mask.  */
+typedef jmp_buf sigjmp_buf;
+
+/* Store the calling environment in ENV, also saving the
+   signal mask if SAVEMASK is nonzero.  Return 0.  */
+# define sigsetjmp(env, savemask)	__sigsetjmp (env, savemask)
+
+/* Jump to the environment saved in ENV, making the
+   sigsetjmp call there return VAL, or 1 if VAL is 0.
+   Restore the signal mask if that sigsetjmp call saved it.
+   This is just an alias `longjmp'.  */
+extern void siglongjmp (sigjmp_buf __env, int __val)
+     __THROW __attribute__ ((__noreturn__));
+#endif /* Use POSIX.  */
+
+__END_DECLS
+
+#endif /* setjmp.h  */
diff -pruwN busybox-1.01/include2/shadow.h busybox-1.01-livebox/include2/shadow.h
--- busybox-1.01/include2/shadow.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/shadow.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,105 @@
+/* Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Declaration of types and functions for shadow password suite.  */
+
+#ifndef _SHADOW_H
+#define _SHADOW_H	1
+
+#include <features.h>
+
+#include <paths.h>
+
+#define	__need_FILE
+#include <stdio.h>
+#define __need_size_t
+#include <stddef.h>
+
+/* Paths to the user database files.  */
+#define	SHADOW _PATH_SHADOW
+
+
+__BEGIN_DECLS
+
+/* Structure of the password file.  */
+struct spwd
+  {
+    char *sp_namp;		/* Login name.  */
+    char *sp_pwdp;		/* Encrypted password.  */
+    long int sp_lstchg;		/* Date of last change.  */
+    long int sp_min;		/* Minimum number of days between changes.  */
+    long int sp_max;		/* Maximum number of days between changes.  */
+    long int sp_warn;		/* Number of days to warn user to change
+				   the password.  */
+    long int sp_inact;		/* Number of days the account may be
+				   inactive.  */
+    long int sp_expire;		/* Number of days since 1970-01-01 until
+				   account expires.  */
+    unsigned long int sp_flag;	/* Reserved.  */
+  };
+
+
+/* Open database for reading.  */
+extern void setspent (void) __THROW;
+
+/* Close database.  */
+extern void endspent (void) __THROW;
+
+/* Get next entry from database, perhaps after opening the file.  */
+extern struct spwd *getspent (void) __THROW;
+
+/* Get shadow entry matching NAME.  */
+extern struct spwd *getspnam (__const char *__name) __THROW;
+
+/* Read shadow entry from STRING.  */
+extern struct spwd *sgetspent (__const char *__string) __THROW;
+
+/* Read next shadow entry from STREAM.  */
+extern struct spwd *fgetspent (FILE *__stream) __THROW;
+
+/* Write line containing shadow password entry to stream.  */
+extern int putspent (__const struct spwd *__p, FILE *__stream) __THROW;
+
+
+#ifdef __USE_MISC
+/* Reentrant versions of some of the functions above.  */
+extern int getspent_r (struct spwd *__result_buf, char *__buffer,
+		       size_t __buflen, struct spwd **__result) __THROW;
+
+extern int getspnam_r (__const char *__name, struct spwd *__result_buf,
+		       char *__buffer, size_t __buflen,
+		       struct spwd **__result)__THROW;
+
+extern int sgetspent_r (__const char *__string, struct spwd *__result_buf,
+			char *__buffer, size_t __buflen,
+			struct spwd **__result) __THROW;
+
+extern int fgetspent_r (FILE *__stream, struct spwd *__result_buf,
+			char *__buffer, size_t __buflen,
+			struct spwd **__result) __THROW;
+#endif	/* misc */
+
+/* Protect password file against multi writers.  */
+extern int lckpwdf (void) __THROW;
+
+/* Unlock password file.  */
+extern int ulckpwdf (void) __THROW;
+
+__END_DECLS
+
+#endif /* shadow.h */
diff -pruwN busybox-1.01/include2/signal.h busybox-1.01-livebox/include2/signal.h
--- busybox-1.01/include2/signal.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/signal.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,375 @@
+/* Copyright (C) 1991-1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99 Standard: 7.14 Signal handling <signal.h>
+ */
+
+#ifndef	_SIGNAL_H
+
+#if !defined __need_sig_atomic_t && !defined __need_sigset_t
+# define _SIGNAL_H
+#endif
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/sigset.h>		/* __sigset_t, __sig_atomic_t.  */
+
+/* An integral type that can be modified atomically, without the
+   possibility of a signal arriving in the middle of the operation.  */
+#if defined __need_sig_atomic_t || defined _SIGNAL_H
+# ifndef __sig_atomic_t_defined
+#  define __sig_atomic_t_defined
+typedef __sig_atomic_t sig_atomic_t;
+# endif
+# undef __need_sig_atomic_t
+#endif
+
+#if defined __need_sigset_t || (defined _SIGNAL_H && defined __USE_POSIX)
+# ifndef __sigset_t_defined
+#  define __sigset_t_defined
+typedef __sigset_t sigset_t;
+# endif
+# undef __need_sigset_t
+#endif
+
+#ifdef _SIGNAL_H
+
+#include <bits/types.h>
+#include <bits/signum.h>
+
+#ifdef __USE_XOPEN
+# ifndef __pid_t_defined
+typedef __pid_t pid_t;
+#  define __pid_t_defined
+# endif
+# ifndef __uid_t_defined
+typedef __uid_t uid_t;
+#  define __uid_t_defined
+# endif
+#endif	/* Unix98 */
+
+
+/* Type of a signal handler.  */
+typedef void (*__sighandler_t) (int);
+
+/* The X/Open definition of `signal' specifies the SVID semantic.  Use
+   the additional function `sysv_signal' when X/Open compatibility is
+   requested.  */
+extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
+     __THROW;
+#ifdef __USE_GNU
+extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
+     __THROW;
+#endif
+
+/* Set the handler for the signal SIG to HANDLER, returning the old
+   handler, or SIG_ERR on error.
+   By default `signal' has the BSD semantic.  */
+#ifdef __USE_BSD
+extern __sighandler_t signal (int __sig, __sighandler_t __handler) __THROW;
+#else
+/* Make sure the used `signal' implementation is the SVID version. */
+# ifdef __REDIRECT
+extern __sighandler_t __REDIRECT (signal,
+				  (int __sig,
+				   __sighandler_t __handler) __THROW,
+				  __sysv_signal);
+# else
+#  define signal __sysv_signal
+# endif
+#endif
+
+#ifdef __USE_XOPEN
+/* The X/Open definition of `signal' conflicts with the BSD version.
+   So they defined another function `bsd_signal'.  */
+extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler) __THROW;
+#endif
+
+/* Send signal SIG to process number PID.  If PID is zero,
+   send SIG to all processes in the current process's process group.
+   If PID is < -1, send SIG to all processes in process group - PID.  */
+#ifdef __USE_POSIX
+extern int kill (__pid_t __pid, int __sig) __THROW;
+#endif /* Use POSIX.  */
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Send SIG to all processes in process group PGRP.
+   If PGRP is zero, send SIG to all processes in
+   the current process's process group.  */
+extern int killpg (__pid_t __pgrp, int __sig) __THROW;
+#endif /* Use BSD || X/Open Unix.  */
+
+/* Raise signal SIG, i.e., send SIG to yourself.  */
+extern int raise (int __sig) __THROW;
+
+#ifdef __USE_SVID
+/* SVID names for the same things.  */
+extern __sighandler_t ssignal (int __sig, __sighandler_t __handler) __THROW;
+extern int gsignal (int __sig) __THROW;
+#endif /* Use SVID.  */
+
+#ifdef __USE_MISC
+/* Print a message describing the meaning of the given signal number.  */
+extern void psignal (int __sig, __const char *__s) __THROW;
+#endif /* Use misc.  */
+
+
+/* The `sigpause' function has two different interfaces.  The original
+   BSD definition defines the argument as a mask of the signal, while
+   the more modern interface in X/Open defines it as the signal
+   number.  We go with the BSD version unless the user explicitly
+   selects the X/Open version.  */
+extern int __sigpause (int __sig_or_mask, int __is_sig) __THROW;
+
+#ifdef __USE_BSD
+/* Set the mask of blocked signals to MASK,
+   wait for a signal to arrive, and then restore the mask.  */
+extern int sigpause (int __mask) __THROW;
+# define sigpause(mask) __sigpause ((mask), 0)
+#else
+# ifdef __USE_XOPEN
+#  ifdef __GNUC__
+extern int sigpause (int __sig) __THROW __asm__ ("__xpg_sigpause");
+#  endif
+/* Remove a signal from the signal mask and suspend the process.  */
+#  define sigpause(sig) __sigpause ((sig), 1)
+# endif
+#endif
+
+
+#ifdef __USE_BSD
+/* None of the following functions should be used anymore.  They are here
+   only for compatibility.  A single word (`int') is not guaranteed to be
+   enough to hold a complete signal mask and therefore these functions
+   simply do not work in many situations.  Use `sigprocmask' instead.  */
+
+/* Compute mask for signal SIG.  */
+# define sigmask(sig)	__sigmask(sig)
+
+/* Block signals in MASK, returning the old mask.  */
+extern int sigblock (int __mask) __THROW;
+
+/* Set the mask of blocked signals to MASK, returning the old mask.  */
+extern int sigsetmask (int __mask) __THROW;
+
+/* Return currently selected signal mask.  */
+extern int siggetmask (void) __THROW;
+#endif /* Use BSD.  */
+
+
+#ifdef __USE_MISC
+# define NSIG	_NSIG
+#endif
+
+#ifdef __USE_GNU
+typedef __sighandler_t sighandler_t;
+#endif
+
+/* 4.4 BSD uses the name `sig_t' for this.  */
+#ifdef __USE_BSD
+typedef __sighandler_t sig_t;
+#endif
+
+#ifdef __USE_POSIX
+
+# ifdef __USE_POSIX199309
+/* We need `struct timespec' later on.  */
+#  define __need_timespec
+#  include <time.h>
+
+/* Get the `siginfo_t' type plus the needed symbols.  */
+#  include <bits/siginfo.h>
+# endif
+
+/* Clear all signals from SET.  */
+extern int sigemptyset (sigset_t *__set) __THROW;
+
+/* Set all signals in SET.  */
+extern int sigfillset (sigset_t *__set) __THROW;
+
+/* Add SIGNO to SET.  */
+extern int sigaddset (sigset_t *__set, int __signo) __THROW;
+
+/* Remove SIGNO from SET.  */
+extern int sigdelset (sigset_t *__set, int __signo) __THROW;
+
+/* Return 1 if SIGNO is in SET, 0 if not.  */
+extern int sigismember (__const sigset_t *__set, int __signo) __THROW;
+
+# ifdef __USE_GNU
+/* Return non-empty value is SET is not empty.  */
+extern int sigisemptyset (__const sigset_t *__set) __THROW;
+
+/* Build new signal set by combining the two inputs set using logical AND.  */
+extern int sigandset (sigset_t *__set, __const sigset_t *__left,
+		      __const sigset_t *__right) __THROW;
+
+/* Build new signal set by combining the two inputs set using logical OR.  */
+extern int sigorset (sigset_t *__set, __const sigset_t *__left,
+		     __const sigset_t *__right) __THROW;
+# endif /* GNU */
+
+/* Get the system-specific definitions of `struct sigaction'
+   and the `SA_*' and `SIG_*'. constants.  */
+# include <bits/sigaction.h>
+
+/* Get and/or change the set of blocked signals.  */
+extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
+			sigset_t *__restrict __oset) __THROW;
+
+/* Change the set of blocked signals to SET,
+   wait until a signal arrives, and restore the set of blocked signals.  */
+extern int sigsuspend (__const sigset_t *__set) __THROW;
+
+/* Get and/or set the action for signal SIG.  */
+extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
+		      struct sigaction *__restrict __oact) __THROW;
+
+/* Put in SET all signals that are blocked and waiting to be delivered.  */
+extern int sigpending (sigset_t *__set) __THROW;
+
+
+/* Select any of pending signals from SET or wait for any to arrive.  */
+extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
+     __THROW;
+
+# ifdef __USE_POSIX199309
+/* Select any of pending signals from SET and place information in INFO.  */
+extern int sigwaitinfo (__const sigset_t *__restrict __set,
+			siginfo_t *__restrict __info) __THROW;
+
+/* Select any of pending signals from SET and place information in INFO.
+   Wait the imte specified by TIMEOUT if no signal is pending.  */
+extern int sigtimedwait (__const sigset_t *__restrict __set,
+			 siginfo_t *__restrict __info,
+			 __const struct timespec *__restrict __timeout)
+     __THROW;
+
+/* Send signal SIG to the process PID.  Associate data in VAL with the
+   signal.  */
+extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
+     __THROW;
+# endif	/* Use POSIX 199306.  */
+
+#endif /* Use POSIX.  */
+
+#ifdef __USE_BSD
+
+#ifdef __UCLIBC_HAS_SYS_SIGLIST__
+/* Names of the signals.  This variable exists only for compatibility.
+   Use `strsignal' instead (see <string.h>).  */
+#define _sys_siglist sys_siglist
+extern __const char *__const sys_siglist[_NSIG];
+#endif /* __UCLIBC_HAS_SYS_SIGLIST__ */
+
+/* Structure passed to `sigvec'.  */
+struct sigvec
+  {
+    __sighandler_t sv_handler;	/* Signal handler.  */
+    int sv_mask;		/* Mask of signals to be blocked.  */
+
+    int sv_flags;		/* Flags (see below).  */
+# define sv_onstack	sv_flags /* 4.2 BSD compatibility.  */
+  };
+
+/* Bits in `sv_flags'.  */
+# define SV_ONSTACK	(1 << 0)/* Take the signal on the signal stack.  */
+# define SV_INTERRUPT	(1 << 1)/* Do not restart system calls.  */
+# define SV_RESETHAND	(1 << 2)/* Reset handler to SIG_DFL on receipt.  */
+
+
+/* If VEC is non-NULL, set the handler for SIG to the `sv_handler' member
+   of VEC.  The signals in `sv_mask' will be blocked while the handler runs.
+   If the SV_RESETHAND bit is set in `sv_flags', the handler for SIG will be
+   reset to SIG_DFL before `sv_handler' is entered.  If OVEC is non-NULL,
+   it is filled in with the old information for SIG.  */
+extern int sigvec (int __sig, __const struct sigvec *__vec,
+		   struct sigvec *__ovec) __THROW;
+
+
+/* Get machine-dependent `struct sigcontext' and signal subcodes.  */
+# include <bits/sigcontext.h>
+
+/* Restore the state saved in SCP.  */
+extern int sigreturn (struct sigcontext *__scp) __THROW;
+
+#endif /*  use BSD.  */
+
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+
+/* If INTERRUPT is nonzero, make signal SIG interrupt system calls
+   (causing them to fail with EINTR); if INTERRUPT is zero, make system
+   calls be restarted after signal SIG.  */
+extern int siginterrupt (int __sig, int __interrupt) __THROW;
+
+# include <bits/sigstack.h>
+# ifdef __USE_XOPEN
+#  include <ucontext.h>
+# endif
+
+/* Run signals handlers on the stack specified by SS (if not NULL).
+   If OSS is not NULL, it is filled in with the old signal stack status.
+   This interface is obsolete and on many platform not implemented.  */
+extern int sigstack (struct sigstack *__ss, struct sigstack *__oss) __THROW;
+
+/* Alternate signal handler stack interface.
+   This interface should always be preferred over `sigstack'.  */
+extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
+			struct sigaltstack *__restrict __oss) __THROW;
+
+#endif /* use BSD or X/Open Unix.  */
+
+#ifdef __USE_UNIX98
+/* Simplified interface for signal management.  */
+
+/* Add SIG to the calling process' signal mask.  */
+extern int sighold (int __sig) __THROW;
+
+/* Remove SIG from the calling process' signal mask.  */
+extern int sigrelse (int __sig) __THROW;
+
+/* Set the disposition of SIG to SIG_IGN.  */
+extern int sigignore (int __sig) __THROW;
+
+/* Set the disposition of SIG.  */
+extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __THROW;
+#endif
+
+#if defined __UCLIBC_HAS_THREADS__ && (defined __USE_POSIX199506 || defined __USE_UNIX98)
+/* Some of the functions for handling signals in threaded programs must
+   be defined here.  */
+# include <bits/sigthread.h>
+#endif /* use Unix98 */
+
+/* The following functions are used internally in the C library and in
+   other code which need deep insights.  */
+
+/* Return number of available real-time signal with highest priority.  */
+extern int __libc_current_sigrtmin (void) __THROW;
+/* Return number of available real-time signal with lowest priority.  */
+extern int __libc_current_sigrtmax (void) __THROW;
+
+#endif /* signal.h  */
+
+__END_DECLS
+
+#endif /* not signal.h */
diff -pruwN busybox-1.01/include2/stdint.h busybox-1.01-livebox/include2/stdint.h
--- busybox-1.01/include2/stdint.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/stdint.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,332 @@
+/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99: 7.18 Integer types <stdint.h>
+ */
+
+#ifndef _STDINT_H
+#define _STDINT_H	1
+
+#include <features.h>
+#ifdef __UCLIBC_HAS_WCHAR__
+#include <bits/wchar.h>
+#endif /* __UCLIBC_HAS_WCHAR__ */
+#include <bits/wordsize.h>
+
+/* Exact integral types.  */
+
+/* Signed.  */
+
+/* There is some amount of overlap with <sys/types.h> as known by inet code */
+#ifndef __int8_t_defined
+# define __int8_t_defined
+typedef signed char		int8_t;
+typedef short int		int16_t;
+typedef int			int32_t;
+# if __WORDSIZE == 64
+typedef long int		int64_t;
+# else
+__extension__
+typedef long long int		int64_t;
+# endif
+#endif
+
+/* Unsigned.  */
+typedef unsigned char		uint8_t;
+typedef unsigned short int	uint16_t;
+#ifndef __uint32_t_defined
+typedef unsigned int		uint32_t;
+# define __uint32_t_defined
+#endif
+#if __WORDSIZE == 64
+typedef unsigned long int	uint64_t;
+#else
+__extension__
+typedef unsigned long long int	uint64_t;
+#endif
+
+
+/* Small types.  */
+
+/* Signed.  */
+typedef signed char		int_least8_t;
+typedef short int		int_least16_t;
+typedef int			int_least32_t;
+#if __WORDSIZE == 64
+typedef long int		int_least64_t;
+#else
+__extension__
+typedef long long int		int_least64_t;
+#endif
+
+/* Unsigned.  */
+typedef unsigned char		uint_least8_t;
+typedef unsigned short int	uint_least16_t;
+typedef unsigned int		uint_least32_t;
+#if __WORDSIZE == 64
+typedef unsigned long int	uint_least64_t;
+#else
+__extension__
+typedef unsigned long long int	uint_least64_t;
+#endif
+
+
+/* Fast types.  */
+
+/* Signed.  */
+typedef signed char		int_fast8_t;
+#if __WORDSIZE == 64
+typedef long int		int_fast16_t;
+typedef long int		int_fast32_t;
+typedef long int		int_fast64_t;
+#else
+typedef int			int_fast16_t;
+typedef int			int_fast32_t;
+__extension__
+typedef long long int		int_fast64_t;
+#endif
+
+/* Unsigned.  */
+typedef unsigned char		uint_fast8_t;
+#if __WORDSIZE == 64
+typedef unsigned long int	uint_fast16_t;
+typedef unsigned long int	uint_fast32_t;
+typedef unsigned long int	uint_fast64_t;
+#else
+typedef unsigned int		uint_fast16_t;
+typedef unsigned int		uint_fast32_t;
+__extension__
+typedef unsigned long long int	uint_fast64_t;
+#endif
+
+
+/* Types for `void *' pointers.  */
+#if __WORDSIZE == 64
+# ifndef __intptr_t_defined
+typedef long int		intptr_t;
+#  define __intptr_t_defined
+# endif
+typedef unsigned long int	uintptr_t;
+#else
+# ifndef __intptr_t_defined
+typedef int			intptr_t;
+#  define __intptr_t_defined
+# endif
+typedef unsigned int		uintptr_t;
+#endif
+
+
+/* Largest integral types.  */
+#if __WORDSIZE == 64
+typedef long int		intmax_t;
+typedef unsigned long int	uintmax_t;
+#else
+__extension__
+typedef long long int		intmax_t;
+__extension__
+typedef unsigned long long int	uintmax_t;
+#endif
+
+
+/* The ISO C99 standard specifies that in C++ implementations these
+   macros should only be defined if explicitly requested.  */
+#if !defined __cplusplus || defined __STDC_LIMIT_MACROS
+
+# if __WORDSIZE == 64
+#  define __INT64_C(c)	c ## L
+#  define __UINT64_C(c)	c ## UL
+# else
+#  define __INT64_C(c)	c ## LL
+#  define __UINT64_C(c)	c ## ULL
+# endif
+
+/* Limits of integral types.  */
+
+/* Minimum of signed integral types.  */
+# define INT8_MIN		(-128)
+# define INT16_MIN		(-32767-1)
+# define INT32_MIN		(-2147483647-1)
+# define INT64_MIN		(-__INT64_C(9223372036854775807)-1)
+/* Maximum of signed integral types.  */
+# define INT8_MAX		(127)
+# define INT16_MAX		(32767)
+# define INT32_MAX		(2147483647)
+# define INT64_MAX		(__INT64_C(9223372036854775807))
+
+/* Maximum of unsigned integral types.  */
+# define UINT8_MAX		(255)
+# define UINT16_MAX		(65535)
+# define UINT32_MAX		(4294967295U)
+# define UINT64_MAX		(__UINT64_C(18446744073709551615))
+
+
+/* Minimum of signed integral types having a minimum size.  */
+# define INT_LEAST8_MIN		(-128)
+# define INT_LEAST16_MIN	(-32767-1)
+# define INT_LEAST32_MIN	(-2147483647-1)
+# define INT_LEAST64_MIN	(-__INT64_C(9223372036854775807)-1)
+/* Maximum of signed integral types having a minimum size.  */
+# define INT_LEAST8_MAX		(127)
+# define INT_LEAST16_MAX	(32767)
+# define INT_LEAST32_MAX	(2147483647)
+# define INT_LEAST64_MAX	(__INT64_C(9223372036854775807))
+
+/* Maximum of unsigned integral types having a minimum size.  */
+# define UINT_LEAST8_MAX	(255)
+# define UINT_LEAST16_MAX	(65535)
+# define UINT_LEAST32_MAX	(4294967295U)
+# define UINT_LEAST64_MAX	(__UINT64_C(18446744073709551615))
+
+
+/* Minimum of fast signed integral types having a minimum size.  */
+# define INT_FAST8_MIN		(-128)
+# if __WORDSIZE == 64
+#  define INT_FAST16_MIN	(-9223372036854775807L-1)
+#  define INT_FAST32_MIN	(-9223372036854775807L-1)
+# else
+#  define INT_FAST16_MIN	(-2147483647-1)
+#  define INT_FAST32_MIN	(-2147483647-1)
+# endif
+# define INT_FAST64_MIN		(-__INT64_C(9223372036854775807)-1)
+/* Maximum of fast signed integral types having a minimum size.  */
+# define INT_FAST8_MAX		(127)
+# if __WORDSIZE == 64
+#  define INT_FAST16_MAX	(9223372036854775807L)
+#  define INT_FAST32_MAX	(9223372036854775807L)
+# else
+#  define INT_FAST16_MAX	(2147483647)
+#  define INT_FAST32_MAX	(2147483647)
+# endif
+# define INT_FAST64_MAX		(__INT64_C(9223372036854775807))
+
+/* Maximum of fast unsigned integral types having a minimum size.  */
+# define UINT_FAST8_MAX		(255)
+# if __WORDSIZE == 64
+#  define UINT_FAST16_MAX	(18446744073709551615UL)
+#  define UINT_FAST32_MAX	(18446744073709551615UL)
+# else
+#  define UINT_FAST16_MAX	(4294967295U)
+#  define UINT_FAST32_MAX	(4294967295U)
+# endif
+# define UINT_FAST64_MAX	(__UINT64_C(18446744073709551615))
+
+
+/* Values to test for integral types holding `void *' pointer.  */
+# if __WORDSIZE == 64
+#  define INTPTR_MIN		(-9223372036854775807L-1)
+#  define INTPTR_MAX		(9223372036854775807L)
+#  define UINTPTR_MAX		(18446744073709551615UL)
+# else
+#  define INTPTR_MIN		(-2147483647-1)
+#  define INTPTR_MAX		(2147483647)
+#  define UINTPTR_MAX		(4294967295U)
+# endif
+
+#if !defined(__H8300H__) && !defined(__H8300S__) 
+/* Minimum for largest signed integral type.  */
+# define INTMAX_MIN		(-__INT64_C(9223372036854775807)-1)
+/* Maximum for largest signed integral type.  */
+# define INTMAX_MAX		(__INT64_C(9223372036854775807))
+
+/* Maximum for largest unsigned integral type.  */
+# define UINTMAX_MAX		(__UINT64_C(18446744073709551615))
+#else
+/* Minimum for largest signed integral type.  */
+# define INTMAX_MIN		(-LONG_LONG_MAX-1)
+/* Maximum for largest signed integral type.  */
+# define INTMAX_MAX		(LONG_LONG_MAX)
+
+/* Maximum for largest unsigned integral type.  */
+# define UINTMAX_MAX		(LONG_LONG_MAX<<1+1)
+#endif
+
+/* Limits of other integer types.  */
+
+/* Limits of `ptrdiff_t' type.  */
+# if __WORDSIZE == 64
+#  define PTRDIFF_MIN		(-9223372036854775807L-1)
+#  define PTRDIFF_MAX		(9223372036854775807L)
+# else
+#  define PTRDIFF_MIN		(-2147483647-1)
+#  define PTRDIFF_MAX		(2147483647)
+# endif
+
+/* Limits of `sig_atomic_t'.  */
+# define SIG_ATOMIC_MIN		(-2147483647-1)
+# define SIG_ATOMIC_MAX		(2147483647)
+
+/* Limit of `size_t' type.  */
+# if __WORDSIZE == 64
+#  define SIZE_MAX		(18446744073709551615UL)
+# else
+#  define SIZE_MAX		(4294967295U)
+# endif
+
+#ifdef __UCLIBC_HAS_WCHAR__
+/* Limits of `wchar_t'.  */
+# ifndef WCHAR_MIN
+/* These constants might also be defined in <wchar.h>.  */
+#  define WCHAR_MIN		__WCHAR_MIN
+#  define WCHAR_MAX		__WCHAR_MAX
+# endif
+
+/* Limits of `wint_t'.  */
+# define WINT_MIN		(0u)
+# define WINT_MAX		(4294967295u)
+#endif /* __UCLIBC_HAS_WCHAR__ */
+
+#endif	/* C++ && limit macros */
+
+
+/* The ISO C99 standard specifies that in C++ implementations these
+   should only be defined if explicitly requested.  */
+#if !defined __cplusplus || defined __STDC_CONSTANT_MACROS
+
+/* Signed.  */
+# define INT8_C(c)	c
+# define INT16_C(c)	c
+# define INT32_C(c)	c
+# if __WORDSIZE == 64
+#  define INT64_C(c)	c ## L
+# else
+#  define INT64_C(c)	c ## LL
+# endif
+
+/* Unsigned.  */
+# define UINT8_C(c)	c ## U
+# define UINT16_C(c)	c ## U
+# define UINT32_C(c)	c ## U
+# if __WORDSIZE == 64
+#  define UINT64_C(c)	c ## UL
+# else
+#  define UINT64_C(c)	c ## ULL
+# endif
+
+/* Maximal type.  */
+# if __WORDSIZE == 64
+#  define INTMAX_C(c)	c ## L
+#  define UINTMAX_C(c)	c ## UL
+# else
+#  define INTMAX_C(c)	c ## LL
+#  define UINTMAX_C(c)	c ## ULL
+# endif
+
+#endif	/* C++ && constant macros */
+
+#endif /* stdint.h */
diff -pruwN busybox-1.01/include2/stdio.h busybox-1.01-livebox/include2/stdio.h
--- busybox-1.01/include2/stdio.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/stdio.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,862 @@
+/*
+   Copyright (C) 1991,1994-2002,2003,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
+ */
+
+#ifndef _STDIO_H
+
+#if !defined __need_FILE && !defined __need___FILE
+# define _STDIO_H	1
+# include <features.h>
+
+__BEGIN_DECLS
+
+# define __need_size_t
+# define __need_NULL
+# include <stddef.h>
+
+# include <bits/types.h>
+# define __need_FILE
+# define __need___FILE
+#endif /* Don't need FILE.  */
+
+
+#if !defined __FILE_defined && defined __need_FILE
+
+__BEGIN_NAMESPACE_STD
+/* The opaque type of streams.  This is the definition used elsewhere.  */
+typedef struct __STDIO_FILE_STRUCT FILE;
+__END_NAMESPACE_STD
+#if defined __USE_LARGEFILE64 || defined __USE_SVID || defined __USE_POSIX \
+    || defined __USE_BSD || defined __USE_ISOC99 || defined __USE_XOPEN \
+    || defined __USE_POSIX2
+__USING_NAMESPACE_STD(FILE)
+#endif
+
+# define __FILE_defined	1
+#endif /* FILE not defined.  */
+#undef	__need_FILE
+
+
+#if !defined ____FILE_defined && defined __need___FILE
+
+/* The opaque type of streams.  This is the definition used elsewhere.  */
+typedef struct __STDIO_FILE_STRUCT __FILE;
+
+# define ____FILE_defined	1
+#endif /* __FILE not defined.  */
+#undef	__need___FILE
+
+
+#ifdef	_STDIO_H
+#undef _STDIO_USES_IOSTREAM
+
+#include <bits/uClibc_stdio.h>
+
+/* This define avoids name pollution if we're using GNU stdarg.h */
+# define __need___va_list
+#include <stdarg.h>
+
+/* The type of the second argument to `fgetpos' and `fsetpos'.  */
+__BEGIN_NAMESPACE_STD
+#ifndef __USE_FILE_OFFSET64
+typedef __STDIO_fpos_t fpos_t;
+#else
+typedef __STDIO_fpos64_t fpos_t;
+#endif
+__END_NAMESPACE_STD
+#ifdef __USE_LARGEFILE64
+typedef __STDIO_fpos64_t fpos64_t;
+#endif
+
+/* The possibilities for the third argument to `setvbuf'.  */
+#define _IOFBF __STDIO_IOFBF 		/* Fully buffered.  */
+#define _IOLBF __STDIO_IOLBF		/* Line buffered.  */
+#define _IONBF __STDIO_IONBF		/* No buffering.  */
+
+
+/* Default buffer size.  */
+#ifndef BUFSIZ
+# define BUFSIZ __STDIO_BUFSIZ
+#endif
+
+
+/* End of file character.
+   Some things throughout the library rely on this being -1.  */
+#ifndef EOF
+# define EOF (-1)
+#endif
+
+
+/* The possibilities for the third argument to `fseek'.
+   These values should not be changed.  */
+#define SEEK_SET	0	/* Seek from beginning of file.  */
+#define SEEK_CUR	1	/* Seek from current position.  */
+#define SEEK_END	2	/* Seek from end of file.  */
+
+
+#if defined __USE_SVID || defined __USE_XOPEN
+/* Default path prefix for `tempnam' and `tmpnam'.  */
+# define P_tmpdir	"/tmp"
+#endif
+
+
+/* Get the values:
+   L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.
+   TMP_MAX	The minimum number of unique filenames generated by tmpnam
+   		(and tempnam when it uses tmpnam's name space),
+		or tempnam (the two are separate).
+   L_ctermid	How long an array to pass to `ctermid'.
+   L_cuserid	How long an array to pass to `cuserid'.
+   FOPEN_MAX	Minimum number of files that can be open at once.
+   FILENAME_MAX	Maximum length of a filename.  */
+#include <bits/stdio_lim.h>
+
+
+/* Standard streams.  */
+extern FILE *stdin;	        /* Standard input stream.  */
+extern FILE *stdout;        /* Standard output stream.  */
+extern FILE *stderr;        /* Standard error output stream.  */
+/* C89/C99 say they're macros.  Make them happy.  */
+#define stdin stdin
+#define stdout stdout
+#define stderr stderr
+
+__BEGIN_NAMESPACE_STD
+/* Remove file FILENAME.  */
+extern int remove (__const char *__filename) __THROW;
+/* Rename file OLD to NEW.  */
+extern int rename (__const char *__old, __const char *__new) __THROW;
+__END_NAMESPACE_STD
+
+
+__BEGIN_NAMESPACE_STD
+/* Create a temporary file and open it read/write.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+#ifndef __USE_FILE_OFFSET64
+extern FILE *tmpfile (void);
+#else
+# ifdef __REDIRECT
+extern FILE *__REDIRECT (tmpfile, (void), tmpfile64);
+# else
+#  define tmpfile tmpfile64
+# endif
+#endif
+
+#ifdef __USE_LARGEFILE64
+extern FILE *tmpfile64 (void);
+#endif
+
+/* Generate a temporary filename.  */
+extern char *tmpnam (char *__s) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_MISC
+/* This is the reentrant variant of `tmpnam'.  The only difference is
+   that it does not allow S to be NULL.  */
+extern char *tmpnam_r (char *__s) __THROW;
+#endif
+
+
+#if defined __USE_SVID || defined __USE_XOPEN
+/* Generate a unique temporary filename using up to five characters of PFX
+   if it is not NULL.  The directory to put this file in is searched for
+   as follows: First the environment variable "TMPDIR" is checked.
+   If it contains the name of a writable directory, that directory is used.
+   If not and if DIR is not NULL, that value is checked.  If that fails,
+   P_tmpdir is tried and finally "/tmp".  The storage for the filename
+   is allocated by `malloc'.  */
+extern char *tempnam (__const char *__dir, __const char *__pfx)
+     __THROW __attribute_malloc__;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Close STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fclose (FILE *__stream);
+/* Flush STREAM, or all streams if STREAM is NULL.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fflush (FILE *__stream);
+__END_NAMESPACE_STD
+
+#ifdef __USE_MISC
+/* Faster versions when locking is not required.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fflush_unlocked (FILE *__stream);
+#endif
+
+#ifdef __USE_GNU
+/* Close all streams.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fcloseall (void);
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+#ifndef __USE_FILE_OFFSET64
+/* Open a file and create a new stream for it.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern FILE *fopen (__const char *__restrict __filename,
+		    __const char *__restrict __modes);
+/* Open a file, replacing an existing stream with it.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern FILE *freopen (__const char *__restrict __filename,
+		      __const char *__restrict __modes,
+		      FILE *__restrict __stream);
+#else
+# ifdef __REDIRECT
+extern FILE *__REDIRECT (fopen, (__const char *__restrict __filename,
+				 __const char *__restrict __modes), fopen64);
+extern FILE *__REDIRECT (freopen, (__const char *__restrict __filename,
+				   __const char *__restrict __modes,
+				   FILE *__restrict __stream), freopen64);
+# else
+#  define fopen fopen64
+#  define freopen freopen64
+# endif
+#endif
+__END_NAMESPACE_STD
+#ifdef __USE_LARGEFILE64
+extern FILE *fopen64 (__const char *__restrict __filename,
+		      __const char *__restrict __modes);
+extern FILE *freopen64 (__const char *__restrict __filename,
+			__const char *__restrict __modes,
+			FILE *__restrict __stream);
+#endif
+
+#ifdef	__USE_POSIX
+/* Create a new stream that refers to an existing system file descriptor.  */
+extern FILE *fdopen (int __fd, __const char *__modes) __THROW;
+#endif
+
+#ifdef	__USE_GNU
+#ifdef __UCLIBC_HAS_GLIBC_CUSTOM_STREAMS__
+/* Create a new stream that refers to the given magic cookie,
+   and uses the given functions for input and output.  */
+extern FILE *fopencookie (void *__restrict __magic_cookie,
+			  __const char *__restrict __modes,
+			  _IO_cookie_io_functions_t __io_funcs) __THROW;
+
+/* Create a new stream that refers to a memory buffer.  */
+extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes) __THROW;
+
+/* Open a stream that writes into a malloc'd buffer that is expanded as
+   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
+   and the number of characters written on fflush or fclose.  */
+extern FILE *open_memstream (char **__restrict __bufloc,
+			     size_t *__restrict __sizeloc) __THROW;
+#endif
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* If BUF is NULL, make STREAM unbuffered.
+   Else make it use buffer BUF, of size BUFSIZ.  */
+extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __THROW;
+/* Make STREAM use buffering mode MODE.
+   If BUF is not NULL, use N bytes of it for buffering;
+   else allocate an internal buffer N bytes long.  */
+extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
+		    int __modes, size_t __n) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef	__USE_BSD
+/* If BUF is NULL, make STREAM unbuffered.
+   Else make it use SIZE bytes of BUF for buffering.  */
+extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
+		       size_t __size) __THROW;
+
+/* Make STREAM line-buffered.  */
+extern void setlinebuf (FILE *__stream) __THROW;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Write formatted output to STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fprintf (FILE *__restrict __stream,
+		    __const char *__restrict __format, ...);
+/* Write formatted output to stdout.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int printf (__const char *__restrict __format, ...);
+/* Write formatted output to S.  */
+extern int sprintf (char *__restrict __s,
+		    __const char *__restrict __format, ...) __THROW;
+
+/* Write formatted output to S from argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
+		     __gnuc_va_list __arg);
+/* Write formatted output to stdout from argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);
+/* Write formatted output to S from argument list ARG.  */
+extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
+		     __gnuc_va_list __arg) __THROW;
+__END_NAMESPACE_STD
+
+#if defined __USE_BSD || defined __USE_ISOC99 || defined __USE_UNIX98
+__BEGIN_NAMESPACE_C99
+/* Maximum chars of output to write in MAXLEN.  */
+extern int snprintf (char *__restrict __s, size_t __maxlen,
+		     __const char *__restrict __format, ...)
+     __THROW __attribute__ ((__format__ (__printf__, 3, 4)));
+
+extern int vsnprintf (char *__restrict __s, size_t __maxlen,
+		      __const char *__restrict __format, __gnuc_va_list __arg)
+     __THROW __attribute__ ((__format__ (__printf__, 3, 0)));
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_GNU
+/* Write formatted output to a string dynamically allocated with `malloc'.
+   Store the address of the string in *PTR.  */
+extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
+		      __gnuc_va_list __arg)
+     __THROW __attribute__ ((__format__ (__printf__, 2, 0)));
+extern int __asprintf (char **__restrict __ptr,
+		       __const char *__restrict __fmt, ...)
+     __THROW __attribute__ ((__format__ (__printf__, 2, 3)));
+extern int asprintf (char **__restrict __ptr,
+		     __const char *__restrict __fmt, ...)
+     __THROW __attribute__ ((__format__ (__printf__, 2, 3)));
+
+/* Write formatted output to a file descriptor.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern int vdprintf (int __fd, __const char *__restrict __fmt,
+		     __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__printf__, 2, 0)));
+extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
+     __attribute__ ((__format__ (__printf__, 2, 3)));
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Read formatted input from STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fscanf (FILE *__restrict __stream,
+		   __const char *__restrict __format, ...);
+/* Read formatted input from stdin.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int scanf (__const char *__restrict __format, ...);
+/* Read formatted input from S.  */
+extern int sscanf (__const char *__restrict __s,
+		   __const char *__restrict __format, ...) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef	__USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Read formatted input from S into argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
+		    __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__scanf__, 2, 0)));
+
+/* Read formatted input from stdin into argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__scanf__, 1, 0)));
+
+/* Read formatted input from S into argument list ARG.  */
+extern int vsscanf (__const char *__restrict __s,
+		    __const char *__restrict __format, __gnuc_va_list __arg)
+     __THROW __attribute__ ((__format__ (__scanf__, 2, 0)));
+__END_NAMESPACE_C99
+#endif /* Use ISO C9x.  */
+
+
+__BEGIN_NAMESPACE_STD
+/* Read a character from STREAM.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.  */
+extern int fgetc (FILE *__stream);
+extern int getc (FILE *__stream);
+
+/* Read a character from stdin.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int getchar (void);
+__END_NAMESPACE_STD
+
+/* The C standard explicitly says this is a macro, so we always do the
+   optimization for it.  */
+#define getc(_fp) __GETC(_fp)
+
+#if defined __USE_POSIX || defined __USE_MISC
+/* These are defined in POSIX.1:1996.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.  */
+extern int getc_unlocked (FILE *__stream);
+extern int getchar_unlocked (void);
+
+/* SUSv3 allows getc_unlocked to be a macro */
+#define getc_unlocked(_fp) __GETC_UNLOCKED(_fp)
+#endif /* Use POSIX or MISC.  */
+
+#ifdef __USE_MISC
+/* Faster version when locking is not necessary.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fgetc_unlocked (FILE *__stream);
+#endif /* Use MISC.  */
+
+
+__BEGIN_NAMESPACE_STD
+/* Write a character to STREAM.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.
+
+   These functions is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fputc (int __c, FILE *__stream);
+extern int putc (int __c, FILE *__stream);
+
+/* Write a character to stdout.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int putchar (int __c);
+__END_NAMESPACE_STD
+
+/* The C standard explicitly says this can be a macro,
+   so we always do the optimization for it.  */
+#define putc(_ch, _fp) __PUTC(_ch, _fp)
+
+#ifdef __USE_MISC
+/* Faster version when locking is not necessary.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fputc_unlocked (int __c, FILE *__stream);
+#endif /* Use MISC.  */
+
+#if defined __USE_POSIX || defined __USE_MISC
+/* These are defined in POSIX.1:1996.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.  */
+extern int putc_unlocked (int __c, FILE *__stream);
+extern int putchar_unlocked (int __c);
+
+/* SUSv3 allows putc_unlocked to be a macro */
+#define putc_unlocked(_ch, _fp) __PUTC_UNLOCKED(_ch, _fp)
+#endif /* Use POSIX or MISC.  */
+
+
+#if defined __USE_SVID || defined __USE_MISC \
+    || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
+/* Get a word (int) from STREAM.  */
+extern int getw (FILE *__stream);
+
+/* Write a word (int) to STREAM.  */
+extern int putw (int __w, FILE *__stream);
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Get a newline-terminated string of finite length from STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream);
+
+/* Get a newline-terminated string from stdin, removing the newline.
+   DO NOT USE THIS FUNCTION!!  There is no limit on how much it will read.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern char *gets (char *__s);
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* This function does the same as `fgets' but does not lock the stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern char *fgets_unlocked (char *__restrict __s, int __n,
+			     FILE *__restrict __stream);
+#endif
+
+
+#ifdef	__USE_GNU
+/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
+   (and null-terminate it). *LINEPTR is a pointer returned from malloc (or
+   NULL), pointing to *N characters of space.  It is realloc'd as
+   necessary.  Returns the number of characters read (not including the
+   null terminator), or -1 on error or EOF.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern __ssize_t __getdelim (char **__restrict __lineptr,
+			       size_t *__restrict __n, int __delimiter,
+			       FILE *__restrict __stream);
+extern __ssize_t getdelim (char **__restrict __lineptr,
+			     size_t *__restrict __n, int __delimiter,
+			     FILE *__restrict __stream);
+
+/* Like `getdelim', but reads up to a newline.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern __ssize_t getline (char **__restrict __lineptr,
+			    size_t *__restrict __n,
+			    FILE *__restrict __stream);
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Write a string to STREAM.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);
+
+/* Write a string, followed by a newline, to stdout.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+extern int puts (__const char *__s);
+
+
+/* Push a character back onto the input buffer of STREAM.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+extern int ungetc (int __c, FILE *__stream);
+
+
+/* Read chunks of generic data from STREAM.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+extern size_t fread (void *__restrict __ptr, size_t __size,
+		     size_t __n, FILE *__restrict __stream);
+/* Write chunks of generic data to STREAM.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
+		      size_t __n, FILE *__restrict __s);
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* This function does the same as `fputs' but does not lock the stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fputs_unlocked (__const char *__restrict __s,
+			   FILE *__restrict __stream);
+#endif
+
+#ifdef __USE_MISC
+/* Faster versions when locking is not necessary.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
+			      size_t __n, FILE *__restrict __stream);
+extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
+			       size_t __n, FILE *__restrict __stream);
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Seek to a certain position on STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fseek (FILE *__stream, long int __off, int __whence);
+/* Return the current position of STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern long int ftell (FILE *__stream);
+/* Rewind to the beginning of STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void rewind (FILE *__stream);
+__END_NAMESPACE_STD
+
+/* The Single Unix Specification, Version 2, specifies an alternative,
+   more adequate interface for the two functions above which deal with
+   file offset.  `long int' is not the right type.  These definitions
+   are originally defined in the Large File Support API.  */
+
+#if defined __USE_LARGEFILE || defined __USE_XOPEN2K
+# ifndef __USE_FILE_OFFSET64
+/* Seek to a certain position on STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fseeko (FILE *__stream, __off_t __off, int __whence);
+/* Return the current position of STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern __off_t ftello (FILE *__stream);
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (fseeko,
+		       (FILE *__stream, __off64_t __off, int __whence),
+		       fseeko64);
+extern __off64_t __REDIRECT (ftello, (FILE *__stream), ftello64);
+#  else
+#   define fseeko fseeko64
+#   define ftello ftello64
+#  endif
+# endif
+#endif
+
+__BEGIN_NAMESPACE_STD
+#ifndef __USE_FILE_OFFSET64
+/* Get STREAM's position.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
+/* Set STREAM's position.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (fgetpos, (FILE *__restrict __stream,
+				 fpos_t *__restrict __pos), fgetpos64);
+extern int __REDIRECT (fsetpos,
+		       (FILE *__stream, __const fpos_t *__pos), fsetpos64);
+# else
+#  define fgetpos fgetpos64
+#  define fsetpos fsetpos64
+# endif
+#endif
+__END_NAMESPACE_STD
+
+#ifdef __USE_LARGEFILE64
+extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
+extern __off64_t ftello64 (FILE *__stream);
+extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
+extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Clear the error and EOF indicators for STREAM.  */
+extern void clearerr (FILE *__stream) __THROW;
+/* Return the EOF indicator for STREAM.  */
+extern int feof (FILE *__stream) __THROW;
+/* Return the error indicator for STREAM.  */
+extern int ferror (FILE *__stream) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_MISC
+/* Faster versions when locking is not required.  */
+extern void clearerr_unlocked (FILE *__stream) __THROW;
+extern int feof_unlocked (FILE *__stream) __THROW;
+extern int ferror_unlocked (FILE *__stream) __THROW;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Print a message describing the meaning of the value of errno.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void perror (__const char *__s);
+__END_NAMESPACE_STD
+
+#ifdef __UCLIBC_HAS_SYS_ERRLIST__
+/* These variables normally should not be used directly.  The `strerror'
+   function provides all the needed functionality.  */
+#ifdef	__USE_BSD
+extern int sys_nerr;
+extern __const char *__const sys_errlist[];
+#endif
+#endif /* __UCLIBC_HAS_SYS_ERRLIST__ */
+
+
+#ifdef	__USE_POSIX
+/* Return the system file descriptor for STREAM.  */
+extern int fileno (FILE *__stream) __THROW;
+#endif /* Use POSIX.  */
+
+#ifdef __USE_MISC
+/* Faster version when locking is not required.  */
+extern int fileno_unlocked (FILE *__stream) __THROW;
+#endif
+
+
+#if (defined __USE_POSIX2 || defined __USE_SVID  || defined __USE_BSD || \
+     defined __USE_MISC)
+/* Create a new stream connected to a pipe running the given command.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern FILE *popen (__const char *__command, __const char *__modes);
+
+/* Close a stream opened by popen and return the status of its child.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int pclose (FILE *__stream);
+#endif
+
+
+#ifdef	__USE_POSIX
+/* Return the name of the controlling terminal.  */
+extern char *ctermid (char *__s) __THROW;
+#endif /* Use POSIX.  */
+
+
+#ifdef __USE_XOPEN
+/* Return the name of the current user.  */
+extern char *cuserid (char *__s);
+#endif /* Use X/Open, but not issue 6.  */
+
+
+#ifdef	__USE_GNU
+struct obstack;			/* See <obstack.h>.  */
+
+/* Write formatted output to an obstack.  */
+extern int obstack_printf (struct obstack *__restrict __obstack,
+			   __const char *__restrict __format, ...)
+     __THROW __attribute__ ((__format__ (__printf__, 2, 3)));
+extern int obstack_vprintf (struct obstack *__restrict __obstack,
+			    __const char *__restrict __format,
+			    __gnuc_va_list __args)
+     __THROW __attribute__ ((__format__ (__printf__, 2, 0)));
+#endif /* Use GNU.  */
+
+
+#if defined __USE_POSIX || defined __USE_MISC
+/* These are defined in POSIX.1:1996.  */
+
+/* Acquire ownership of STREAM.  */
+extern void flockfile (FILE *__stream) __THROW;
+
+/* Try to acquire ownership of STREAM but do not block if it is not
+   possible.  */
+extern int ftrylockfile (FILE *__stream) __THROW;
+
+/* Relinquish the ownership granted for STREAM.  */
+extern void funlockfile (FILE *__stream) __THROW;
+#endif /* POSIX || misc */
+
+#if defined __USE_XOPEN && !defined __USE_XOPEN2K && !defined __USE_GNU
+/* The X/Open standard requires some functions and variables to be
+   declared here which do not belong into this header.  But we have to
+   follow.  In GNU mode we don't do this nonsense.  */
+# define __need_getopt
+# include <bits/getopt.h>
+#endif	/* X/Open, but not issue 6 and not for GNU.  */
+
+/* If we are compiling with optimizing read this file.  It contains
+   several optimizing inline functions and macros.  */
+#define fgetc(_fp)                   __FGETC(_fp)
+#define fputc(_ch, _fp)              __FPUTC(_ch, _fp)
+
+#ifdef __USE_MISC
+#define fgetc_unlocked(_fp)          __FGETC_UNLOCKED(_fp)
+#define fputc_unlocked(_ch, _fp)     __FPUTC_UNLOCKED(_ch, _fp)
+#endif
+
+#define getchar()                    __GETC(__stdin)
+#define putchar(_ch)                 __PUTC((_ch), __stdout)
+
+#if defined __USE_POSIX || defined __USE_MISC
+#define getchar_unlocked()           __GETC_UNLOCKED(__stdin)
+#define putchar_unlocked(_ch)        __PUTC_UNLOCKED((_ch), __stdout)
+#endif
+
+/* Clear the error and EOF indicators for STREAM.  */
+#define clearerr(_fp)                __CLEARERR(_fp)
+#define feof(_fp)                    __FEOF(_fp)
+#define ferror(_fp)                  __FERROR(_fp)
+
+#ifdef __USE_MISC
+#define clearerr_unlocked(_fp)       __CLEARERR_UNLOCKED(_fp)
+#define feof_unlocked(_fp)           __FEOF_UNLOCKED(_fp)
+#define ferror_unlocked(_fp)         __FERROR_UNLOCKED(_fp)
+#endif
+
+__END_DECLS
+
+#endif /* <stdio.h> included.  */
+
+#endif /* !_STDIO_H */
diff -pruwN busybox-1.01/include2/stdlib.h busybox-1.01-livebox/include2/stdlib.h
--- busybox-1.01/include2/stdlib.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/stdlib.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,776 @@
+/* Copyright (C) 1991-2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
+ */
+
+#ifndef	_STDLIB_H
+
+#include <features.h>
+
+/* Get size_t, wchar_t and NULL from <stddef.h>.  */
+#define		__need_size_t
+#ifndef __need_malloc_and_calloc
+#ifdef __UCLIBC_HAS_WCHAR__
+# define	__need_wchar_t
+#endif
+# define	__need_NULL
+#endif
+#include <stddef.h>
+
+__BEGIN_DECLS
+
+#ifndef __need_malloc_and_calloc
+#define	_STDLIB_H	1
+
+#if defined __USE_XOPEN && !defined _SYS_WAIT_H
+/* XPG requires a few symbols from <sys/wait.h> being defined.  */
+# include <bits/waitflags.h>
+# include <bits/waitstatus.h>
+
+# ifdef __USE_BSD
+
+/* Lots of hair to allow traditional BSD use of `union wait'
+   as well as POSIX.1 use of `int' for the status word.  */
+
+#  if defined __GNUC__ && !defined __cplusplus
+#   define __WAIT_INT(status)						      \
+  (__extension__ ({ union { __typeof(status) __in; int __i; } __u;	      \
+		    __u.__in = (status); __u.__i; }))
+#  else
+#   define __WAIT_INT(status)	(*(int *) &(status))
+#  endif
+
+/* This is the type of the argument to `wait'.  The funky union
+   causes redeclarations with ether `int *' or `union wait *' to be
+   allowed without complaint.  __WAIT_STATUS_DEFN is the type used in
+   the actual function definitions.  */
+
+#  if !defined __GNUC__ || __GNUC__ < 2 || defined __cplusplus
+#   define __WAIT_STATUS	void *
+#   define __WAIT_STATUS_DEFN	void *
+#  else
+/* This works in GCC 2.6.1 and later.  */
+typedef union
+  {
+    union wait *__uptr;
+    int *__iptr;
+  } __WAIT_STATUS __attribute__ ((__transparent_union__));
+#   define __WAIT_STATUS_DEFN	int *
+#  endif
+
+# else /* Don't use BSD.  */
+
+#  define __WAIT_INT(status)	(status)
+#  define __WAIT_STATUS		int *
+#  define __WAIT_STATUS_DEFN	int *
+
+# endif /* Use BSD.  */
+
+/* Define the macros <sys/wait.h> also would define this way.  */
+# define WEXITSTATUS(status)	__WEXITSTATUS(__WAIT_INT(status))
+# define WTERMSIG(status)	__WTERMSIG(__WAIT_INT(status))
+# define WSTOPSIG(status)	__WSTOPSIG(__WAIT_INT(status))
+# define WIFEXITED(status)	__WIFEXITED(__WAIT_INT(status))
+# define WIFSIGNALED(status)	__WIFSIGNALED(__WAIT_INT(status))
+# define WIFSTOPPED(status)	__WIFSTOPPED(__WAIT_INT(status))
+#endif	/* X/Open and <sys/wait.h> not included.  */
+
+__BEGIN_NAMESPACE_STD
+/* Returned by `div'.  */
+typedef struct
+  {
+    int quot;			/* Quotient.  */
+    int rem;			/* Remainder.  */
+  } div_t;
+
+/* Returned by `ldiv'.  */
+#ifndef __ldiv_t_defined
+typedef struct
+  {
+    long int quot;		/* Quotient.  */
+    long int rem;		/* Remainder.  */
+  } ldiv_t;
+# define __ldiv_t_defined	1
+#endif
+__END_NAMESPACE_STD
+
+#if defined __USE_ISOC99 && !defined __lldiv_t_defined
+__BEGIN_NAMESPACE_C99
+/* Returned by `lldiv'.  */
+__extension__ typedef struct
+  {
+    long long int quot;		/* Quotient.  */
+    long long int rem;		/* Remainder.  */
+  } lldiv_t;
+# define __lldiv_t_defined	1
+__END_NAMESPACE_C99
+#endif
+
+
+/* The largest number rand will return (same as INT_MAX).  */
+#define	RAND_MAX	2147483647
+
+
+/* We define these the same for all machines.
+   Changes from this to the outside world should be done in `_exit'.  */
+#define	EXIT_FAILURE	1	/* Failing exit status.  */
+#define	EXIT_SUCCESS	0	/* Successful exit status.  */
+
+
+/* Maximum length of a multibyte character in the current locale.  */
+/* #define	MB_CUR_MAX	(__ctype_get_mb_cur_max ()) */
+/* extern size_t __ctype_get_mb_cur_max (void) __THROW; */
+#ifdef __UCLIBC_HAS_WCHAR__
+/* Maximum length of a multibyte character in the current locale.  */
+#define	MB_CUR_MAX	(_stdlib_mb_cur_max ())
+extern size_t _stdlib_mb_cur_max (void) __THROW;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+#ifdef __UCLIBC_HAS_FLOATS__
+/* Convert a string to a floating-point number.  */
+extern double atof (__const char *__nptr) __THROW __attribute_pure__;
+#endif /* __UCLIBC_HAS_FLOATS__ */
+/* Convert a string to an integer.  */
+extern int atoi (__const char *__nptr) __THROW __attribute_pure__;
+/* Convert a string to a long integer.  */
+extern long int atol (__const char *__nptr) __THROW __attribute_pure__;
+__END_NAMESPACE_STD
+
+#if defined __USE_ISOC99 || defined __USE_MISC
+__BEGIN_NAMESPACE_C99
+/* Convert a string to a long long integer.  */
+__extension__ extern long long int atoll (__const char *__nptr)
+     __THROW __attribute_pure__;
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __UCLIBC_HAS_FLOATS__
+__BEGIN_NAMESPACE_STD
+/* Convert a string to a floating-point number.  */
+extern double strtod (__const char *__restrict __nptr,
+		      char **__restrict __endptr) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef	__USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
+extern float strtof (__const char *__restrict __nptr,
+		     char **__restrict __endptr) __THROW;
+
+extern long double strtold (__const char *__restrict __nptr,
+			    char **__restrict __endptr) __THROW;
+__END_NAMESPACE_C99
+#endif
+#endif /* __UCLIBC_HAS_FLOATS__ */
+
+__BEGIN_NAMESPACE_STD
+/* Convert a string to a long integer.  */
+extern long int strtol (__const char *__restrict __nptr,
+			char **__restrict __endptr, int __base) __THROW;
+/* Convert a string to an unsigned long integer.  */
+extern unsigned long int strtoul (__const char *__restrict __nptr,
+				  char **__restrict __endptr, int __base)
+     __THROW;
+__END_NAMESPACE_C99
+
+#if defined __USE_BSD
+/* Convert a string to a quadword integer.  */
+__extension__
+extern long long int strtoq (__const char *__restrict __nptr,
+			     char **__restrict __endptr, int __base) __THROW;
+/* Convert a string to an unsigned quadword integer.  */
+__extension__
+extern unsigned long long int strtouq (__const char *__restrict __nptr,
+				       char **__restrict __endptr, int __base)
+     __THROW;
+#endif /* GCC and use BSD.  */
+
+#if defined __USE_ISOC99 || defined __USE_MISC
+__BEGIN_NAMESPACE_C99
+/* Convert a string to a quadword integer.  */
+__extension__
+extern long long int strtoll (__const char *__restrict __nptr,
+			      char **__restrict __endptr, int __base) __THROW;
+/* Convert a string to an unsigned quadword integer.  */
+__extension__
+extern unsigned long long int strtoull (__const char *__restrict __nptr,
+					char **__restrict __endptr, int __base)
+     __THROW;
+__END_NAMESPACE_C99
+#endif /* ISO C99 or GCC and use MISC.  */
+
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+#ifdef __USE_GNU
+/* The concept of one static locale per category is not very well
+   thought out.  Many applications will need to process its data using
+   information from several different locales.  Another application is
+   the implementation of the internationalization handling in the
+   upcoming ISO C++ standard library.  To support this another set of
+   the functions using locale data exist which have an additional
+   argument.
+
+   Attention: all these functions are *not* standardized in any form.
+   This is a proof-of-concept implementation.  */
+
+/* Structure for reentrant locale using functions.  This is an
+   (almost) opaque type for the user level programs.  */
+# include <xlocale.h>
+
+/* Special versions of the functions above which take the locale to
+   use as an additional parameter.  */
+extern long int strtol_l (__const char *__restrict __nptr,
+			  char **__restrict __endptr, int __base,
+			  __locale_t __loc) __THROW;
+
+extern unsigned long int strtoul_l (__const char *__restrict __nptr,
+				    char **__restrict __endptr,
+				    int __base, __locale_t __loc) __THROW;
+
+__extension__
+extern long long int strtoll_l (__const char *__restrict __nptr,
+				char **__restrict __endptr, int __base,
+				__locale_t __loc) __THROW;
+
+__extension__
+extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
+					  char **__restrict __endptr,
+					  int __base, __locale_t __loc)
+     __THROW;
+
+extern double strtod_l (__const char *__restrict __nptr,
+			char **__restrict __endptr, __locale_t __loc)
+     __THROW;
+
+extern float strtof_l (__const char *__restrict __nptr,
+		       char **__restrict __endptr, __locale_t __loc) __THROW;
+
+extern long double strtold_l (__const char *__restrict __nptr,
+			      char **__restrict __endptr,
+			      __locale_t __loc) __THROW;
+
+/* Internal names to support libstd++. */
+extern long int __strtol_l (__const char *__restrict __nptr,
+			  char **__restrict __endptr, int __base,
+			  __locale_t __loc) __THROW;
+
+extern unsigned long int __strtoul_l (__const char *__restrict __nptr,
+				    char **__restrict __endptr,
+				    int __base, __locale_t __loc) __THROW;
+
+__extension__
+extern long long int __strtoll_l (__const char *__restrict __nptr,
+				char **__restrict __endptr, int __base,
+				__locale_t __loc) __THROW;
+
+__extension__
+extern unsigned long long int __strtoull_l (__const char *__restrict __nptr,
+					  char **__restrict __endptr,
+					  int __base, __locale_t __loc)
+     __THROW;
+
+extern double __strtod_l (__const char *__restrict __nptr,
+			char **__restrict __endptr, __locale_t __loc)
+     __THROW;
+
+extern float __strtof_l (__const char *__restrict __nptr,
+		       char **__restrict __endptr, __locale_t __loc) __THROW;
+
+extern long double __strtold_l (__const char *__restrict __nptr,
+			      char **__restrict __endptr,
+			      __locale_t __loc) __THROW;
+#endif /* GNU */
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+
+
+#if defined __USE_SVID || defined __USE_XOPEN_EXTENDED
+/* Convert N to base 64 using the digits "./0-9A-Za-z", least-significant
+   digit first.  Returns a pointer to static storage overwritten by the
+   next call.  */
+extern char *l64a (long int __n) __THROW;
+
+/* Read a number from a string S in base 64 as above.  */
+extern long int a64l (__const char *__s) __THROW __attribute_pure__;
+
+#endif	/* Use SVID || extended X/Open.  */
+
+#if defined __USE_SVID || defined __USE_XOPEN_EXTENDED || defined __USE_BSD
+# include <sys/types.h>	/* we need int32_t... */
+
+/* These are the functions that actually do things.  The `random', `srandom',
+   `initstate' and `setstate' functions are those from BSD Unices.
+   The `rand' and `srand' functions are required by the ANSI standard.
+   We provide both interfaces to the same random number generator.  */
+/* Return a random long integer between 0 and RAND_MAX inclusive.  */
+extern long int random (void) __THROW;
+
+/* Seed the random number generator with the given number.  */
+extern void srandom (unsigned int __seed) __THROW;
+
+/* Initialize the random number generator to use state buffer STATEBUF,
+   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,
+   32, 64, 128 and 256, the bigger the better; values less than 8 will
+   cause an error and values greater than 256 will be rounded down.  */
+extern char *initstate (unsigned int __seed, char *__statebuf,
+			size_t __statelen) __THROW;
+
+/* Switch the random number generator to state buffer STATEBUF,
+   which should have been previously initialized by `initstate'.  */
+extern char *setstate (char *__statebuf) __THROW;
+
+
+# ifdef __USE_MISC
+/* Reentrant versions of the `random' family of functions.
+   These functions all use the following data structure to contain
+   state, rather than global state variables.  */
+
+struct random_data
+  {
+    int32_t *fptr;		/* Front pointer.  */
+    int32_t *rptr;		/* Rear pointer.  */
+    int32_t *state;		/* Array of state values.  */
+    int rand_type;		/* Type of random number generator.  */
+    int rand_deg;		/* Degree of random number generator.  */
+    int rand_sep;		/* Distance between front and rear.  */
+    int32_t *end_ptr;		/* Pointer behind state table.  */
+  };
+
+extern int random_r (struct random_data *__restrict __buf,
+		     int32_t *__restrict __result) __THROW;
+
+extern int srandom_r (unsigned int __seed, struct random_data *__buf) __THROW;
+
+extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
+			size_t __statelen,
+			struct random_data *__restrict __buf) __THROW;
+
+extern int setstate_r (char *__restrict __statebuf,
+		       struct random_data *__restrict __buf) __THROW;
+# endif	/* Use misc.  */
+#endif	/* Use SVID || extended X/Open || BSD. */
+
+
+__BEGIN_NAMESPACE_STD
+/* Return a random integer between 0 and RAND_MAX inclusive.  */
+extern int rand (void) __THROW;
+/* Seed the random number generator with the given number.  */
+extern void srand (unsigned int __seed) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_POSIX
+/* Reentrant interface according to POSIX.1.  */
+extern int rand_r (unsigned int *__seed) __THROW;
+#endif
+
+
+#if defined __USE_SVID || defined __USE_XOPEN
+/* System V style 48-bit random number generator functions.  */
+
+#ifdef __UCLIBC_HAS_FLOATS__
+/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
+extern double drand48 (void) __THROW;
+extern double erand48 (unsigned short int __xsubi[3]) __THROW;
+#endif /* __UCLIBC_HAS_FLOATS__ */
+
+/* Return non-negative, long integer in [0,2^31).  */
+extern long int lrand48 (void) __THROW;
+extern long int nrand48 (unsigned short int __xsubi[3]) __THROW;
+
+/* Return signed, long integers in [-2^31,2^31).  */
+extern long int mrand48 (void) __THROW;
+extern long int jrand48 (unsigned short int __xsubi[3]) __THROW;
+
+/* Seed random number generator.  */
+extern void srand48 (long int __seedval) __THROW;
+extern unsigned short int *seed48 (unsigned short int __seed16v[3]) __THROW;
+extern void lcong48 (unsigned short int __param[7]) __THROW;
+
+# ifdef __USE_MISC
+/* Data structure for communication with thread safe versions.  This
+   type is to be regarded as opaque.  It's only exported because users
+   have to allocate objects of this type.  */
+struct drand48_data
+  {
+    unsigned short int __x[3];	/* Current state.  */
+    unsigned short int __old_x[3]; /* Old state.  */
+    unsigned short int __c;	/* Additive const. in congruential formula.  */
+    unsigned short int __init;	/* Flag for initializing.  */
+    unsigned long long int __a;	/* Factor in congruential formula.  */
+  };
+
+#ifdef __UCLIBC_HAS_FLOATS__
+/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
+extern int drand48_r (struct drand48_data *__restrict __buffer,
+		      double *__restrict __result) __THROW;
+extern int erand48_r (unsigned short int __xsubi[3],
+		      struct drand48_data *__restrict __buffer,
+		      double *__restrict __result) __THROW;
+#endif /* __UCLIBC_HAS_FLOATS__ */
+
+/* Return non-negative, long integer in [0,2^31).  */
+extern int lrand48_r (struct drand48_data *__restrict __buffer,
+		      long int *__restrict __result) __THROW;
+extern int nrand48_r (unsigned short int __xsubi[3],
+		      struct drand48_data *__restrict __buffer,
+		      long int *__restrict __result) __THROW;
+
+/* Return signed, long integers in [-2^31,2^31).  */
+extern int mrand48_r (struct drand48_data *__restrict __buffer,
+		      long int *__restrict __result) __THROW;
+extern int jrand48_r (unsigned short int __xsubi[3],
+		      struct drand48_data *__restrict __buffer,
+		      long int *__restrict __result) __THROW;
+
+/* Seed random number generator.  */
+extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
+     __THROW;
+
+extern int seed48_r (unsigned short int __seed16v[3],
+		     struct drand48_data *__buffer) __THROW;
+
+extern int lcong48_r (unsigned short int __param[7],
+		      struct drand48_data *__buffer) __THROW;
+# endif	/* Use misc.  */
+#endif	/* Use SVID or X/Open.  */
+
+#endif /* don't just need malloc and calloc */
+
+#ifndef __malloc_and_calloc_defined
+# define __malloc_and_calloc_defined
+__BEGIN_NAMESPACE_STD
+/* Allocate SIZE bytes of memory.  */
+extern void *malloc (size_t __size) __THROW __attribute_malloc__;
+/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
+extern void *calloc (size_t __nmemb, size_t __size)
+     __THROW __attribute_malloc__;
+__END_NAMESPACE_STD
+#endif
+
+#ifndef __need_malloc_and_calloc
+__BEGIN_NAMESPACE_STD
+/* Re-allocate the previously allocated block
+   in PTR, making the new block SIZE bytes long.  */
+extern void *realloc (void *__ptr, size_t __size) __THROW __attribute_malloc__;
+/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
+extern void free (void *__ptr) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef	__USE_MISC
+/* Free a block.  An alias for `free'.	(Sun Unices).  */
+extern void cfree (void *__ptr) __THROW;
+#endif /* Use misc.  */
+
+#if defined __USE_GNU || defined __USE_BSD || defined __USE_MISC
+# include <alloca.h>
+#endif /* Use GNU, BSD, or misc.  */
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */
+extern void *valloc (size_t __size) __THROW __attribute_malloc__;
+#endif
+
+#ifdef __USE_XOPEN2K
+/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */
+extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
+     __THROW __attribute_malloc__;
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Abort execution and generate a core-dump.  */
+extern void abort (void) __THROW __attribute__ ((__noreturn__));
+
+
+/* Register a function to be called when `exit' is called.  */
+extern int atexit (void (*__func) (void)) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef	__USE_MISC
+/* Register a function to be called with the status
+   given to `exit' and the given argument.  */
+extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
+     __THROW;
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Call all functions registered with `atexit' and `on_exit',
+   in the reverse of the order in which they were registered
+   perform stdio cleanup, and terminate program execution with STATUS.  */
+extern void exit (int __status) __THROW __attribute__ ((__noreturn__));
+__END_NAMESPACE_STD
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Terminate the program with STATUS without calling any of the
+   functions registered with `atexit' or `on_exit'.  */
+extern void _Exit (int __status) __THROW __attribute__ ((__noreturn__));
+__END_NAMESPACE_C99
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
+extern char *getenv (__const char *__name) __THROW;
+__END_NAMESPACE_STD
+
+/* This function is similar to the above but returns NULL if the
+   programs is running with SUID or SGID enabled.  */
+extern char *__secure_getenv (__const char *__name) __THROW;
+
+#if defined __USE_SVID || defined __USE_XOPEN
+/* The SVID says this is in <stdio.h>, but this seems a better place.	*/
+/* Put STRING, which is of the form "NAME=VALUE", in the environment.
+   If there is no `=', remove NAME from the environment.  */
+extern int putenv (char *__string) __THROW;
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+/* Set NAME to VALUE in the environment.
+   If REPLACE is nonzero, overwrite an existing value.  */
+extern int setenv (__const char *__name, __const char *__value, int __replace)
+     __THROW;
+
+/* Remove the variable NAME from the environment.  */
+extern int unsetenv (__const char *__name) __THROW;
+#endif
+
+/* The following is used by uClibc in atexit.c and sysconf.c */
+/* We have no limit when __UCLIBC_DYNAMIC_ATEXIT__ is enabled.  */
+#ifdef __UCLIBC_DYNAMIC_ATEXIT__
+# define __UCLIBC_MAX_ATEXIT     INT_MAX
+#else
+# define __UCLIBC_MAX_ATEXIT     20
+#endif
+
+
+#ifdef	__USE_MISC
+/* The `clearenv' was planned to be added to POSIX.1 but probably
+   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
+   for Fortran 77) requires this function.  */
+extern int clearenv (void) __THROW;
+#endif
+
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED
+/* Generate a unique temporary file name from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   Returns TEMPLATE, or a null pointer if it cannot get a unique file name.  */
+extern char *mktemp (char *__template) __THROW;
+
+/* Generate a unique temporary file name from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the filename unique.
+   Returns a file descriptor open on the file for reading and writing,
+   or -1 if it cannot create a uniquely-named file.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int mkstemp (char *__template);
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (mkstemp, (char *__template), mkstemp64);
+#  else
+#   define mkstemp mkstemp64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int mkstemp64 (char *__template);
+# endif
+#endif
+
+#ifdef __USE_BSD
+/* Create a unique temporary directory from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the directory name unique.
+   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
+   The directory is created mode 700.  */
+extern char *mkdtemp (char *__template) __THROW;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Execute the given line as a shell command.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int system (__const char *__command);
+__END_NAMESPACE_STD
+
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Return the canonical absolute name of file NAME.  The last file name
+   component need not exist, and may be a symlink to a nonexistent file.
+   If RESOLVED is null, the result is malloc'd; otherwise, if the canonical
+   name is PATH_MAX chars or more, returns null with `errno' set to
+   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars, returns the
+   name in RESOLVED.  */
+extern char *realpath (__const char *__restrict __name,
+		       char *__restrict __resolved) __THROW;
+#endif
+
+
+/* Shorthand for type of comparison functions.  */
+#ifndef __COMPAR_FN_T
+# define __COMPAR_FN_T
+typedef int (*__compar_fn_t) (__const void *, __const void *);
+
+# ifdef	__USE_GNU
+typedef __compar_fn_t comparison_fn_t;
+# endif
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Do a binary search for KEY in BASE, which consists of NMEMB elements
+   of SIZE bytes each, using COMPAR to perform the comparisons.  */
+extern void *bsearch (__const void *__key, __const void *__base,
+		      size_t __nmemb, size_t __size, __compar_fn_t __compar);
+
+/* Sort NMEMB elements of BASE, of SIZE bytes each,
+   using COMPAR to perform the comparisons.  */
+extern void qsort (void *__base, size_t __nmemb, size_t __size,
+		   __compar_fn_t __compar);
+
+
+/* Return the absolute value of X.  */
+extern int abs (int __x) __THROW __attribute__ ((__const__));
+extern long int labs (long int __x) __THROW __attribute__ ((__const__));
+__END_NAMESPACE_STD
+
+#ifdef __USE_ISOC99
+__extension__ extern long long int llabs (long long int __x)
+     __THROW __attribute__ ((__const__));
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Return the `div_t', `ldiv_t' or `lldiv_t' representation
+   of the value of NUMER over DENOM. */
+/* GCC may have built-ins for these someday.  */
+extern div_t div (int __numer, int __denom)
+     __THROW __attribute__ ((__const__));
+extern ldiv_t ldiv (long int __numer, long int __denom)
+     __THROW __attribute__ ((__const__));
+__END_NAMESPACE_STD
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+__extension__ extern lldiv_t lldiv (long long int __numer,
+				    long long int __denom)
+     __THROW __attribute__ ((__const__));
+__END_NAMESPACE_C99
+#endif
+
+
+#ifdef __UCLIBC_HAS_WCHAR__
+__BEGIN_NAMESPACE_STD
+/* Return the length of the multibyte character
+   in S, which is no longer than N.  */
+extern int mblen (__const char *__s, size_t __n) __THROW;
+/* Return the length of the given multibyte character,
+   putting its `wchar_t' representation in *PWC.  */
+extern int mbtowc (wchar_t *__restrict __pwc,
+		   __const char *__restrict __s, size_t __n) __THROW;
+/* Put the multibyte character represented
+   by WCHAR in S, returning its length.  */
+extern int wctomb (char *__s, wchar_t __wchar) __THROW;
+
+
+/* Convert a multibyte string to a wide char string.  */
+extern size_t mbstowcs (wchar_t *__restrict  __pwcs,
+			__const char *__restrict __s, size_t __n) __THROW;
+/* Convert a wide char string to multibyte string.  */
+extern size_t wcstombs (char *__restrict __s,
+			__const wchar_t *__restrict __pwcs, size_t __n)
+     __THROW;
+__END_NAMESPACE_STD
+#endif /* __UCLIBC_HAS_WCHAR__ */
+
+
+#ifdef __USE_SVID
+/* Determine whether the string value of RESPONSE matches the affirmation
+   or negative response expression as specified by the LC_MESSAGES category
+   in the program's current locale.  Returns 1 if affirmative, 0 if
+   negative, and -1 if not matching.  */
+extern int rpmatch (__const char *__response) __THROW;
+#endif
+
+
+#ifdef __USE_XOPEN_EXTENDED
+/* Parse comma separated suboption from *OPTIONP and match against
+   strings in TOKENS.  If found return index and set *VALUEP to
+   optional value introduced by an equal sign.  If the suboption is
+   not part of TOKENS return in *VALUEP beginning of unknown
+   suboption.  On exit *OPTIONP is set to the beginning of the next
+   token or at the terminating NUL character.  */
+extern int getsubopt (char **__restrict __optionp,
+		      char *__const *__restrict __tokens,
+		      char **__restrict __valuep) __THROW;
+#endif
+
+
+#ifdef __USE_XOPEN
+/* Setup DES tables according KEY.  */
+extern void setkey (__const char *__key) __THROW;
+#endif
+
+
+/* X/Open pseudo terminal handling.  */
+
+#ifdef __USE_XOPEN2K
+/* Return a master pseudo-terminal handle.  */
+extern int posix_openpt (int __oflag) __THROW;
+#endif
+
+#ifdef __USE_XOPEN
+/* The next four functions all take a master pseudo-tty fd and
+   perform an operation on the associated slave:  */
+
+/* Chown the slave to the calling user.  */
+extern int grantpt (int __fd) __THROW;
+
+/* Release an internal lock so the slave can be opened.
+   Call after grantpt().  */
+extern int unlockpt (int __fd) __THROW;
+
+/* Return the pathname of the pseudo terminal slave assoicated with
+   the master FD is open on, or NULL on errors.
+   The returned storage is good until the next call to this function.  */
+extern char *ptsname (int __fd) __THROW;
+#endif
+
+#ifdef __USE_GNU
+/* Store at most BUFLEN characters of the pathname of the slave pseudo
+   terminal associated with the master FD is open on in BUF.
+   Return 0 on success, otherwise an error number.  */
+extern int ptsname_r (int __fd, char *__buf, size_t __buflen) __THROW;
+
+/* Open a master pseudo terminal and return its file descriptor.  */
+extern int getpt (void) __THROW;
+#endif
+
+#endif /* don't just need malloc and calloc */
+#undef __need_malloc_and_calloc
+
+__END_DECLS
+
+#endif /* stdlib.h  */
diff -pruwN busybox-1.01/include2/string.h busybox-1.01-livebox/include2/string.h
--- busybox-1.01/include2/string.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/string.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,429 @@
+/* Copyright (C) 1991-1993, 1995-2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99 Standard: 7.21 String handling	<string.h>
+ */
+
+#ifndef	_STRING_H
+#define	_STRING_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Get size_t and NULL from <stddef.h>.  */
+#define	__need_size_t
+#define	__need_NULL
+#include <stddef.h>
+
+
+__BEGIN_NAMESPACE_STD
+/* Copy N bytes of SRC to DEST.  */
+extern void *memcpy (void *__restrict __dest,
+		     __const void *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+/* Copy N bytes of SRC to DEST, guaranteeing
+   correct behavior for overlapping strings.  */
+extern void *memmove (void *__dest, __const void *__src, size_t __n)
+     __THROW __nonnull ((1, 2));
+__END_NAMESPACE_STD
+
+/* Copy no more than N bytes of SRC to DEST, stopping when C is found.
+   Return the position in DEST one byte past where C was copied,
+   or NULL if C was not found in the first N bytes of SRC.  */
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN
+extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
+		      int __c, size_t __n)
+     __THROW __nonnull ((1, 2));
+#endif /* SVID.  */
+
+
+__BEGIN_NAMESPACE_STD
+/* Set N bytes of S to C.  */
+extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1));
+
+/* Compare N bytes of S1 and S2.  */
+extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+/* Search N bytes of S for C.  */
+extern void *memchr (__const void *__s, int __c, size_t __n)
+      __THROW __attribute_pure__ __nonnull ((1));
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* Search in S for C.  This is similar to `memchr' but there is no
+   length limit.  */
+extern void *rawmemchr (__const void *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+
+/* Search N bytes of S for the final occurrence of C.  */
+extern void *memrchr (__const void *__s, int __c, size_t __n)
+      __THROW __attribute_pure__ __nonnull ((1));
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Copy SRC to DEST.  */
+extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
+     __THROW __nonnull ((1, 2));
+/* Copy no more than N characters of SRC to DEST.  */
+extern char *strncpy (char *__restrict __dest,
+		      __const char *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+
+/* Append SRC onto DEST.  */
+extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
+     __THROW __nonnull ((1, 2));
+/* Append no more than N characters from SRC onto DEST.  */
+extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
+		      size_t __n) __THROW __nonnull ((1, 2));
+
+/* Compare S1 and S2.  */
+extern int strcmp (__const char *__s1, __const char *__s2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+/* Compare N characters of S1 and S2.  */
+extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+/* Compare the collated forms of S1 and S2.  */
+extern int strcoll (__const char *__s1, __const char *__s2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+/* Put a transformation of SRC into no more than N bytes of DEST.  */
+extern size_t strxfrm (char *__restrict __dest,
+		       __const char *__restrict __src, size_t __n)
+     __THROW __nonnull ((2));
+__END_NAMESPACE_STD
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+#ifdef __USE_GNU
+/* The following functions are equivalent to the both above but they
+   take the locale they use for the collation as an extra argument.
+   This is not standardsized but something like will come.  */
+# include <xlocale.h>
+
+/* Compare the collated forms of S1 and S2 using rules from L.  */
+extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 3));
+extern int __strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 3));
+
+/* Put a transformation of SRC into no more than N bytes of DEST.  */
+extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
+			 __locale_t __l) __THROW __nonnull ((2, 4));
+extern size_t __strxfrm_l (char *__dest, __const char *__src, size_t __n,
+			 __locale_t __l) __THROW __nonnull ((2, 4));
+
+#endif
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Duplicate S, returning an identical malloc'd string.  */
+extern char *strdup (__const char *__s)
+     __THROW __attribute_malloc__ __nonnull ((1));
+#endif
+
+/* Return a malloc'd copy of at most N bytes of STRING.  The
+   resultant string is terminated even if no null terminator
+   appears before STRING[N].  */
+#if defined __USE_GNU
+extern char *strndup (__const char *__string, size_t __n)
+     __THROW __attribute_malloc__ __nonnull ((1));
+#endif
+
+#if defined __USE_GNU && defined __GNUC__
+/* Duplicate S, returning an identical alloca'd string.  */
+# define strdupa(s)							      \
+  (__extension__							      \
+    ({									      \
+      __const char *__old = (s);					      \
+      size_t __len = strlen (__old) + 1;				      \
+      char *__new = (char *) __builtin_alloca (__len);			      \
+      (char *) memcpy (__new, __old, __len);				      \
+    }))
+
+/* Return an alloca'd copy of at most N bytes of string.  */
+# define strndupa(s, n)							      \
+  (__extension__							      \
+    ({									      \
+      __const char *__old = (s);					      \
+      size_t __len = strnlen (__old, (n));				      \
+      char *__new = (char *) __builtin_alloca (__len + 1);		      \
+      __new[__len] = '\0';						      \
+      (char *) memcpy (__new, __old, __len);				      \
+    }))
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Find the first occurrence of C in S.  */
+extern char *strchr (__const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+/* Find the last occurrence of C in S.  */
+extern char *strrchr (__const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* This function is similar to `strchr'.  But it returns a pointer to
+   the closing NUL byte in case C is not found in S.  */
+extern char *strchrnul (__const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Return the length of the initial segment of S which
+   consists entirely of characters not in REJECT.  */
+extern size_t strcspn (__const char *__s, __const char *__reject)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+/* Return the length of the initial segment of S which
+   consists entirely of characters in ACCEPT.  */
+extern size_t strspn (__const char *__s, __const char *__accept)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+/* Find the first occurrence in S of any character in ACCEPT.  */
+extern char *strpbrk (__const char *__s, __const char *__accept)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+/* Find the first occurrence of NEEDLE in HAYSTACK.  */
+extern char *strstr (__const char *__haystack, __const char *__needle)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+
+/* Divide S into tokens separated by characters in DELIM.  */
+extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
+     __THROW __nonnull ((2));
+__END_NAMESPACE_STD
+
+/* Divide S into tokens separated by characters in DELIM.  Information
+   passed between calls are stored in SAVE_PTR.  */
+extern char *__strtok_r (char *__restrict __s,
+			 __const char *__restrict __delim,
+			 char **__restrict __save_ptr)
+     __THROW __nonnull ((2, 3));
+#if defined __USE_POSIX || defined __USE_MISC
+extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
+		       char **__restrict __save_ptr)
+     __THROW __nonnull ((2, 3));
+#endif
+
+#ifdef __USE_GNU
+/* Similar to `strstr' but this function ignores the case of both strings.  */
+extern char *strcasestr (__const char *__haystack, __const char *__needle)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+#endif
+
+#ifdef __USE_GNU
+/* Find the first occurrence of NEEDLE in HAYSTACK.
+   NEEDLE is NEEDLELEN bytes long;
+   HAYSTACK is HAYSTACKLEN bytes long.  */
+extern void *memmem (__const void *__haystack, size_t __haystacklen,
+		     __const void *__needle, size_t __needlelen)
+     __THROW __attribute_pure__ __nonnull ((1, 3));
+
+/* Copy N bytes of SRC to DEST, return pointer to bytes after the
+   last written byte.  */
+extern void *__mempcpy (void *__restrict __dest,
+			__const void *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+extern void *mempcpy (void *__restrict __dest,
+		      __const void *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Return the length of S.  */
+extern size_t strlen (__const char *__s)
+     __THROW __attribute_pure__ __nonnull ((1));
+__END_NAMESPACE_STD
+
+#ifdef	__USE_GNU
+/* Find the length of STRING, but scan at most MAXLEN characters.
+   If no '\0' terminator is found in that many characters, return MAXLEN.  */
+extern size_t strnlen (__const char *__string, size_t __maxlen)
+     __THROW __attribute_pure__ __nonnull ((1));
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
+extern char *strerror (int __errnum) __THROW;
+__END_NAMESPACE_STD
+
+extern char *__glibc_strerror_r (int __errnum, char *__buf, size_t __buflen)
+     __THROW __nonnull ((2));
+extern int __xpg_strerror_r (int __errnum, char *__buf, size_t __buflen)
+     __THROW __nonnull ((2));
+
+#if defined __USE_XOPEN2K || defined __USE_MISC
+/* Reentrant version of `strerror'.
+   There are 2 flavors of `strerror_r', GNU which returns the string
+   and may or may not use the supplied temporary buffer and POSIX one
+   which fills the string into the buffer.
+   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
+   without -D_GNU_SOURCE is needed, otherwise the GNU version is
+   preferred.  */
+# if defined __USE_XOPEN2K && !defined __USE_GNU
+/* Fill BUF with a string describing the meaning of the `errno' code in
+   ERRNUM.  */
+#  ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (strerror_r,
+			   (int __errnum, char *__buf, size_t __buflen),
+			   __xpg_strerror_r) __nonnull ((2));
+#  else
+#   define strerror_r __xpg_strerror_r
+#  endif
+# else
+/* If a temporary buffer is required, at most BUFLEN bytes of BUF will be
+   used.  */
+#  ifdef __REDIRECT_NTH
+extern char * __REDIRECT_NTH (strerror_r,
+			   (int __errnum, char *__buf, size_t __buflen),
+			   __glibc_strerror_r) __nonnull ((2));
+#  else
+#   define strerror_r __glibc_strerror_r
+#  endif
+# endif
+#endif
+
+/* We define this function always since `bzero' is sometimes needed when
+   the namespace rules does not allow this.  */
+extern void __bzero (void *__s, size_t __n) __THROW __nonnull ((1));
+
+#ifdef __USE_BSD
+/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
+extern void bcopy (__const void *__src, void *__dest, size_t __n)
+     __THROW __nonnull ((1, 2));
+
+/* Set N bytes of S to 0.  */
+extern void bzero (void *__s, size_t __n) __THROW __nonnull ((1));
+
+/* Compare N bytes of S1 and S2 (same as memcmp).  */
+extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+/* Find the first occurrence of C in S (same as strchr).  */
+extern char *index (__const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+
+/* Find the last occurrence of C in S (same as strrchr).  */
+extern char *rindex (__const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+
+/* Return the position of the first bit set in I, or 0 if none are set.
+   The least-significant bit is position 1, the most-significant 32.  */
+extern int ffs (int __i) __THROW __attribute__ ((__const__));
+
+/* The following two functions are non-standard but necessary for non-32 bit
+   platforms.  */
+# ifdef	__USE_GNU
+extern int ffsl (long int __l) __THROW __attribute__ ((__const__));
+#  ifdef __GNUC__
+__extension__ extern int ffsll (long long int __ll)
+     __THROW __attribute__ ((__const__));
+#  endif
+# endif
+
+/* Compare S1 and S2, ignoring case.  */
+extern int strcasecmp (__const char *__s1, __const char *__s2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+/* Compare no more than N chars of S1 and S2, ignoring case.  */
+extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+#endif /* Use BSD.  */
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+#ifdef	__USE_GNU
+/* Again versions of a few functions which use the given locale instead
+   of the global one.  */
+extern int strcasecmp_l (__const char *__s1, __const char *__s2,
+			 __locale_t __loc)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 3));
+extern int __strcasecmp_l (__const char *__s1, __const char *__s2,
+			 __locale_t __loc)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 3));
+
+extern int strncasecmp_l (__const char *__s1, __const char *__s2,
+			  size_t __n, __locale_t __loc)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 4));
+extern int __strncasecmp_l (__const char *__s1, __const char *__s2,
+			  size_t __n, __locale_t __loc)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 4));
+#endif
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+
+#ifdef	__USE_BSD
+/* Return the next DELIM-delimited token from *STRINGP,
+   terminating it with a '\0', and update *STRINGP to point past it.  */
+extern char *strsep (char **__restrict __stringp,
+		     __const char *__restrict __delim)
+     __THROW __nonnull ((1, 2));
+#endif
+
+#ifdef	__USE_GNU
+/* Compare S1 and S2 as strings holding name & indices/version numbers.  */
+extern int strverscmp (__const char *__s1, __const char *__s2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+/* Return a string describing the meaning of the signal number in SIG.  */
+extern char *strsignal (int __sig) __THROW;
+
+/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
+extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     __THROW __nonnull ((1, 2));
+extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     __THROW __nonnull ((1, 2));
+
+/* Copy no more than N characters of SRC to DEST, returning the address of
+   the last character written into DEST.  */
+extern char *__stpncpy (char *__restrict __dest,
+			__const char *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+extern char *stpncpy (char *__restrict __dest,
+		      __const char *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+
+#if 0							/* uClibc does not support strfry or memfrob. */
+/* Sautee STRING briskly.  */
+extern char *strfry (char *__string) __THROW __nonnull ((1));
+
+/* Frobnicate N bytes of S.  */
+extern void *memfrob (void *__s, size_t __n) __THROW __nonnull ((1));
+#endif
+
+# ifndef basename
+/* Return the file name within directory of FILENAME.  We don't
+   declare the function if the `basename' macro is available (defined
+   in <libgen.h>) which makes the XPG version of this function
+   available.  */
+extern char *basename (__const char *__filename) __THROW __nonnull ((1));
+# endif
+#endif
+
+
+#ifdef	__USE_BSD
+/* Two OpenBSD extension functions. */
+extern size_t strlcat(char *__restrict dst, const char *__restrict src,
+                      size_t n) __THROW __nonnull ((1, 2));
+extern size_t strlcpy(char *__restrict dst, const char *__restrict src,
+                      size_t n) __THROW __nonnull ((1, 2));
+#endif
+
+__END_DECLS
+
+#endif /* string.h  */
diff -pruwN busybox-1.01/include2/sys/cdefs.h busybox-1.01-livebox/include2/sys/cdefs.h
--- busybox-1.01/include2/sys/cdefs.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/cdefs.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,315 @@
+/* Copyright (C) 1992-2001, 2002, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_CDEFS_H
+#define	_SYS_CDEFS_H	1
+
+/* We are almost always included from features.h. */
+#ifndef _FEATURES_H
+# include <features.h>
+#endif
+
+/* The GNU libc does not support any K&R compilers or the traditional mode
+   of ISO C compilers anymore.  Check for some of the combinations not
+   anymore supported.  */
+#if defined __GNUC__ && !defined __STDC__
+# error "You need a ISO C conforming compiler to use the glibc headers"
+#endif
+
+/* Some user header file might have defined this before.  */
+#undef	__P
+#undef	__PMT
+
+#ifdef __GNUC__
+
+/* GCC can always grok prototypes.  For C++ programs we add throw()
+   to help it optimize the function calls.  But this works only with
+   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
+   as non-throwing using a function attribute since programs can use
+   the -fexceptions options for C code as well.  */
+# if 0 //!defined __cplusplus && __GNUC_PREREQ (3, 3)
+#  define __THROW	__attribute__ ((__nothrow__))
+#  define __NTH(fct)	__attribute__ ((__nothrow__)) fct
+# else
+#  if defined __cplusplus && __GNUC_PREREQ (2,8)
+#   define __THROW	throw ()
+#   define __NTH(fct)	fct throw ()
+#  else
+#   define __THROW
+#   define __NTH(fct)	fct
+#  endif
+# endif
+
+#else	/* Not GCC.  */
+
+# define __inline		/* No inline functions.  */
+
+# define __THROW
+# define __NTH(fct)	fct
+
+# define __const	const
+# define __signed	signed
+# define __volatile	volatile
+
+#endif	/* GCC.  */
+
+/* These two macros are not used in glibc anymore.  They are kept here
+   only because some other projects expect the macros to be defined.  */
+#define __P(args)	args
+#define __PMT(args)	args
+
+/* For these things, GCC behaves the ANSI way normally,
+   and the non-ANSI way under -traditional.  */
+
+#define __CONCAT(x,y)	x ## y
+#define __STRING(x)	#x
+
+/* This is not a typedef so `const __ptr_t' does the right thing.  */
+#define __ptr_t void *
+#define __long_double_t  long double
+
+
+/* C++ needs to know that types and declarations are C, not C++.  */
+#ifdef	__cplusplus
+# define __BEGIN_DECLS	extern "C" {
+# define __END_DECLS	}
+#else
+# define __BEGIN_DECLS
+# define __END_DECLS
+#endif
+
+
+/* The standard library needs the functions from the ISO C90 standard
+   in the std namespace.  At the same time we want to be safe for
+   future changes and we include the ISO C99 code in the non-standard
+   namespace __c99.  The C++ wrapper header take case of adding the
+   definitions to the global namespace.  */
+#if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES
+# define __BEGIN_NAMESPACE_STD	namespace std {
+# define __END_NAMESPACE_STD	}
+# define __USING_NAMESPACE_STD(name) using std::name;
+# define __BEGIN_NAMESPACE_C99	namespace __c99 {
+# define __END_NAMESPACE_C99	}
+# define __USING_NAMESPACE_C99(name) using __c99::name;
+#else
+/* For compatibility we do not add the declarations into any
+   namespace.  They will end up in the global namespace which is what
+   old code expects.  */
+# define __BEGIN_NAMESPACE_STD
+# define __END_NAMESPACE_STD
+# define __USING_NAMESPACE_STD(name)
+# define __BEGIN_NAMESPACE_C99
+# define __END_NAMESPACE_C99
+# define __USING_NAMESPACE_C99(name)
+#endif
+
+
+/* Support for bounded pointers.  */
+#ifndef __BOUNDED_POINTERS__
+# define __bounded	/* nothing */
+# define __unbounded	/* nothing */
+# define __ptrvalue	/* nothing */
+#endif
+
+
+/* Fortify support.  */
+#define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)
+#define __bos0(ptr) __builtin_object_size (ptr, 0)
+#define __warndecl(name, msg) extern void name (void)
+
+
+/* Support for flexible arrays.  */
+#if __GNUC_PREREQ (2,97)
+/* GCC 2.97 supports C99 flexible array members.  */
+# define __flexarr	[]
+#else
+# ifdef __GNUC__
+#  define __flexarr	[0]
+# else
+#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#   define __flexarr	[]
+#  else
+/* Some other non-C99 compiler.  Approximate with [1].  */
+#   define __flexarr	[1]
+#  endif
+# endif
+#endif
+
+
+/* __asm__ ("xyz") is used throughout the headers to rename functions
+   at the assembly language level.  This is wrapped by the __REDIRECT
+   macro, in order to support compilers that can do this some other
+   way.  When compilers don't support asm-names at all, we have to do
+   preprocessor tricks instead (which don't have exactly the right
+   semantics, but it's the best we can do).
+
+   Example:
+   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+# define __REDIRECT(name, proto, alias) name proto __asm__ (__ASMNAME (#alias))
+# define __ASMNAME(cname) __C_SYMBOL_PREFIX__ cname
+/*
+# ifdef __cplusplus
+#  define __REDIRECT_NTH(name, proto, alias) \
+     name proto __THROW __asm__ (__ASMNAME (#alias))
+# else
+#  define __REDIRECT_NTH(name, proto, alias) \
+     name proto __asm__ (__ASMNAME (#alias)) __THROW
+# endif
+# define __ASMNAME(cname)  __ASMNAME2 (__USER_LABEL_PREFIX__, cname)
+# define __ASMNAME2(prefix, cname) __STRING (prefix) cname
+*/
+
+/*
+#elif __SOME_OTHER_COMPILER__
+
+# define __REDIRECT(name, proto, alias) name proto; \
+	_Pragma("let " #name " = " #alias)
+*/
+#endif
+
+/* GCC has various useful declarations that can be made with the
+   `__attribute__' syntax.  All of the ways we use this do fine if
+   they are omitted for compilers that don't understand it. */
+#if !defined __GNUC__ || __GNUC__ < 2
+# define __attribute__(xyz)	/* Ignore */
+#endif
+
+/* At some point during the gcc 2.96 development the `malloc' attribute
+   for functions was introduced.  We don't want to use it unconditionally
+   (although this would be possible) since it generates warnings.  */
+#if __GNUC_PREREQ (2,96)
+# define __attribute_malloc__ __attribute__ ((__malloc__))
+#else
+# define __attribute_malloc__ /* Ignore */
+#endif
+
+/* At some point during the gcc 2.96 development the `pure' attribute
+   for functions was introduced.  We don't want to use it unconditionally
+   (although this would be possible) since it generates warnings.  */
+#if __GNUC_PREREQ (2,96)
+# define __attribute_pure__ __attribute__ ((__pure__))
+#else
+# define __attribute_pure__ /* Ignore */
+#endif
+
+/* At some point during the gcc 3.1 development the `used' attribute
+   for functions was introduced.  We don't want to use it unconditionally
+   (although this would be possible) since it generates warnings.  */
+#if __GNUC_PREREQ (3,1)
+# define __attribute_used__ __attribute__ ((__used__))
+# define __attribute_noinline__ __attribute__ ((__noinline__))
+#else
+# define __attribute_used__ __attribute__ ((__unused__))
+# define __attribute_noinline__ /* Ignore */
+#endif
+
+/* gcc allows marking deprecated functions.  */
+#if __GNUC_PREREQ (3,2)
+# define __attribute_deprecated__ __attribute__ ((__deprecated__))
+#else
+# define __attribute_deprecated__ /* Ignore */
+#endif
+
+/* At some point during the gcc 2.8 development the `format_arg' attribute
+   for functions was introduced.  We don't want to use it unconditionally
+   (although this would be possible) since it generates warnings.
+   If several `format_arg' attributes are given for the same function, in
+   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
+   all designated arguments are considered.  */
+#if __GNUC_PREREQ (2,8)
+# define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))
+#else
+# define __attribute_format_arg__(x) /* Ignore */
+#endif
+
+/* At some point during the gcc 2.97 development the `strfmon' format
+   attribute for functions was introduced.  We don't want to use it
+   unconditionally (although this would be possible) since it
+   generates warnings.  */
+#if __GNUC_PREREQ (2,97)
+# define __attribute_format_strfmon__(a,b) \
+  __attribute__ ((__format__ (__strfmon__, a, b)))
+#else
+# define __attribute_format_strfmon__(a,b) /* Ignore */
+#endif
+
+/* The nonull function attribute allows to mark pointer parameters which
+   must not be NULL.  */
+#if __GNUC_PREREQ (3,3)
+# define __nonnull(params) __attribute__ ((__nonnull__ params))
+#else
+# define __nonnull(params)
+#endif
+
+/* If fortification mode, we warn about unused results of certain
+   function calls which can lead to problems.  */
+#if __GNUC_PREREQ (3,4)
+# define __attribute_warn_unused_result__ \
+   __attribute__ ((__warn_unused_result__))
+# if __USE_FORTIFY_LEVEL > 0
+#  define __wur __attribute_warn_unused_result__
+# endif
+#else
+# define __attribute_warn_unused_result__ /* empty */
+#endif
+#ifndef __wur
+# define __wur /* Ignore */
+#endif
+
+/* Forces a function to be always inlined.  */
+#if __GNUC_PREREQ (3,2)
+# define __always_inline __inline __attribute__ ((__always_inline__))
+#else
+# define __always_inline __inline
+#endif
+
+/* It is possible to compile containing GCC extensions even if GCC is
+   run in pedantic mode if the uses are carefully marked using the
+   `__extension__' keyword.  But this is not generally available before
+   version 2.8.  */
+#if !__GNUC_PREREQ (2,8)
+# define __extension__		/* Ignore */
+#endif
+
+/* __restrict is known in EGCS 1.2 and above. */
+#if !__GNUC_PREREQ (2,92)
+# define __restrict	/* Ignore */
+#endif
+
+/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
+     array_name[restrict]
+   GCC 3.1 supports this.  */
+#if __GNUC_PREREQ (3,1) && !defined __GNUG__
+# define __restrict_arr	__restrict
+#else
+# ifdef __GNUC__
+#  define __restrict_arr	/* Not supported in old GCC.  */
+# else
+#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#   define __restrict_arr	restrict
+#  else
+/* Some other non-C99 compiler.  */
+#   define __restrict_arr	/* Not supported.  */
+#  endif
+# endif
+#endif
+
+#endif	 /* sys/cdefs.h */
diff -pruwN busybox-1.01/include2/sys/file.h busybox-1.01-livebox/include2/sys/file.h
--- busybox-1.01/include2/sys/file.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/file.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,56 @@
+/* Copyright (C) 1991, 92, 96, 97, 98, 99 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_FILE_H
+#define	_SYS_FILE_H	1
+
+#include <features.h>
+
+#ifndef	_FCNTL_H
+# include <fcntl.h>
+#endif
+
+__BEGIN_DECLS
+
+
+/* Alternate names for values for the WHENCE argument to `lseek'.
+   These are the same as SEEK_SET, SEEK_CUR, and SEEK_END, respectively.  */
+#ifndef L_SET
+# define L_SET	0	/* Seek from beginning of file.  */
+# define L_INCR	1	/* Seek from current position.  */
+# define L_XTND	2	/* Seek from end of file.  */
+#endif
+
+
+/* Operations for the `flock' call.  */
+#define	LOCK_SH	1	/* Shared lock.  */
+#define	LOCK_EX	2 	/* Exclusive lock.  */
+#define	LOCK_UN	8	/* Unlock.  */
+
+/* Can be OR'd in to one of the above.  */
+#define	LOCK_NB	4	/* Don't block when locking.  */
+
+
+/* Apply or remove an advisory lock, according to OPERATION,
+   on the file FD refers to.  */
+extern int flock (int __fd, int __operation) __THROW;
+
+
+__END_DECLS
+
+#endif /* sys/file.h  */
diff -pruwN busybox-1.01/include2/sys/ioctl.h busybox-1.01-livebox/include2/sys/ioctl.h
--- busybox-1.01/include2/sys/ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/ioctl.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,46 @@
+/* Copyright (C) 1991, 92, 93, 94, 96, 98, 99 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_IOCTL_H
+#define	_SYS_IOCTL_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Get the list of `ioctl' requests and related constants.  */
+#include <bits/ioctls.h>
+
+/* Define some types used by `ioctl' requests.  */
+#include <bits/ioctl-types.h>
+
+/* On a Unix system, the system <sys/ioctl.h> probably defines some of
+   the symbols we define in <sys/ttydefaults.h> (usually with the same
+   values).  The code to generate <bits/ioctls.h> has omitted these
+   symbols to avoid the conflict, but a Unix program expects <sys/ioctl.h>
+   to define them, so we must include <sys/ttydefaults.h> here.  */
+#include <sys/ttydefaults.h>
+
+/* Perform the I/O control operation specified by REQUEST on FD.
+   One argument may follow; its presence and type depend on REQUEST.
+   Return value depends on REQUEST.  Usually -1 indicates error.  */
+extern int ioctl (int __fd, unsigned long int __request, ...) __THROW;
+
+__END_DECLS
+
+#endif /* sys/ioctl.h */
diff -pruwN busybox-1.01/include2/sys/mman.h busybox-1.01-livebox/include2/sys/mman.h
--- busybox-1.01/include2/sys/mman.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/mman.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,139 @@
+/* Definitions for BSD-style memory management.
+   Copyright (C) 1994-1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_MMAN_H
+#define	_SYS_MMAN_H	1
+
+#include <features.h>
+#include <bits/types.h>
+#define __need_size_t
+#include <stddef.h>
+
+#ifndef __off_t_defined
+# ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+# else
+typedef __off64_t off_t;
+# endif
+# define __off_t_defined
+#endif
+
+#ifndef __mode_t_defined
+typedef __mode_t mode_t;
+# define __mode_t_defined
+#endif
+
+#include <bits/mman.h>
+
+/* Return value of `mmap' in case of an error.  */
+#define MAP_FAILED	((void *) -1)
+
+__BEGIN_DECLS
+/* Map addresses starting near ADDR and extending for LEN bytes.  from
+   OFFSET into the file FD describes according to PROT and FLAGS.  If ADDR
+   is nonzero, it is the desired mapping address.  If the MAP_FIXED bit is
+   set in FLAGS, the mapping will be at ADDR exactly (which must be
+   page-aligned); otherwise the system chooses a convenient nearby address.
+   The return value is the actual mapping address chosen or MAP_FAILED
+   for errors (in which case `errno' is set).  A successful `mmap' call
+   deallocates any previous mapping for the affected region.  */
+
+#ifndef __USE_FILE_OFFSET64
+extern void *mmap (void *__addr, size_t __len, int __prot,
+		   int __flags, int __fd, __off_t __offset) __THROW;
+#else
+# ifdef __REDIRECT
+extern void * __REDIRECT (mmap,
+			  (void *__addr, size_t __len, int __prot,
+			   int __flags, int __fd, __off64_t __offset) __THROW,
+			  mmap64);
+# else
+#  define mmap mmap64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern void *mmap64 (void *__addr, size_t __len, int __prot,
+		     int __flags, int __fd, __off64_t __offset) __THROW;
+#endif
+
+/* Deallocate any mapping for the region starting at ADDR and extending LEN
+   bytes.  Returns 0 if successful, -1 for errors (and sets errno).  */
+extern int munmap (void *__addr, size_t __len) __THROW;
+
+/* Change the memory protection of the region starting at ADDR and
+   extending LEN bytes to PROT.  Returns 0 if successful, -1 for errors
+   (and sets errno).  */
+extern int mprotect (void *__addr, size_t __len, int __prot) __THROW;
+
+/* Synchronize the region starting at ADDR and extending LEN bytes with the
+   file it maps.  Filesystem operations on a file being mapped are
+   unpredictable before this is done.  Flags are from the MS_* set.  */
+extern int msync (void *__addr, size_t __len, int __flags) __THROW;
+
+#ifdef __USE_BSD
+/* Advise the system about particular usage patterns the program follows
+   for the region starting at ADDR and extending LEN bytes.  */
+extern int madvise (void *__addr, size_t __len, int __advice) __THROW;
+#endif
+#ifdef __USE_XOPEN2K
+/* This is the POSIX name for this function.  */
+extern int posix_madvise (void *__addr, size_t __len, int __advice) __THROW;
+#endif
+
+/* Guarantee all whole pages mapped by the range [ADDR,ADDR+LEN) to
+   be memory resident.  */
+extern int mlock (__const void *__addr, size_t __len) __THROW;
+
+/* Unlock whole pages previously mapped by the range [ADDR,ADDR+LEN).  */
+extern int munlock (__const void *__addr, size_t __len) __THROW;
+
+/* Cause all currently mapped pages of the process to be memory resident
+   until unlocked by a call to the `munlockall', until the process exits,
+   or until the process calls `execve'.  */
+extern int mlockall (int __flags) __THROW;
+
+/* All currently mapped pages of the process' address space become
+   unlocked.  */
+extern int munlockall (void) __THROW;
+
+#ifdef __USE_MISC
+/* Remap pages mapped by the range [ADDR,ADDR+OLD_LEN) to new length
+   NEW_LEN.  If MAY_MOVE is MREMAP_MAYMOVE the returned address may
+   differ from ADDR.  */
+extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
+		     int __may_move) __THROW;
+
+/* mincore returns the memory residency status of the pages in the
+   current process's address space specified by [start, start + len).
+   The status is returned in a vector of bytes.  The least significant
+   bit of each byte is 1 if the referenced page is in memory, otherwise
+   it is zero.  */
+extern int mincore (void *__start, size_t __len, unsigned char *__vec);
+#endif
+
+
+/* Open shared memory segment.  */
+extern int shm_open (__const char *__name, int __oflag, mode_t __mode);
+
+/* Remove shared memory segment.  */
+extern int shm_unlink (__const char *__name);
+
+__END_DECLS
+
+#endif	/* sys/mman.h */
diff -pruwN busybox-1.01/include2/sys/param.h busybox-1.01-livebox/include2/sys/param.h
--- busybox-1.01/include2/sys/param.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/param.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,66 @@
+/* Copyright (C) 1995, 1996, 1997, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PARAM_H
+#define _SYS_PARAM_H	1
+
+#include <limits.h>
+#include <linux/limits.h>
+#include <linux/param.h>
+
+/* BSD names for some <limits.h> values.  */
+
+#define	NBBY		CHAR_BIT
+#ifndef	NGROUPS
+# define NGROUPS	NGROUPS_MAX
+#endif
+#define	MAXSYMLINKS	20
+#define	CANBSIZ		MAX_CANON
+#define	NCARGS		ARG_MAX
+#define MAXPATHLEN	PATH_MAX
+/* The following is not really correct but it is a value we used for a
+   long time and which seems to be usable.  People should not use NOFILE
+   anyway.  */
+#define NOFILE		256
+
+
+#include <sys/types.h>
+
+/* Bit map related macros.  */
+#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+
+/* Macros for counting and rounding.  */
+#ifndef howmany
+# define howmany(x, y)	(((x)+((y)-1))/(y))
+#endif
+#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))
+#define powerof2(x)	((((x)-1)&(x))==0)
+
+/* Macros for min/max.  */
+#define	MIN(a,b) (((a)<(b))?(a):(b))
+#define	MAX(a,b) (((a)>(b))?(a):(b))
+
+
+/* Unit of `st_blocks'.  */
+#define DEV_BSIZE       512
+
+
+#endif	/* sys/param.h */
diff -pruwN busybox-1.01/include2/sys/resource.h busybox-1.01-livebox/include2/sys/resource.h
--- busybox-1.01/include2/sys/resource.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/resource.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,104 @@
+/* Copyright (C) 1992,94,96,97,98,99,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_RESOURCE_H
+#define	_SYS_RESOURCE_H	1
+
+#include <features.h>
+
+/* Get the system-dependent definitions of structures and bit values.  */
+#include <bits/resource.h>
+
+#ifndef __id_t_defined
+typedef __id_t id_t;
+# define __id_t_defined
+#endif
+
+__BEGIN_DECLS
+
+/* The X/Open standard defines that all the functions below must use
+   `int' as the type for the first argument.  When we are compiling with
+   GNU extensions we change this slightly to provide better error
+   checking.  */
+#if defined __USE_GNU && !defined __cplusplus
+typedef enum __rlimit_resource __rlimit_resource_t;
+typedef enum __rusage_who __rusage_who_t;
+typedef enum __priority_which __priority_which_t;
+#else
+typedef int __rlimit_resource_t;
+typedef int __rusage_who_t;
+typedef int __priority_which_t;
+#endif
+
+/* Put the soft and hard limits for RESOURCE in *RLIMITS.
+   Returns 0 if successful, -1 if not (and sets errno).  */
+#ifndef __USE_FILE_OFFSET64
+extern int getrlimit (__rlimit_resource_t __resource,
+		      struct rlimit *__rlimits) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (getrlimit, (__rlimit_resource_t __resource,
+				   struct rlimit *__rlimits) __THROW,
+		       getrlimit64);
+# else
+#  define getrlimit getrlimit64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int getrlimit64 (__rlimit_resource_t __resource,
+			struct rlimit64 *__rlimits) __THROW;
+#endif
+
+/* Set the soft and hard limits for RESOURCE to *RLIMITS.
+   Only the super-user can increase hard limits.
+   Return 0 if successful, -1 if not (and sets errno).  */
+#ifndef __USE_FILE_OFFSET64
+extern int setrlimit (__rlimit_resource_t __resource,
+		      __const struct rlimit *__rlimits) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (setrlimit, (__rlimit_resource_t __resource,
+				   __const struct rlimit *__rlimits) __THROW,
+		       setrlimit64);
+# else
+#  define setrlimit setrlimit64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int setrlimit64 (__rlimit_resource_t __resource,
+			__const struct rlimit64 *__rlimits) __THROW;
+#endif
+
+/* Return resource usage information on process indicated by WHO
+   and put it in *USAGE.  Returns 0 for success, -1 for failure.  */
+extern int getrusage (__rusage_who_t __who, struct rusage *__usage) __THROW;
+
+/* Return the highest priority of any process specified by WHICH and WHO
+   (see above); if WHO is zero, the current process, process group, or user
+   (as specified by WHO) is used.  A lower priority number means higher
+   priority.  Priorities range from PRIO_MIN to PRIO_MAX (above).  */
+extern int getpriority (__priority_which_t __which, id_t __who) __THROW;
+
+/* Set the priority of all processes specified by WHICH and WHO (see above)
+   to PRIO.  Returns 0 on success, -1 on errors.  */
+extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
+     __THROW;
+
+__END_DECLS
+
+#endif	/* sys/resource.h  */
diff -pruwN busybox-1.01/include2/sys/select.h busybox-1.01-livebox/include2/sys/select.h
--- busybox-1.01/include2/sys/select.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/select.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,114 @@
+/* `fd_set' type and related macros, and `select'/`pselect' declarations.
+   Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */
+
+#ifndef _SYS_SELECT_H
+#define _SYS_SELECT_H	1
+
+#include <features.h>
+
+/* Get definition of needed basic types.  */
+#include <bits/types.h>
+
+/* Get __FD_* definitions.  */
+#include <bits/select.h>
+
+/* Get __sigset_t.  */
+#include <bits/sigset.h>
+
+#ifndef __sigset_t_defined
+# define __sigset_t_defined
+typedef __sigset_t sigset_t;
+#endif
+
+/* Get definition of timer specification structures.  */
+#define __need_timespec
+#include <time.h>
+#define __need_timeval
+#include <bits/time.h>
+
+
+/* The fd_set member is required to be an array of longs.  */
+typedef long int __fd_mask;
+
+/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */
+#define __NFDBITS	(8 * sizeof (__fd_mask))
+#define	__FDELT(d)	((d) / __NFDBITS)
+#define	__FDMASK(d)	((__fd_mask) 1 << ((d) % __NFDBITS))
+
+/* fd_set for select and pselect.  */
+typedef struct
+  {
+    /* XPG4.2 requires this member name.  Otherwise avoid the name
+       from the global namespace.  */
+#ifdef __USE_XOPEN
+    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
+# define __FDS_BITS(set) ((set)->fds_bits)
+#else
+    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
+# define __FDS_BITS(set) ((set)->__fds_bits)
+#endif
+  } fd_set;
+
+/* Maximum number of file descriptors in `fd_set'.  */
+#define	FD_SETSIZE		__FD_SETSIZE
+
+#ifdef __USE_MISC
+/* Sometimes the fd_set member is assumed to have this type.  */
+typedef __fd_mask fd_mask;
+
+/* Number of bits per word of `fd_set' (some code assumes this is 32).  */
+# define NFDBITS		__NFDBITS
+#endif
+
+
+/* Access macros for `fd_set'.  */
+#define	FD_SET(fd, fdsetp)	__FD_SET (fd, fdsetp)
+#define	FD_CLR(fd, fdsetp)	__FD_CLR (fd, fdsetp)
+#define	FD_ISSET(fd, fdsetp)	__FD_ISSET (fd, fdsetp)
+#define	FD_ZERO(fdsetp)		__FD_ZERO (fdsetp)
+
+
+__BEGIN_DECLS
+
+/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
+   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
+   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
+   after waiting the interval specified therein.  Returns the number of ready
+   descriptors, or -1 for errors.  */
+extern int select (int __nfds, fd_set *__restrict __readfds,
+		   fd_set *__restrict __writefds,
+		   fd_set *__restrict __exceptfds,
+		   struct timeval *__restrict __timeout) __THROW;
+
+#ifdef __USE_XOPEN2K
+/* Same as above only that the TIMEOUT value is given with higher
+   resolution and a sigmask which is been set temporarily.  This version
+   should be used.  */
+extern int pselect (int __nfds, fd_set *__restrict __readfds,
+		    fd_set *__restrict __writefds,
+		    fd_set *__restrict __exceptfds,
+		    const struct timespec *__restrict __timeout,
+		    const __sigset_t *__restrict __sigmask) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* sys/select.h */
diff -pruwN busybox-1.01/include2/sys/signal.h busybox-1.01-livebox/include2/sys/signal.h
--- busybox-1.01/include2/sys/signal.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/signal.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1 @@
+#include <signal.h>
diff -pruwN busybox-1.01/include2/sys/socket.h busybox-1.01-livebox/include2/sys/socket.h
--- busybox-1.01/include2/sys/socket.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/socket.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,217 @@
+/* Declarations of socket constants, types, and functions.
+   Copyright (C) 1991,92,1994-1999,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_SOCKET_H
+#define	_SYS_SOCKET_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <sys/uio.h>
+#define	__need_size_t
+#include <stddef.h>
+
+
+/* This operating system-specific header file defines the SOCK_*, PF_*,
+   AF_*, MSG_*, SOL_*, and SO_* constants, and the `struct sockaddr',
+   `struct msghdr', and `struct linger' types.  */
+#include <bits/socket.h>
+
+#ifdef __USE_BSD
+/* This is the 4.3 BSD `struct sockaddr' format, which is used as wire
+   format in the grotty old 4.3 `talk' protocol.  */
+struct osockaddr
+  {
+    unsigned short int sa_family;
+    unsigned char sa_data[14];
+  };
+#endif
+
+/* The following constants should be used for the second parameter of
+   `shutdown'.  */
+enum
+{
+  SHUT_RD = 0,		/* No more receptions.  */
+#define SHUT_RD		SHUT_RD
+  SHUT_WR,		/* No more transmissions.  */
+#define SHUT_WR		SHUT_WR
+  SHUT_RDWR		/* No more receptions or transmissions.  */
+#define SHUT_RDWR	SHUT_RDWR
+};
+
+/* This is the type we use for generic socket address arguments.
+
+   With GCC 2.7 and later, the funky union causes redeclarations or
+   uses with any of the listed types to be allowed without complaint.
+   G++ 2.7 does not support transparent unions so there we want the
+   old-style declaration, too.  */
+#if defined __cplusplus || !__GNUC_PREREQ (2, 7) || !defined __USE_GNU
+# define __SOCKADDR_ARG		struct sockaddr *__restrict
+# define __CONST_SOCKADDR_ARG	__const struct sockaddr *
+#else
+/* Add more `struct sockaddr_AF' types here as necessary.
+   These are all the ones I found on NetBSD and Linux.  */
+# define __SOCKADDR_ALLTYPES \
+  __SOCKADDR_ONETYPE (sockaddr) \
+  __SOCKADDR_ONETYPE (sockaddr_at) \
+  __SOCKADDR_ONETYPE (sockaddr_ax25) \
+  __SOCKADDR_ONETYPE (sockaddr_dl) \
+  __SOCKADDR_ONETYPE (sockaddr_eon) \
+  __SOCKADDR_ONETYPE (sockaddr_in) \
+  __SOCKADDR_ONETYPE (sockaddr_in6) \
+  __SOCKADDR_ONETYPE (sockaddr_inarp) \
+  __SOCKADDR_ONETYPE (sockaddr_ipx) \
+  __SOCKADDR_ONETYPE (sockaddr_iso) \
+  __SOCKADDR_ONETYPE (sockaddr_ns) \
+  __SOCKADDR_ONETYPE (sockaddr_un) \
+  __SOCKADDR_ONETYPE (sockaddr_x25)
+
+# define __SOCKADDR_ONETYPE(type) struct type *__restrict __##type##__;
+typedef union { __SOCKADDR_ALLTYPES
+	      } __SOCKADDR_ARG __attribute__ ((__transparent_union__));
+# undef __SOCKADDR_ONETYPE
+# define __SOCKADDR_ONETYPE(type) __const struct type *__restrict __##type##__;
+typedef union { __SOCKADDR_ALLTYPES
+	      } __CONST_SOCKADDR_ARG __attribute__ ((__transparent_union__));
+# undef __SOCKADDR_ONETYPE
+#endif
+
+
+/* Create a new socket of type TYPE in domain DOMAIN, using
+   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
+   Returns a file descriptor for the new socket, or -1 for errors.  */
+extern int socket (int __domain, int __type, int __protocol) __THROW;
+
+/* Create two new sockets, of type TYPE in domain DOMAIN and using
+   protocol PROTOCOL, which are connected to each other, and put file
+   descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,
+   one will be chosen automatically.  Returns 0 on success, -1 for errors.  */
+extern int socketpair (int __domain, int __type, int __protocol,
+		       int __fds[2]) __THROW;
+
+/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
+extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
+     __THROW;
+
+/* Put the local address of FD into *ADDR and its length in *LEN.  */
+extern int getsockname (int __fd, __SOCKADDR_ARG __addr,
+			socklen_t *__restrict __len) __THROW;
+
+/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
+   For connectionless socket types, just set the default address to send to
+   and the only address from which to accept transmissions.
+   Return 0 on success, -1 for errors.  */
+extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
+     __THROW;
+
+/* Put the address of the peer connected to socket FD into *ADDR
+   (which is *LEN bytes long), and its actual length into *LEN.  */
+extern int getpeername (int __fd, __SOCKADDR_ARG __addr,
+			socklen_t *__restrict __len) __THROW;
+
+
+/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.  */
+extern ssize_t send (int __fd, __const void *__buf, size_t __n, int __flags)
+     __THROW;
+
+/* Read N bytes into BUF from socket FD.
+   Returns the number read or -1 for errors.  */
+extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags)
+     __THROW;
+
+/* Send N bytes of BUF on socket FD to peer at address ADDR (which is
+   ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.  */
+extern ssize_t sendto (int __fd, __const void *__buf, size_t __n,
+		       int __flags, __CONST_SOCKADDR_ARG __addr,
+		       socklen_t __addr_len) __THROW;
+
+/* Read N bytes into BUF through socket FD.
+   If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of
+   the sender, and store the actual size of the address in *ADDR_LEN.
+   Returns the number of bytes read or -1 for errors.  */
+extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n, int __flags,
+			 __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len)
+     __THROW;
+
+
+/* Send a message described MESSAGE on socket FD.
+   Returns the number of bytes sent, or -1 for errors.  */
+extern ssize_t sendmsg (int __fd, __const struct msghdr *__message, int __flags)
+     __THROW;
+
+/* Receive a message as described by MESSAGE from socket FD.
+   Returns the number of bytes read or -1 for errors.  */
+extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags)
+     __THROW;
+
+
+/* Put the current value for socket FD's option OPTNAME at protocol level LEVEL
+   into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's
+   actual length.  Returns 0 on success, -1 for errors.  */
+extern int getsockopt (int __fd, int __level, int __optname,
+		       void *__restrict __optval,
+		       socklen_t *__restrict __optlen) __THROW;
+
+/* Set socket FD's option OPTNAME at protocol level LEVEL
+   to *OPTVAL (which is OPTLEN bytes long).
+   Returns 0 on success, -1 for errors.  */
+extern int setsockopt (int __fd, int __level, int __optname,
+		       __const void *__optval, socklen_t __optlen) __THROW;
+
+
+/* Prepare to accept connections on socket FD.
+   N connection requests will be queued before further requests are refused.
+   Returns 0 on success, -1 for errors.  */
+extern int listen (int __fd, int __n) __THROW;
+
+/* Await a connection on socket FD.
+   When a connection arrives, open a new socket to communicate with it,
+   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting
+   peer and *ADDR_LEN to the address's actual length, and return the
+   new socket's descriptor, or -1 for errors.  */
+extern int accept (int __fd, __SOCKADDR_ARG __addr,
+		   socklen_t *__restrict __addr_len)
+     __THROW;
+
+/* Shut down all or part of the connection open on socket FD.
+   HOW determines what to shut down:
+     SHUT_RD   = No more receptions;
+     SHUT_WR   = No more transmissions;
+     SHUT_RDWR = No more receptions or transmissions.
+   Returns 0 on success, -1 for errors.  */
+extern int shutdown (int __fd, int __how) __THROW;
+
+
+#ifdef __USE_XOPEN2K
+/* Determine wheter socket is at a out-of-band mark.  */
+extern int sockatmark (int __fd) __THROW;
+#endif
+
+
+#ifdef __USE_MISC
+/* FDTYPE is S_IFSOCK or another S_IF* macro defined in <sys/stat.h>;
+   returns 1 if FD is open on an object of the indicated type, 0 if not,
+   or -1 for errors (setting errno).  */
+extern int isfdtype (int __fd, int __fdtype) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* sys/socket.h */
diff -pruwN busybox-1.01/include2/sys/statfs.h busybox-1.01-livebox/include2/sys/statfs.h
--- busybox-1.01/include2/sys/statfs.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/statfs.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,64 @@
+/* Definitions for getting information about a filesystem.
+   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_STATFS_H
+#define	_SYS_STATFS_H	1
+
+#include <features.h>
+
+/* Get the system-specific definition of `struct statfs'.  */
+#include <bits/statfs.h>
+
+__BEGIN_DECLS
+
+/* Return information about the filesystem on which FILE resides.  */
+#ifndef __USE_FILE_OFFSET64
+extern int statfs (__const char *__file, struct statfs *__buf) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (statfs,
+		       (__const char *__file, struct statfs *__buf) __THROW,
+		       statfs64);
+# else
+#  define statfs statfs64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int statfs64 (__const char *__file, struct statfs64 *__buf) __THROW;
+#endif
+
+/* Return information about the filesystem containing the file FILDES
+   refers to.  */
+#ifndef __USE_FILE_OFFSET64
+extern int fstatfs (int __fildes, struct statfs *__buf) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (fstatfs, (int __fildes, struct statfs *__buf) __THROW,
+		       fstatfs64);
+# else
+#  define fstatfs fstatfs64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int fstatfs64 (int __fildes, struct statfs64 *__buf) __THROW;
+#endif
+
+__END_DECLS
+
+#endif	/* sys/statfs.h */
diff -pruwN busybox-1.01/include2/sys/stat.h busybox-1.01-livebox/include2/sys/stat.h
--- busybox-1.01/include2/sys/stat.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/stat.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,284 @@
+/* Copyright (C) 1991, 92, 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 5.6 File Characteristics	<sys/stat.h>
+ */
+
+#ifndef	_SYS_STAT_H
+#define	_SYS_STAT_H	1
+
+#include <features.h>
+
+#include <bits/types.h>		/* For __mode_t and __dev_t.  */
+
+#ifdef __USE_XOPEN
+# define __need_time_t
+# include <time.h>		/* For time_t.  */
+
+/* The Single Unix specification says that some more types are
+   available here.  */
+# ifndef __dev_t_defined
+typedef __dev_t dev_t;
+#  define __dev_t_defined
+# endif
+
+# ifndef __gid_t_defined
+typedef __gid_t gid_t;
+#  define __gid_t_defined
+# endif
+
+# ifndef __ino_t_defined
+#  ifndef __USE_FILE_OFFSET64
+typedef __ino_t ino_t;
+#  else
+typedef __ino64_t ino_t;
+#  endif
+#  define __ino_t_defined
+# endif
+
+# ifndef __mode_t_defined
+typedef __mode_t mode_t;
+#  define __mode_t_defined
+# endif
+
+# ifndef __nlink_t_defined
+typedef __nlink_t nlink_t;
+#  define __nlink_t_defined
+# endif
+
+# ifndef __off_t_defined
+#  ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+#  else
+typedef __off64_t off_t;
+#  endif
+#  define __off_t_defined
+# endif
+
+# ifndef __uid_t_defined
+typedef __uid_t uid_t;
+#  define __uid_t_defined
+# endif
+#endif	/* X/Open */
+
+#ifdef __USE_UNIX98
+# ifndef __blkcnt_t_defined
+#  ifndef __USE_FILE_OFFSET64
+typedef __blkcnt_t blkcnt_t;
+#  else
+typedef __blkcnt64_t blkcnt_t;
+#  endif
+#  define __blkcnt_t_defined
+# endif
+
+# ifndef __blksize_t_defined
+typedef __blksize_t blksize_t;
+#  define __blksize_t_defined
+# endif
+#endif	/* Unix98 */
+
+__BEGIN_DECLS
+
+#include <bits/stat.h>
+
+#if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN
+# define S_IFMT		__S_IFMT
+# define S_IFDIR	__S_IFDIR
+# define S_IFCHR	__S_IFCHR
+# define S_IFBLK	__S_IFBLK
+# define S_IFREG	__S_IFREG
+# ifdef __S_IFIFO
+#  define S_IFIFO	__S_IFIFO
+# endif
+# ifdef __S_IFLNK
+#  define S_IFLNK	__S_IFLNK
+# endif
+# if (defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN2K) \
+     && defined __S_IFSOCK
+#  define S_IFSOCK	__S_IFSOCK
+# endif
+#endif
+
+/* Test macros for file types.	*/
+
+#define	__S_ISTYPE(mode, mask)	(((mode) & __S_IFMT) == (mask))
+
+#define	S_ISDIR(mode)	 __S_ISTYPE((mode), __S_IFDIR)
+#define	S_ISCHR(mode)	 __S_ISTYPE((mode), __S_IFCHR)
+#define	S_ISBLK(mode)	 __S_ISTYPE((mode), __S_IFBLK)
+#define	S_ISREG(mode)	 __S_ISTYPE((mode), __S_IFREG)
+#ifdef __S_IFIFO
+# define S_ISFIFO(mode)	 __S_ISTYPE((mode), __S_IFIFO)
+#endif
+#ifdef __S_IFLNK
+# define S_ISLNK(mode)	 __S_ISTYPE((mode), __S_IFLNK)
+#endif
+
+#ifdef	__USE_BSD
+# ifndef __S_IFLNK
+#  define S_ISLNK(mode)  0
+# endif
+# ifdef __S_IFSOCK
+#  define S_ISSOCK(mode) __S_ISTYPE((mode), __S_IFSOCK)
+# endif
+#endif
+
+/* These are from POSIX.1b.  If the objects are not implemented using separate
+   distinct file types, the macros always will evaluate to zero.  Unlike the
+   other S_* macros the following three take a pointer to a `struct stat'
+   object as the argument.  */
+#ifdef	__USE_POSIX199309
+# define S_TYPEISMQ(buf) __S_TYPEISMQ(buf)
+# define S_TYPEISSEM(buf) __S_TYPEISSEM(buf)
+# define S_TYPEISSHM(buf) __S_TYPEISSHM(buf)
+#endif
+
+
+/* Protection bits.  */
+
+#define	S_ISUID __S_ISUID	/* Set user ID on execution.  */
+#define	S_ISGID	__S_ISGID	/* Set group ID on execution.  */
+
+#if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN
+/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */
+# define S_ISVTX	__S_ISVTX
+#endif
+
+#define	S_IRUSR	__S_IREAD	/* Read by owner.  */
+#define	S_IWUSR	__S_IWRITE	/* Write by owner.  */
+#define	S_IXUSR	__S_IEXEC	/* Execute by owner.  */
+/* Read, write, and execute by owner.  */
+#define	S_IRWXU	(__S_IREAD|__S_IWRITE|__S_IEXEC)
+
+#if defined __USE_MISC && defined __USE_BSD
+# define S_IREAD	S_IRUSR
+# define S_IWRITE	S_IWUSR
+# define S_IEXEC	S_IXUSR
+#endif
+
+#define	S_IRGRP	(S_IRUSR >> 3)	/* Read by group.  */
+#define	S_IWGRP	(S_IWUSR >> 3)	/* Write by group.  */
+#define	S_IXGRP	(S_IXUSR >> 3)	/* Execute by group.  */
+/* Read, write, and execute by group.  */
+#define	S_IRWXG	(S_IRWXU >> 3)
+
+#define	S_IROTH	(S_IRGRP >> 3)	/* Read by others.  */
+#define	S_IWOTH	(S_IWGRP >> 3)	/* Write by others.  */
+#define	S_IXOTH	(S_IXGRP >> 3)	/* Execute by others.  */
+/* Read, write, and execute by others.  */
+#define	S_IRWXO	(S_IRWXG >> 3)
+
+
+#ifdef	__USE_BSD
+/* Macros for common mode bit masks.  */
+# define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO) /* 0777 */
+# define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)/* 07777 */
+# define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)/* 0666*/
+
+# define S_BLKSIZE	512	/* Block size for `st_blocks'.  */
+#endif
+
+
+#ifndef __USE_FILE_OFFSET64
+/* Get file attributes for FILE and put them in BUF.  */
+extern int stat (__const char *__restrict __file,
+		 struct stat *__restrict __buf) __THROW;
+
+/* Get file attributes for the file, device, pipe, or socket
+   that file descriptor FD is open on and put them in BUF.  */
+extern int fstat (int __fd, struct stat *__buf) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (stat,
+		       (__const char *__restrict __file,
+			struct stat *__restrict __buf) __THROW,
+		       stat64);
+extern int __REDIRECT (fstat, (int __fd, struct stat *__buf) __THROW, fstat64);
+# else
+#  define stat stat64
+#  define fstat fstat64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int stat64 (__const char *__restrict __file,
+		   struct stat64 *__restrict __buf) __THROW;
+extern int fstat64 (int __fd, struct stat64 *__buf) __THROW;
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+# ifndef __USE_FILE_OFFSET64
+/* Get file attributes about FILE and put them in BUF.
+   If FILE is a symbolic link, do not follow it.  */
+extern int lstat (__const char *__restrict __file,
+		  struct stat *__restrict __buf) __THROW;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (lstat,
+		       (__const char *__restrict __file,
+			struct stat *__restrict __buf) __THROW,
+		       lstat64);
+#  else
+#   define lstat lstat64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int lstat64 (__const char *__restrict __file,
+		    struct stat64 *__restrict __buf) __THROW;
+# endif
+#endif
+
+/* Set file access permissions for FILE to MODE.
+   This takes an `int' MODE argument because that
+   is what `mode_t's get widened to.  */
+extern int chmod (__const char *__file, __mode_t __mode) __THROW;
+
+/* Set file access permissions of the file FD is open on to MODE.  */
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+extern int fchmod (int __fd, __mode_t __mode) __THROW;
+#endif
+
+
+/* Set the file creation mask of the current process to MASK,
+   and return the old creation mask.  */
+extern __mode_t umask (__mode_t __mask) __THROW;
+
+#ifdef	__USE_GNU
+/* Get the current `umask' value without changing it.
+   This function is only available under the GNU Hurd.  */
+extern __mode_t getumask (void) __THROW;
+#endif
+
+/* Create a new directory named PATH, with permission bits MODE.  */
+extern int mkdir (__const char *__path, __mode_t __mode) __THROW;
+
+/* Create a device file named PATH, with permission and special bits MODE
+   and device number DEV (which can be constructed from major and minor
+   device numbers with the `makedev' macro above).  */
+#if defined __USE_MISC || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
+     __THROW;
+#endif
+
+/* Create a new FIFO named PATH, with permission bits MODE.  */
+extern int mkfifo (__const char *__path, __mode_t __mode) __THROW;
+
+__END_DECLS
+
+
+#endif /* sys/stat.h  */
diff -pruwN busybox-1.01/include2/sys/syscall.h busybox-1.01-livebox/include2/sys/syscall.h
--- busybox-1.01/include2/sys/syscall.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/syscall.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,25 @@
+/* Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _SYSCALL_H
+#define _SYSCALL_H	1
+
+/* This file provides us with the nicely useful _syscall[0-5] macros. */
+#include <bits/syscalls.h>
+
+#endif
diff -pruwN busybox-1.01/include2/sys/syslog.h busybox-1.01-livebox/include2/sys/syslog.h
--- busybox-1.01/include2/sys/syslog.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/syslog.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,193 @@
+/*
+ * Copyright (c) 1982, 1986, 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)syslog.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _SYS_SYSLOG_H
+#define _SYS_SYSLOG_H 1
+
+#include <features.h>
+#define __need___va_list
+#include <stdarg.h>
+
+
+#define	_PATH_LOG	"/dev/log"
+
+/*
+ * priorities/facilities are encoded into a single 32-bit quantity, where the
+ * bottom 3 bits are the priority (0-7) and the top 28 bits are the facility
+ * (0-big number).  Both the priorities and the facilities map roughly
+ * one-to-one to strings in the syslogd(8) source code.  This mapping is
+ * included in this file.
+ *
+ * priorities (these are ordered)
+ */
+#define	LOG_EMERG	0	/* system is unusable */
+#define	LOG_ALERT	1	/* action must be taken immediately */
+#define	LOG_CRIT	2	/* critical conditions */
+#define	LOG_ERR		3	/* error conditions */
+#define	LOG_WARNING	4	/* warning conditions */
+#define	LOG_NOTICE	5	/* normal but significant condition */
+#define	LOG_INFO	6	/* informational */
+#define	LOG_DEBUG	7	/* debug-level messages */
+
+#define	LOG_PRIMASK	0x07	/* mask to extract priority part (internal) */
+				/* extract priority */
+#define	LOG_PRI(p)	((p) & LOG_PRIMASK)
+#define	LOG_MAKEPRI(fac, pri)	(((fac) << 3) | (pri))
+
+#ifdef SYSLOG_NAMES
+#define	INTERNAL_NOPRI	0x10	/* the "no priority" priority */
+				/* mark "facility" */
+#define	INTERNAL_MARK	LOG_MAKEPRI(LOG_NFACILITIES, 0)
+typedef struct _code {
+	char	*c_name;
+	int	c_val;
+} CODE;
+
+CODE prioritynames[] =
+  {
+    { "alert", LOG_ALERT },
+    { "crit", LOG_CRIT },
+    { "debug", LOG_DEBUG },
+    { "emerg", LOG_EMERG },
+    { "err", LOG_ERR },
+    { "error", LOG_ERR },		/* DEPRECATED */
+    { "info", LOG_INFO },
+    { "none", INTERNAL_NOPRI },		/* INTERNAL */
+    { "notice", LOG_NOTICE },
+    { "panic", LOG_EMERG },		/* DEPRECATED */
+    { "warn", LOG_WARNING },		/* DEPRECATED */
+    { "warning", LOG_WARNING },
+    { NULL, -1 }
+  };
+#endif
+
+/* facility codes */
+#define	LOG_KERN	(0<<3)	/* kernel messages */
+#define	LOG_USER	(1<<3)	/* random user-level messages */
+#define	LOG_MAIL	(2<<3)	/* mail system */
+#define	LOG_DAEMON	(3<<3)	/* system daemons */
+#define	LOG_AUTH	(4<<3)	/* security/authorization messages */
+#define	LOG_SYSLOG	(5<<3)	/* messages generated internally by syslogd */
+#define	LOG_LPR		(6<<3)	/* line printer subsystem */
+#define	LOG_NEWS	(7<<3)	/* network news subsystem */
+#define	LOG_UUCP	(8<<3)	/* UUCP subsystem */
+#define	LOG_CRON	(9<<3)	/* clock daemon */
+#define	LOG_AUTHPRIV	(10<<3)	/* security/authorization messages (private) */
+#define	LOG_FTP		(11<<3)	/* ftp daemon */
+
+	/* other codes through 15 reserved for system use */
+#define	LOG_LOCAL0	(16<<3)	/* reserved for local use */
+#define	LOG_LOCAL1	(17<<3)	/* reserved for local use */
+#define	LOG_LOCAL2	(18<<3)	/* reserved for local use */
+#define	LOG_LOCAL3	(19<<3)	/* reserved for local use */
+#define	LOG_LOCAL4	(20<<3)	/* reserved for local use */
+#define	LOG_LOCAL5	(21<<3)	/* reserved for local use */
+#define	LOG_LOCAL6	(22<<3)	/* reserved for local use */
+#define	LOG_LOCAL7	(23<<3)	/* reserved for local use */
+
+#define	LOG_NFACILITIES	24	/* current number of facilities */
+#define	LOG_FACMASK	0x03f8	/* mask to extract facility part */
+				/* facility of pri */
+#define	LOG_FAC(p)	(((p) & LOG_FACMASK) >> 3)
+
+#ifdef SYSLOG_NAMES
+CODE facilitynames[] =
+  {
+    { "auth", LOG_AUTH },
+    { "authpriv", LOG_AUTHPRIV },
+    { "cron", LOG_CRON },
+    { "daemon", LOG_DAEMON },
+    { "ftp", LOG_FTP },
+    { "kern", LOG_KERN },
+    { "lpr", LOG_LPR },
+    { "mail", LOG_MAIL },
+    { "mark", INTERNAL_MARK },		/* INTERNAL */
+    { "news", LOG_NEWS },
+    { "security", LOG_AUTH },		/* DEPRECATED */
+    { "syslog", LOG_SYSLOG },
+    { "user", LOG_USER },
+    { "uucp", LOG_UUCP },
+    { "local0", LOG_LOCAL0 },
+    { "local1", LOG_LOCAL1 },
+    { "local2", LOG_LOCAL2 },
+    { "local3", LOG_LOCAL3 },
+    { "local4", LOG_LOCAL4 },
+    { "local5", LOG_LOCAL5 },
+    { "local6", LOG_LOCAL6 },
+    { "local7", LOG_LOCAL7 },
+    { NULL, -1 }
+  };
+#endif
+
+/*
+ * arguments to setlogmask.
+ */
+#define	LOG_MASK(pri)	(1 << (pri))		/* mask for one priority */
+#define	LOG_UPTO(pri)	((1 << ((pri)+1)) - 1)	/* all priorities through pri */
+
+/*
+ * Option flags for openlog.
+ *
+ * LOG_ODELAY no longer does anything.
+ * LOG_NDELAY is the inverse of what it used to be.
+ */
+#define	LOG_PID		0x01	/* log the pid with each message */
+#define	LOG_CONS	0x02	/* log on the console if errors in sending */
+#define	LOG_ODELAY	0x04	/* delay open until first syslog() (default) */
+#define	LOG_NDELAY	0x08	/* don't delay open */
+#define	LOG_NOWAIT	0x10	/* don't wait for console forks: DEPRECATED */
+#define	LOG_PERROR	0x20	/* log to stderr as well */
+
+__BEGIN_DECLS
+
+/* Close desriptor used to write to system logger.  */
+extern void closelog (void) __THROW;
+
+/* Open connection to system logger.  */
+extern void openlog (__const char *__ident, int __option, int __facility)
+     __THROW;
+
+/* Set the log mask level.  */
+extern int setlogmask (int __mask) __THROW;
+
+/* Generate a log message using FMT string and option arguments.  */
+extern void syslog (int __pri, __const char *__fmt, ...) __THROW
+     __attribute__ ((__format__(__printf__, 2, 3)));
+
+#ifdef __USE_BSD
+/* Generate a log message using FMT and using arguments pointed to by AP.  */
+extern void vsyslog (int __pri, __const char *__fmt, __gnuc_va_list __ap)
+     __THROW __attribute__ ((__format__(__printf__, 2, 0)));
+#endif
+
+__END_DECLS
+
+#endif /* sys/syslog.h */
diff -pruwN busybox-1.01/include2/sys/sysmacros.h busybox-1.01-livebox/include2/sys/sysmacros.h
--- busybox-1.01/include2/sys/sysmacros.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/sysmacros.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,69 @@
+/* Definitions of macros to access `dev_t' values.
+   Copyright (C) 1996, 1997, 1999, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H	1
+
+#include <features.h>
+
+/* If the compiler does not know long long it is out of luck.  We are
+   not going to hack weird hacks to support the dev_t representation
+   they need.  */
+#if 1 /*def __GLIBC_HAVE_LONG_LONG    uClibc note: always enable */
+__extension__
+static __inline unsigned int gnu_dev_major (unsigned long long int __dev)
+     __THROW;
+__extension__
+static __inline unsigned int gnu_dev_minor (unsigned long long int __dev)
+     __THROW;
+__extension__
+static __inline unsigned long long int gnu_dev_makedev (unsigned int __major,
+							unsigned int __minor)
+     __THROW;
+
+# if defined __GNUC__ && __GNUC__ >= 2
+__extension__ static __inline unsigned int
+__NTH (gnu_dev_major (unsigned long long int __dev))
+{
+  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
+}
+
+__extension__ static __inline unsigned int
+__NTH (gnu_dev_minor (unsigned long long int __dev))
+{
+  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
+}
+
+__extension__ static __inline unsigned long long int
+__NTH (gnu_dev_makedev (unsigned int __major, unsigned int __minor))
+{
+  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
+	  | (((unsigned long long int) (__minor & ~0xff)) << 12)
+	  | (((unsigned long long int) (__major & ~0xfff)) << 32));
+}
+# endif
+
+
+/* Access the functions with their traditional names.  */
+# define major(dev) gnu_dev_major (dev)
+# define minor(dev) gnu_dev_minor (dev)
+# define makedev(maj, min) gnu_dev_makedev (maj, min)
+#endif
+
+#endif /* sys/sysmacros.h */
diff -pruwN busybox-1.01/include2/sys/time.h busybox-1.01-livebox/include2/sys/time.h
--- busybox-1.01/include2/sys/time.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/time.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,173 @@
+/* Copyright (C) 1991-1994,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_TIME_H
+#define _SYS_TIME_H	1
+
+#include <features.h>
+
+#include <bits/types.h>
+#define __need_time_t
+#include <time.h>
+#define __need_timeval
+#include <bits/time.h>
+
+#include <sys/select.h>
+
+#ifndef __suseconds_t_defined
+typedef __suseconds_t suseconds_t;
+# define __suseconds_t_defined
+#endif
+
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+/* Macros for converting between `struct timeval' and `struct timespec'.  */
+# define TIMEVAL_TO_TIMESPEC(tv, ts) {                                   \
+        (ts)->tv_sec = (tv)->tv_sec;                                    \
+        (ts)->tv_nsec = (tv)->tv_usec * 1000;                           \
+}
+# define TIMESPEC_TO_TIMEVAL(tv, ts) {                                   \
+        (tv)->tv_sec = (ts)->tv_sec;                                    \
+        (tv)->tv_usec = (ts)->tv_nsec / 1000;                           \
+}
+#endif
+
+
+#ifdef __USE_BSD
+/* Structure crudely representing a timezone.
+   This is obsolete and should never be used.  */
+struct timezone
+  {
+    int tz_minuteswest;		/* Minutes west of GMT.  */
+    int tz_dsttime;		/* Nonzero if DST is ever in effect.  */
+  };
+
+typedef struct timezone *__restrict __timezone_ptr_t;
+#else
+typedef void *__restrict __timezone_ptr_t;
+#endif
+
+/* Get the current time of day and timezone information,
+   putting it into *TV and *TZ.  If TZ is NULL, *TZ is not filled.
+   Returns 0 on success, -1 on errors.
+   NOTE: This form of timezone information is obsolete.
+   Use the functions and variables declared in <time.h> instead.  */
+extern int gettimeofday (struct timeval *__restrict __tv,
+			 __timezone_ptr_t __tz) __THROW;
+
+#ifdef __USE_BSD
+/* Set the current time of day and timezone information.
+   This call is restricted to the super-user.  */
+extern int settimeofday (__const struct timeval *__tv,
+			 __const struct timezone *__tz) __THROW;
+
+/* Adjust the current time of day by the amount in DELTA.
+   If OLDDELTA is not NULL, it is filled in with the amount
+   of time adjustment remaining to be done from the last `adjtime' call.
+   This call is restricted to the super-user.  */
+extern int adjtime (__const struct timeval *__delta,
+		    struct timeval *__olddelta) __THROW;
+#endif
+
+
+/* Values for the first argument to `getitimer' and `setitimer'.  */
+enum __itimer_which
+  {
+    /* Timers run in real time.  */
+    ITIMER_REAL = 0,
+#define ITIMER_REAL ITIMER_REAL
+    /* Timers run only when the process is executing.  */
+    ITIMER_VIRTUAL = 1,
+#define ITIMER_VIRTUAL ITIMER_VIRTUAL
+    /* Timers run when the process is executing and when
+       the system is executing on behalf of the process.  */
+    ITIMER_PROF = 2
+#define ITIMER_PROF ITIMER_PROF
+  };
+
+/* Type of the second argument to `getitimer' and
+   the second and third arguments `setitimer'.  */
+struct itimerval
+  {
+    /* Value to put into `it_value' when the timer expires.  */
+    struct timeval it_interval;
+    /* Time to the next timer expiration.  */
+    struct timeval it_value;
+  };
+
+#if defined __USE_GNU && !defined __cplusplus
+/* Use the nicer parameter type only in GNU mode and not for C++ since the
+   strict C++ rules prevent the automatic promotion.  */
+typedef enum __itimer_which __itimer_which_t;
+#else
+typedef int __itimer_which_t;
+#endif
+
+/* Set *VALUE to the current setting of timer WHICH.
+   Return 0 on success, -1 on errors.  */
+extern int getitimer (__itimer_which_t __which,
+		      struct itimerval *__value) __THROW;
+
+/* Set the timer WHICH to *NEW.  If OLD is not NULL,
+   set *OLD to the old value of timer WHICH.
+   Returns 0 on success, -1 on errors.  */
+extern int setitimer (__itimer_which_t __which,
+		      __const struct itimerval *__restrict __new,
+		      struct itimerval *__restrict __old) __THROW;
+
+/* Change the access time of FILE to TVP[0] and
+   the modification time of FILE to TVP[1].  */
+extern int utimes (__const char *__file, __const struct timeval __tvp[2])
+     __THROW;
+
+
+#ifdef __USE_BSD
+/* Convenience macros for operations on timevals.
+   NOTE: `timercmp' does not work for >= or <=.  */
+# define timerisset(tvp)	((tvp)->tv_sec || (tvp)->tv_usec)
+# define timerclear(tvp)	((tvp)->tv_sec = (tvp)->tv_usec = 0)
+# define timercmp(a, b, CMP) 						      \
+  (((a)->tv_sec == (b)->tv_sec) ? 					      \
+   ((a)->tv_usec CMP (b)->tv_usec) : 					      \
+   ((a)->tv_sec CMP (b)->tv_sec))
+# define timeradd(a, b, result)						      \
+  do {									      \
+    (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;			      \
+    (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;			      \
+    if ((result)->tv_usec >= 1000000)					      \
+      {									      \
+	++(result)->tv_sec;						      \
+	(result)->tv_usec -= 1000000;					      \
+      }									      \
+  } while (0)
+# define timersub(a, b, result)						      \
+  do {									      \
+    (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;			      \
+    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;			      \
+    if ((result)->tv_usec < 0) {					      \
+      --(result)->tv_sec;						      \
+      (result)->tv_usec += 1000000;					      \
+    }									      \
+  } while (0)
+#endif	/* BSD */
+
+__END_DECLS
+
+#endif /* sys/time.h */
diff -pruwN busybox-1.01/include2/sys/times.h busybox-1.01-livebox/include2/sys/times.h
--- busybox-1.01/include2/sys/times.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/times.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,53 @@
+/* Copyright (C) 1991, 1992, 1996, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 4.5.2 Process Times	<sys/times.h>
+ */
+
+#ifndef	_SYS_TIMES_H
+#define	_SYS_TIMES_H	1
+
+#include <features.h>
+
+#define	__need_clock_t
+#include <time.h>
+
+
+__BEGIN_DECLS
+
+/* Structure describing CPU time used by a process and its children.  */
+struct tms
+  {
+    clock_t tms_utime;		/* User CPU time.  */
+    clock_t tms_stime;		/* System CPU time.  */
+
+    clock_t tms_cutime;		/* User CPU time of dead children.  */
+    clock_t tms_cstime;		/* System CPU time of dead children.  */
+  };
+
+
+/* Store the CPU time used by this process and all its
+   dead children (and their dead children) in BUFFER.
+   Return the elapsed real time, or (clock_t) -1 for errors.
+   All times are in CLK_TCKths of a second.  */
+extern clock_t times (struct tms *__buffer) __THROW;
+
+__END_DECLS
+
+#endif /* sys/times.h	*/
diff -pruwN busybox-1.01/include2/sys/ttydefaults.h busybox-1.01-livebox/include2/sys/ttydefaults.h
--- busybox-1.01/include2/sys/ttydefaults.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/ttydefaults.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,100 @@
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
+ */
+
+/*
+ * System wide defaults for terminal state.  Linux version.
+ */
+#ifndef _SYS_TTYDEFAULTS_H_
+#define	_SYS_TTYDEFAULTS_H_
+
+/*
+ * Defaults on "first" open.
+ */
+#define	TTYDEF_IFLAG	(BRKINT | ISTRIP | ICRNL | IMAXBEL | IXON | IXANY)
+#define TTYDEF_OFLAG	(OPOST | ONLCR | XTABS)
+#define TTYDEF_LFLAG	(ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
+#define TTYDEF_CFLAG	(CREAD | CS7 | PARENB | HUPCL)
+#define TTYDEF_SPEED	(B9600)
+
+/*
+ * Control Character Defaults
+ */
+#define CTRL(x)	(x&037)
+#define	CEOF		CTRL('d')
+#ifdef _POSIX_VDISABLE
+# define CEOL		_POSIX_VDISABLE
+#else
+# define CEOL		'\0'		/* XXX avoid _POSIX_VDISABLE */
+#endif
+#define	CERASE		0177
+#define	CINTR		CTRL('c')
+#ifdef _POSIX_VDISABLE
+# define CSTATUS	_POSIX_VDISABLE
+#else
+# define CSTATUS	'\0'		/* XXX avoid _POSIX_VDISABLE */
+#endif
+#define	CKILL		CTRL('u')
+#define	CMIN		1
+#define	CQUIT		034		/* FS, ^\ */
+#define	CSUSP		CTRL('z')
+#define	CTIME		0
+#define	CDSUSP		CTRL('y')
+#define	CSTART		CTRL('q')
+#define	CSTOP		CTRL('s')
+#define	CLNEXT		CTRL('v')
+#define	CDISCARD 	CTRL('o')
+#define	CWERASE 	CTRL('w')
+#define	CREPRINT 	CTRL('r')
+#define	CEOT		CEOF
+/* compat */
+#define	CBRK		CEOL
+#define CRPRNT		CREPRINT
+#define	CFLUSH		CDISCARD
+
+/* PROTECTED INCLUSION ENDS HERE */
+#endif /* !_SYS_TTYDEFAULTS_H_ */
+
+/*
+ * #define TTYDEFCHARS to include an array of default control characters.
+ */
+#ifdef TTYDEFCHARS
+cc_t	ttydefchars[NCCS] = {
+	CEOF,	CEOL,	CEOL,	CERASE, CWERASE, CKILL, CREPRINT,
+	_POSIX_VDISABLE, CINTR,	CQUIT,	CSUSP,	CDSUSP,	CSTART,	CSTOP,	CLNEXT,
+	CDISCARD, CMIN,	CTIME,  CSTATUS, _POSIX_VDISABLE
+};
+#undef TTYDEFCHARS
+#endif
diff -pruwN busybox-1.01/include2/sys/types.h busybox-1.01-livebox/include2/sys/types.h
--- busybox-1.01/include2/sys/types.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/types.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,264 @@
+/* Copyright (C) 1991,92,94,95,96,97,98,99,2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
+ */
+
+#ifndef	_SYS_TYPES_H
+#define	_SYS_TYPES_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/types.h>
+
+#ifdef	__USE_BSD
+# ifndef __u_char_defined
+typedef __u_char u_char;
+typedef __u_short u_short;
+typedef __u_int u_int;
+typedef __u_long u_long;
+typedef __quad_t quad_t;
+typedef __u_quad_t u_quad_t;
+typedef __fsid_t fsid_t;
+#  define __u_char_defined
+# endif
+#endif
+
+typedef __loff_t loff_t;
+
+#ifndef __ino_t_defined
+# ifndef __USE_FILE_OFFSET64
+typedef __ino_t ino_t;
+# else
+typedef __ino64_t ino_t;
+# endif
+# define __ino_t_defined
+#endif
+#if defined __USE_LARGEFILE64 && !defined __ino64_t_defined
+typedef __ino64_t ino64_t;
+# define __ino64_t_defined
+#endif
+
+#ifndef __dev_t_defined
+typedef __dev_t dev_t;
+# define __dev_t_defined
+#endif
+
+#ifndef __gid_t_defined
+typedef __gid_t gid_t;
+# define __gid_t_defined
+#endif
+
+#ifndef __mode_t_defined
+typedef __mode_t mode_t;
+# define __mode_t_defined
+#endif
+
+#ifndef __nlink_t_defined
+typedef __nlink_t nlink_t;
+# define __nlink_t_defined
+#endif
+
+#ifndef __uid_t_defined
+typedef __uid_t uid_t;
+# define __uid_t_defined
+#endif
+
+#ifndef __off_t_defined
+# ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+# else
+typedef __off64_t off_t;
+# endif
+# define __off_t_defined
+#endif
+#if defined __USE_LARGEFILE64 && !defined __off64_t_defined
+typedef __off64_t off64_t;
+# define __off64_t_defined
+#endif
+
+#ifndef __pid_t_defined
+typedef __pid_t pid_t;
+# define __pid_t_defined
+#endif
+
+#if (defined __USE_SVID || defined __USE_XOPEN) && !defined __id_t_defined
+typedef __id_t id_t;
+# define __id_t_defined
+#endif
+
+#ifndef __ssize_t_defined
+typedef __ssize_t ssize_t;
+# define __ssize_t_defined
+#endif
+
+#ifdef	__USE_BSD
+# ifndef __daddr_t_defined
+typedef __daddr_t daddr_t;
+typedef __caddr_t caddr_t;
+#  define __daddr_t_defined
+# endif
+#endif
+
+#if (defined __USE_SVID || defined __USE_XOPEN) && !defined __key_t_defined
+typedef __key_t key_t;
+# define __key_t_defined
+#endif
+
+#ifdef __USE_XOPEN
+# define __need_clock_t
+#endif
+#define	__need_time_t
+#define __need_timer_t
+#define __need_clockid_t
+#include <time.h>
+
+#ifdef __USE_XOPEN
+# ifndef __useconds_t_defined
+typedef __useconds_t useconds_t;
+#  define __useconds_t_defined
+# endif
+# ifndef __suseconds_t_defined
+typedef __suseconds_t suseconds_t;
+#  define __suseconds_t_defined
+# endif
+#endif
+
+#define	__need_size_t
+#include <stddef.h>
+
+#ifdef __USE_MISC
+/* Old compatibility names for C types.  */
+typedef unsigned long int ulong;
+typedef unsigned short int ushort;
+typedef unsigned int uint;
+#endif
+
+/* These size-specific names are used by some of the inet code.  */
+
+#if !__GNUC_PREREQ (2, 7)
+
+/* These types are defined by the ISO C99 header <inttypes.h>. */
+# ifndef __int8_t_defined
+#  define __int8_t_defined
+typedef	char int8_t;
+typedef	short int int16_t;
+typedef	int int32_t;
+#  ifdef __GNUC__
+__extension__ typedef long long int int64_t;
+#  endif
+# endif
+
+/* But these were defined by ISO C without the first `_'.  */
+typedef	unsigned char u_int8_t;
+typedef	unsigned short int u_int16_t;
+typedef	unsigned int u_int32_t;
+# ifdef __GNUC__
+__extension__ typedef unsigned long long int u_int64_t;
+# endif
+
+typedef int register_t;
+
+#else
+
+/* For GCC 2.7 and later, we can use specific type-size attributes.  */
+# define __intN_t(N, MODE) \
+  typedef int int##N##_t __attribute__ ((__mode__ (MODE)))
+# define __u_intN_t(N, MODE) \
+  typedef unsigned int u_int##N##_t __attribute__ ((__mode__ (MODE)))
+
+# ifndef __int8_t_defined
+#  define __int8_t_defined
+__intN_t (8, __QI__);
+__intN_t (16, __HI__);
+__intN_t (32, __SI__);
+__intN_t (64, __DI__);
+# endif
+
+__u_intN_t (8, __QI__);
+__u_intN_t (16, __HI__);
+__u_intN_t (32, __SI__);
+__u_intN_t (64, __DI__);
+
+typedef int register_t __attribute__ ((__mode__ (__word__)));
+
+
+/* Some code from BIND tests this macro to see if the types above are
+   defined.  */
+#endif
+#define __BIT_TYPES_DEFINED__	1
+
+
+#ifdef	__USE_BSD
+/* In BSD <sys/types.h> is expected to define BYTE_ORDER.  */
+# include <endian.h>
+
+/* It also defines `fd_set' and the FD_* macros for `select'.  */
+# include <sys/select.h>
+
+/* BSD defines these symbols, so we follow.  */
+# include <sys/sysmacros.h>
+#endif /* Use BSD.  */
+
+
+#if defined __USE_UNIX98 && !defined __blksize_t_defined
+typedef __blksize_t blksize_t;
+# define __blksize_t_defined
+#endif
+
+/* Types from the Large File Support interface.  */
+#ifndef __USE_FILE_OFFSET64
+# ifndef __blkcnt_t_defined
+typedef __blkcnt_t blkcnt_t;	 /* Type to count number of disk blocks.  */
+#  define __blkcnt_t_defined
+# endif
+# ifndef __fsblkcnt_t_defined
+typedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */
+#  define __fsblkcnt_t_defined
+# endif
+# ifndef __fsfilcnt_t_defined
+typedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */
+#  define __fsfilcnt_t_defined
+# endif
+#else
+# ifndef __blkcnt_t_defined
+typedef __blkcnt64_t blkcnt_t;	   /* Type to count number of disk blocks.  */
+#  define __blkcnt_t_defined
+# endif
+# ifndef __fsblkcnt_t_defined
+typedef __fsblkcnt64_t fsblkcnt_t; /* Type to count file system blocks.  */
+#  define __fsblkcnt_t_defined
+# endif
+# ifndef __fsfilcnt_t_defined
+typedef __fsfilcnt64_t fsfilcnt_t; /* Type to count file system inodes.  */
+#  define __fsfilcnt_t_defined
+# endif
+#endif
+
+#ifdef __USE_LARGEFILE64
+typedef __blkcnt64_t blkcnt64_t;     /* Type to count number of disk blocks. */
+typedef __fsblkcnt64_t fsblkcnt64_t; /* Type to count file system blocks.  */
+typedef __fsfilcnt64_t fsfilcnt64_t; /* Type to count file system inodes.  */
+#endif
+
+__END_DECLS
+
+#endif /* sys/types.h */
diff -pruwN busybox-1.01/include2/sys/ucontext.h busybox-1.01-livebox/include2/sys/ucontext.h
--- busybox-1.01/include2/sys/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/ucontext.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,158 @@
+/* Copyright (C) 1998, 1999, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* System V/mips ABI compliant context switching support.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* Type for general register.  */
+#if _MIPS_SIM == _MIPS_SIM_ABI32
+typedef __uint32_t greg_t;
+#else
+typedef __uint64_t greg_t;
+#endif
+
+/* Number of general registers.  */
+#define NGREG	36
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[NGREG];
+
+/* Number of each register is the `gregset_t' array.  */
+enum
+{
+  CTX_R0 = 0,
+#define CTX_R0	CTX_R0
+  CTX_AT = 1,
+#define CTX_AT	CTX_AT
+  CTX_V0 = 2,
+#define CTX_V0	CTX_V0
+  CTX_V1 = 3,
+#define CTX_V1	CTX_V1
+  CTX_A0 = 4,
+#define CTX_A0	CTX_A0
+  CTX_A1 = 5,
+#define CTX_A1	CTX_A1
+  CTX_A2 = 6,
+#define CTX_A2	CTX_A2
+  CTX_A3 = 7,
+#define CTX_A3	CTX_A3
+  CTX_T0 = 8,
+#define CTX_T0	CTX_T0
+  CTX_T1 = 9,
+#define CTX_T1	CTX_T1
+  CTX_T2 = 10,
+#define CTX_T2	CTX_T2
+  CTX_T3 = 11,
+#define CTX_T3	CTX_T3
+  CTX_T4 = 12,
+#define CTX_T4	CTX_T4
+  CTX_T5 = 13,
+#define CTX_T5	CTX_T5
+  CTX_T6 = 14,
+#define CTX_T6	CTX_T6
+  CTX_T7 = 15,
+#define CTX_T7	CTX_T7
+  CTX_S0 = 16,
+#define CTX_S0	CTX_S0
+  CTX_S1 = 17,
+#define CTX_S1	CTX_S1
+  CTX_S2 = 18,
+#define CTX_S2	CTX_S2
+  CTX_S3 = 19,
+#define CTX_S3	CTX_S3
+  CTX_S4 = 20,
+#define CTX_S4	CTX_S4
+  CTX_S5 = 21,
+#define CTX_S5	CTX_S5
+  CTX_S6 = 22,
+#define CTX_S6	CTX_S6
+  CTX_S7 = 23,
+#define CTX_S7	CTX_S7
+  CTX_T8 = 24,
+#define CTX_T8	CTX_T8
+  CTX_T9 = 25,
+#define CTX_T9	CTX_T9
+  CTX_K0 = 26,
+#define CTX_K0	CTX_K0
+  CTX_K1 = 27,
+#define CTX_K1	CTX_K1
+  CTX_GP = 28,
+#define CTX_GP	CTX_GP
+  CTX_SP = 29,
+#define CTX_SP	CTX_SP
+  CTX_S8 = 30,
+#define CTX_S8	CTX_S8
+  CTX_RA = 31,
+#define CTX_RA	CTX_RA
+  CTX_MDLO = 32,
+#define CTX_MDLO	CTX_MDLO
+  CTX_MDHI = 33,
+#define CTX_MDHI	CTX_MDHI
+  CTX_CAUSE = 34,
+#define CTX_CAUSE	CTX_CAUSE
+  CTX_EPC = 35,
+#define CTX_EPC	CTX_EPC
+};
+
+/* Structure to describe FPU registers.  */
+typedef struct fpregset
+{
+  union
+  {
+#if _MIPS_SIM == _MIPS_SIM_ABI32
+    double fp_dregs[16];
+    float fp_fregs[32];
+    unsigned int fp_regs[32];
+#else
+    double fp_dregs[32];
+    /* float fp_fregs[32]; */
+    __uint64_t fp_regs[32];
+#endif
+  } fp_r;
+  unsigned int fp_csr;
+  unsigned int fp_pad;
+} fpregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct
+{
+  gregset_t gpregs;
+  fpregset_t fpregs;
+} mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+{
+#if _MIPS_SIM == _MIPS_SIM_ABI32
+  unsigned long int uc_flags;
+#else
+  __uint64_t uc_flags;
+#endif
+  struct ucontext *uc_link;
+  __sigset_t uc_sigmask;
+  stack_t uc_stack;
+  mcontext_t uc_mcontext;
+  int uc_filler[48];
+} ucontext_t;
+
+#endif /* sys/ucontext.h */
diff -pruwN busybox-1.01/include2/sys/uio.h busybox-1.01-livebox/include2/sys/uio.h
--- busybox-1.01/include2/sys/uio.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/uio.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,50 @@
+/* Copyright (C) 1991, 92, 96, 97, 98, 99 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UIO_H
+#define _SYS_UIO_H	1
+
+#include <features.h>
+
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+/* This file defines `struct iovec'.  */
+#include <bits/uio.h>
+
+
+/* Read data from file descriptor FD, and put the result in the
+   buffers described by VECTOR, which is a vector of COUNT `struct iovec's.
+   The buffers are filled in the order specified.
+   Operates just like `read' (see <unistd.h>) except that data are
+   put in VECTOR instead of a contiguous buffer.  */
+extern ssize_t readv (int __fd, __const struct iovec *__vector, int __count)
+     __THROW;
+
+/* Write data pointed by the buffers described by VECTOR, which
+   is a vector of COUNT `struct iovec's, to file descriptor FD.
+   The data is written in the order specified.
+   Operates just like `write' (see <unistd.h>) except that the data
+   are taken from VECTOR instead of a contiguous buffer.  */
+extern ssize_t writev (int __fd, __const struct iovec *__vector, int __count)
+     __THROW;
+
+__END_DECLS
+
+#endif /* sys/uio.h */
diff -pruwN busybox-1.01/include2/sys/utsname.h busybox-1.01-livebox/include2/sys/utsname.h
--- busybox-1.01/include2/sys/utsname.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/utsname.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,74 @@
+/* Copyright (C) 1991, 92, 94, 96, 97, 99 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 4.4 System Identification	<sys/utsname.h>
+ */
+
+#ifndef	_SYS_UTSNAME_H
+#define	_SYS_UTSNAME_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/utsname.h>
+
+#ifndef _UTSNAME_NODENAME_LENGTH
+# define _UTSNAME_NODENAME_LENGTH _UTSNAME_LENGTH
+#endif
+
+/* Structure describing the system and machine.  */
+struct utsname
+  {
+    /* Name of the implementation of the operating system.  */
+    char sysname[_UTSNAME_LENGTH];
+
+    /* Name of this node on the network.  */
+    char nodename[_UTSNAME_NODENAME_LENGTH];
+
+    /* Current release level of this implementation.  */
+    char release[_UTSNAME_LENGTH];
+    /* Current version level of this release.  */
+    char version[_UTSNAME_LENGTH];
+
+    /* Name of the hardware type the system is running on.  */
+    char machine[_UTSNAME_LENGTH];
+
+#if _UTSNAME_DOMAIN_LENGTH - 0
+    /* Name of the domain of this node on the network.  */
+# ifdef __USE_GNU
+    char domainname[_UTSNAME_DOMAIN_LENGTH];
+# else
+    char __domainname[_UTSNAME_DOMAIN_LENGTH];
+# endif
+#endif
+  };
+
+#ifdef __USE_SVID
+# define SYS_NMLN  _UTSNAME_LENGTH
+#endif
+
+
+/* Put information about the system in NAME.  */
+extern int uname (struct utsname *__name) __THROW;
+
+
+__END_DECLS
+
+#endif /* sys/utsname.h  */
diff -pruwN busybox-1.01/include2/sys/vfs.h busybox-1.01-livebox/include2/sys/vfs.h
--- busybox-1.01/include2/sys/vfs.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/vfs.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,4 @@
+/* Other systems declare `struct statfs' et al in <sys/vfs.h>,
+   so we have this file to be compatible with programs expecting it.  */
+
+#include <sys/statfs.h>
diff -pruwN busybox-1.01/include2/sys/wait.h busybox-1.01-livebox/include2/sys/wait.h
--- busybox-1.01/include2/sys/wait.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sys/wait.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,173 @@
+/* Copyright (C) 1991-1994,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 3.2.1 Wait for Process Termination	<sys/wait.h>
+ */
+
+#ifndef	_SYS_WAIT_H
+#define	_SYS_WAIT_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <signal.h>
+#include <sys/resource.h>
+
+/* These macros could also be defined int <stdlib.h>.  */
+#if !defined _STDLIB_H || !defined __USE_XOPEN
+/* This will define the `W*' macros for the flag
+   bits to `waitpid', `wait3', and `wait4'.  */
+# include <bits/waitflags.h>
+
+# ifdef	__USE_BSD
+
+/* Lots of hair to allow traditional BSD use of `union wait'
+   as well as POSIX.1 use of `int' for the status word.  */
+
+#  if defined __GNUC__ && !defined __cplusplus
+#   define __WAIT_INT(status)						      \
+  (__extension__ ({ union { __typeof(status) __in; int __i; } __u;	      \
+		    __u.__in = (status); __u.__i; }))
+#  else
+#   define __WAIT_INT(status)	(*(int *) &(status))
+#  endif
+
+/* This is the type of the argument to `wait'.  The funky union
+   causes redeclarations with ether `int *' or `union wait *' to be
+   allowed without complaint.  __WAIT_STATUS_DEFN is the type used in
+   the actual function definitions.  */
+
+#  if !defined __GNUC__ || __GNUC__ < 2 || defined __cplusplus
+#   define __WAIT_STATUS	void *
+#   define __WAIT_STATUS_DEFN	void *
+#  else
+/* This works in GCC 2.6.1 and later.  */
+typedef union
+  {
+    union wait *__uptr;
+    int *__iptr;
+  } __WAIT_STATUS __attribute__ ((__transparent_union__));
+#   define __WAIT_STATUS_DEFN	int *
+#  endif
+
+# else /* Don't use BSD.  */
+
+#  define __WAIT_INT(status)	(status)
+#  define __WAIT_STATUS		int *
+#  define __WAIT_STATUS_DEFN	int *
+
+# endif /* Use BSD.  */
+
+/* This will define all the `__W*' macros.  */
+# include <bits/waitstatus.h>
+
+# define WEXITSTATUS(status)	__WEXITSTATUS(__WAIT_INT(status))
+# define WTERMSIG(status)	__WTERMSIG(__WAIT_INT(status))
+# define WSTOPSIG(status)	__WSTOPSIG(__WAIT_INT(status))
+# define WIFEXITED(status)	__WIFEXITED(__WAIT_INT(status))
+# define WIFSIGNALED(status)	__WIFSIGNALED(__WAIT_INT(status))
+# define WIFSTOPPED(status)	__WIFSTOPPED(__WAIT_INT(status))
+#endif	/* <stdlib.h> not included.  */
+
+#ifdef	__USE_BSD
+# define WCOREFLAG		__WCOREFLAG
+# define WCOREDUMP(status)	__WCOREDUMP(__WAIT_INT(status))
+# define W_EXITCODE(ret, sig)	__W_EXITCODE(ret, sig)
+# define W_STOPCODE(sig)	__W_STOPCODE(sig)
+#endif
+
+/* The following values are used by the `waitid' function.  */
+#if defined __USE_SVID || defined __USE_XOPEN
+typedef enum
+{
+  P_ALL,		/* Wait for any child.  */
+  P_PID,		/* Wait for specified process.  */
+  P_PGID		/* Wait for members of process group.  */
+} idtype_t;
+#endif
+
+
+/* Wait for a child to die.  When one does, put its status in *STAT_LOC
+   and return its process ID.  For errors, return (pid_t) -1.  */
+extern __pid_t wait (__WAIT_STATUS __stat_loc) __THROW;
+
+#ifdef	__USE_BSD
+/* Special values for the PID argument to `waitpid' and `wait4'.  */
+# define WAIT_ANY	(-1)	/* Any process.  */
+# define WAIT_MYPGRP	0	/* Any process in my process group.  */
+#endif
+
+/* Wait for a child matching PID to die.
+   If PID is greater than 0, match any process whose process ID is PID.
+   If PID is (pid_t) -1, match any process.
+   If PID is (pid_t) 0, match any process with the
+   same process group as the current process.
+   If PID is less than -1, match any process whose
+   process group is the absolute value of PID.
+   If the WNOHANG bit is set in OPTIONS, and that child
+   is not already dead, return (pid_t) 0.  If successful,
+   return PID and store the dead child's status in STAT_LOC.
+   Return (pid_t) -1 for errors.  If the WUNTRACED bit is
+   set in OPTIONS, return status for stopped children; otherwise don't.  */
+extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options) __THROW;
+
+#if defined __USE_SVID || defined __USE_XOPEN
+# define __need_siginfo_t
+# include <bits/siginfo.h>
+/* Wait for a childing matching IDTYPE and ID to change the status and
+   place appropriate information in *INFOP.
+   If IDTYPE is P_PID, match any process whose process ID is ID.
+   If IDTYPE is P_PGID, match any process whose process group is ID.
+   If IDTYPE is P_ALL, match any process.
+   If the WNOHANG bit is set in OPTIONS, and that child
+   is not already dead, clear *INFOP and return 0.  If successful, store
+   exit code and status in *INFOP.  */
+extern int waitid (idtype_t __idtype, __id_t __id, siginfo_t *__infop,
+		   int __options) __THROW;
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* This being here makes the prototypes valid whether or not
+   we have already included <sys/resource.h> to define `struct rusage'.  */
+struct rusage;
+
+/* Wait for a child to exit.  When one does, put its status in *STAT_LOC and
+   return its process ID.  For errors return (pid_t) -1.  If USAGE is not
+   nil, store information about the child's resource usage there.  If the
+   WUNTRACED bit is set in OPTIONS, return status for stopped children;
+   otherwise don't.  */
+extern __pid_t wait3 (__WAIT_STATUS __stat_loc, int __options,
+		      struct rusage * __usage) __THROW;
+#endif
+
+#ifdef __USE_BSD
+/* This being here makes the prototypes valid whether or not
+   we have already included <sys/resource.h> to define `struct rusage'.  */
+struct rusage;
+
+/* PID is like waitpid.  Other args are like wait3.  */
+extern __pid_t wait4 (__pid_t __pid, __WAIT_STATUS __stat_loc, int __options,
+		      struct rusage *__usage) __THROW;
+#endif /* Use BSD.  */
+
+
+__END_DECLS
+
+#endif /* sys/wait.h  */
diff -pruwN busybox-1.01/include2/sysexits.h busybox-1.01-livebox/include2/sysexits.h
--- busybox-1.01/include2/sysexits.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/sysexits.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 1987, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)sysexits.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef	_SYSEXITS_H
+#define	_SYSEXITS_H 1
+
+/*
+ *  SYSEXITS.H -- Exit status codes for system programs.
+ *
+ *	This include file attempts to categorize possible error
+ *	exit statuses for system programs, notably delivermail
+ *	and the Berkeley network.
+ *
+ *	Error numbers begin at EX__BASE to reduce the possibility of
+ *	clashing with other exit statuses that random programs may
+ *	already return.  The meaning of the codes is approximately
+ *	as follows:
+ *
+ *	EX_USAGE -- The command was used incorrectly, e.g., with
+ *		the wrong number of arguments, a bad flag, a bad
+ *		syntax in a parameter, or whatever.
+ *	EX_DATAERR -- The input data was incorrect in some way.
+ *		This should only be used for user's data & not
+ *		system files.
+ *	EX_NOINPUT -- An input file (not a system file) did not
+ *		exist or was not readable.  This could also include
+ *		errors like "No message" to a mailer (if it cared
+ *		to catch it).
+ *	EX_NOUSER -- The user specified did not exist.  This might
+ *		be used for mail addresses or remote logins.
+ *	EX_NOHOST -- The host specified did not exist.  This is used
+ *		in mail addresses or network requests.
+ *	EX_UNAVAILABLE -- A service is unavailable.  This can occur
+ *		if a support program or file does not exist.  This
+ *		can also be used as a catchall message when something
+ *		you wanted to do doesn't work, but you don't know
+ *		why.
+ *	EX_SOFTWARE -- An internal software error has been detected.
+ *		This should be limited to non-operating system related
+ *		errors as possible.
+ *	EX_OSERR -- An operating system error has been detected.
+ *		This is intended to be used for such things as "cannot
+ *		fork", "cannot create pipe", or the like.  It includes
+ *		things like getuid returning a user that does not
+ *		exist in the passwd file.
+ *	EX_OSFILE -- Some system file (e.g., /etc/passwd, /etc/utmp,
+ *		etc.) does not exist, cannot be opened, or has some
+ *		sort of error (e.g., syntax error).
+ *	EX_CANTCREAT -- A (user specified) output file cannot be
+ *		created.
+ *	EX_IOERR -- An error occurred while doing I/O on some file.
+ *	EX_TEMPFAIL -- temporary failure, indicating something that
+ *		is not really an error.  In sendmail, this means
+ *		that a mailer (e.g.) could not create a connection,
+ *		and the request should be reattempted later.
+ *	EX_PROTOCOL -- the remote system returned something that
+ *		was "not possible" during a protocol exchange.
+ *	EX_NOPERM -- You did not have sufficient permission to
+ *		perform the operation.  This is not intended for
+ *		file system problems, which should use NOINPUT or
+ *		CANTCREAT, but rather for higher level permissions.
+ */
+
+#define EX_OK		0	/* successful termination */
+
+#define EX__BASE	64	/* base value for error messages */
+
+#define EX_USAGE	64	/* command line usage error */
+#define EX_DATAERR	65	/* data format error */
+#define EX_NOINPUT	66	/* cannot open input */
+#define EX_NOUSER	67	/* addressee unknown */
+#define EX_NOHOST	68	/* host name unknown */
+#define EX_UNAVAILABLE	69	/* service unavailable */
+#define EX_SOFTWARE	70	/* internal software error */
+#define EX_OSERR	71	/* system error (e.g., can't fork) */
+#define EX_OSFILE	72	/* critical OS file missing */
+#define EX_CANTCREAT	73	/* can't create (user) output file */
+#define EX_IOERR	74	/* input/output error */
+#define EX_TEMPFAIL	75	/* temp failure; user is invited to retry */
+#define EX_PROTOCOL	76	/* remote error in protocol */
+#define EX_NOPERM	77	/* permission denied */
+#define EX_CONFIG	78	/* configuration error */
+
+#define EX__MAX	78	/* maximum listed value */
+
+#endif /* sysexits.h */
diff -pruwN busybox-1.01/include2/syslog.h busybox-1.01-livebox/include2/syslog.h
--- busybox-1.01/include2/syslog.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/syslog.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1 @@
+#include <sys/syslog.h>
diff -pruwN busybox-1.01/include2/termios.h busybox-1.01-livebox/include2/termios.h
--- busybox-1.01/include2/termios.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/termios.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,107 @@
+/* Copyright (C) 1991,92,93,94,96,97,98,99 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 7.1-2 General Terminal Interface	<termios.h>
+ */
+
+#ifndef	_TERMIOS_H
+#define	_TERMIOS_H	1
+
+#include <features.h>
+#ifdef __USE_UNIX98
+/* We need `pid_t'.  */
+# include <bits/types.h>
+# ifndef __pid_t_defined
+typedef __pid_t pid_t;
+#  define __pid_t_defined
+# endif
+#endif
+
+__BEGIN_DECLS
+
+/* Get the system-dependent definitions of `struct termios', `tcflag_t',
+   `cc_t', `speed_t', and all the macros specifying the flag bits.  */
+#include <bits/termios.h>
+
+#ifdef __USE_BSD
+/* Compare a character C to a value VAL from the `c_cc' array in a
+   `struct termios'.  If VAL is _POSIX_VDISABLE, no character can match it.  */
+# define CCEQ(val, c)	((c) == (val) && (val) != _POSIX_VDISABLE)
+#endif
+
+/* Return the output baud rate stored in *TERMIOS_P.  */
+extern speed_t cfgetospeed (__const struct termios *__termios_p) __THROW;
+
+/* Return the input baud rate stored in *TERMIOS_P.  */
+extern speed_t cfgetispeed (__const struct termios *__termios_p) __THROW;
+
+/* Set the output baud rate stored in *TERMIOS_P to SPEED.  */
+extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __THROW;
+
+/* Set the input baud rate stored in *TERMIOS_P to SPEED.  */
+extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __THROW;
+
+#ifdef	__USE_BSD
+/* Set both the input and output baud rates in *TERMIOS_OP to SPEED.  */
+extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __THROW;
+#endif
+
+
+/* Put the state of FD into *TERMIOS_P.  */
+extern int tcgetattr (int __fd, struct termios *__termios_p) __THROW;
+
+/* Set the state of FD to *TERMIOS_P.
+   Values for OPTIONAL_ACTIONS (TCSA*) are in <bits/termios.h>.  */
+extern int tcsetattr (int __fd, int __optional_actions,
+		      __const struct termios *__termios_p) __THROW;
+
+
+#ifdef	__USE_BSD
+/* Set *TERMIOS_P to indicate raw mode.  */
+extern void cfmakeraw (struct termios *__termios_p) __THROW;
+#endif
+
+/* Send zero bits on FD.  */
+extern int tcsendbreak (int __fd, int __duration) __THROW;
+
+/* Wait for pending output to be written on FD.  */
+extern int tcdrain (int __fd) __THROW;
+
+/* Flush pending data on FD.
+   Values for QUEUE_SELECTOR (TC{I,O,IO}FLUSH) are in <bits/termios.h>.  */
+extern int tcflush (int __fd, int __queue_selector) __THROW;
+
+/* Suspend or restart transmission on FD.
+   Values for ACTION (TC[IO]{OFF,ON}) are in <bits/termios.h>.  */
+extern int tcflow (int __fd, int __action) __THROW;
+
+
+#ifdef __USE_UNIX98
+/* Get process group ID for session leader for controlling terminal FD.  */
+extern __pid_t tcgetsid (int __fd) __THROW;
+#endif
+
+
+#ifdef __USE_BSD
+# include <sys/ttydefaults.h>
+#endif
+
+__END_DECLS
+
+#endif /* termios.h  */
diff -pruwN busybox-1.01/include2/time.h busybox-1.01-livebox/include2/time.h
--- busybox-1.01/include2/time.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/time.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,442 @@
+/* Copyright (C) 1991-1999,2000,2001,2002,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99 Standard: 7.23 Date and time	<time.h>
+ */
+
+#ifndef	_TIME_H
+
+#if (! defined __need_time_t && !defined __need_clock_t && \
+     ! defined __need_timespec)
+# define _TIME_H	1
+# include <features.h>
+
+__BEGIN_DECLS
+
+#endif
+
+#ifdef	_TIME_H
+/* Get size_t and NULL from <stddef.h>.  */
+# define __need_size_t
+# define __need_NULL
+# include <stddef.h>
+
+/* This defines CLOCKS_PER_SEC, which is the number of processor clock
+   ticks per second.  */
+# include <bits/time.h>
+
+/* This is the obsolete POSIX.1-1988 name for the same constant.  */
+# if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
+#  ifndef CLK_TCK
+#   define CLK_TCK	CLOCKS_PER_SEC
+#  endif
+# endif
+
+#endif /* <time.h> included.  */
+
+#if !defined __clock_t_defined && (defined _TIME_H || defined __need_clock_t)
+# define __clock_t_defined	1
+
+# include <bits/types.h>
+
+__BEGIN_NAMESPACE_STD
+/* Returned by `clock'.  */
+typedef __clock_t clock_t;
+__END_NAMESPACE_STD
+#if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
+__USING_NAMESPACE_STD(clock_t)
+#endif
+
+#endif /* clock_t not defined and <time.h> or need clock_t.  */
+#undef	__need_clock_t
+
+#if !defined __time_t_defined && (defined _TIME_H || defined __need_time_t)
+# define __time_t_defined	1
+
+# include <bits/types.h>
+
+__BEGIN_NAMESPACE_STD
+/* Returned by `time'.  */
+typedef __time_t time_t;
+__END_NAMESPACE_STD
+#if defined __USE_POSIX || defined __USE_MISC || defined __USE_SVID
+__USING_NAMESPACE_STD(time_t)
+#endif
+
+#endif /* time_t not defined and <time.h> or need time_t.  */
+#undef	__need_time_t
+
+#if !defined __clockid_t_defined && \
+   ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_clockid_t)
+# define __clockid_t_defined	1
+
+# include <bits/types.h>
+
+/* Clock ID used in clock and timer functions.  */
+typedef __clockid_t clockid_t;
+
+#endif /* clockid_t not defined and <time.h> or need clockid_t.  */
+#undef	__clockid_time_t
+
+#if !defined __timer_t_defined && \
+    ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_timer_t)
+# define __timer_t_defined	1
+
+# include <bits/types.h>
+
+/* Timer ID returned by `timer_create'.  */
+typedef __timer_t timer_t;
+
+#endif /* timer_t not defined and <time.h> or need timer_t.  */
+#undef	__need_timer_t
+
+
+#if !defined __timespec_defined &&				\
+    ((defined _TIME_H &&					\
+      (defined __USE_POSIX199309 || defined __USE_MISC)) ||	\
+      defined __need_timespec)
+# define __timespec_defined	1
+
+/* POSIX.1b structure for a time value.  This is like a `struct timeval' but
+   has nanoseconds instead of microseconds.  */
+struct timespec
+  {
+    __time_t tv_sec;		/* Seconds.  */
+    long int tv_nsec;		/* Nanoseconds.  */
+  };
+
+#endif /* timespec not defined and <time.h> or need timespec.  */
+#undef	__need_timespec
+
+
+#ifdef	_TIME_H
+__BEGIN_NAMESPACE_STD
+/* Used by other time functions.  */
+struct tm
+{
+  int tm_sec;			/* Seconds.	[0-60] (1 leap second) */
+  int tm_min;			/* Minutes.	[0-59] */
+  int tm_hour;			/* Hours.	[0-23] */
+  int tm_mday;			/* Day.		[1-31] */
+  int tm_mon;			/* Month.	[0-11] */
+  int tm_year;			/* Year	- 1900.  */
+  int tm_wday;			/* Day of week.	[0-6] */
+  int tm_yday;			/* Days in year.[0-365]	*/
+  int tm_isdst;			/* DST.		[-1/0/1]*/
+
+#ifdef __UCLIBC_HAS_TM_EXTENSIONS__
+#ifdef	__USE_BSD
+  long int tm_gmtoff;		/* Seconds east of UTC.  */
+  __const char *tm_zone;	/* Timezone abbreviation. */
+#else
+  long int __tm_gmtoff;		/* Seconds east of UTC.  */
+  __const char *__tm_zone;	/* Timezone abbreviation. */
+#endif
+#endif /* __UCLIBC_HAS_TM_EXTENSIONS__ */
+};
+__END_NAMESPACE_STD
+#if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
+__USING_NAMESPACE_STD(tm)
+#endif
+
+
+#ifdef __USE_POSIX199309
+/* POSIX.1b structure for timer start values and intervals.  */
+struct itimerspec
+  {
+    struct timespec it_interval;
+    struct timespec it_value;
+  };
+
+/* We can use a simple forward declaration.  */
+struct sigevent;
+
+#endif	/* POSIX.1b */
+
+#ifdef __USE_XOPEN2K
+# ifndef __pid_t_defined
+typedef __pid_t pid_t;
+#  define __pid_t_defined
+# endif
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Time used by the program so far (user time + system time).
+   The result / CLOCKS_PER_SECOND is program time in seconds.  */
+extern clock_t clock (void) __THROW;
+
+/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
+extern time_t time (time_t *__timer) __THROW;
+
+#ifdef __UCLIBC_HAS_FLOATS__
+/* Return the difference between TIME1 and TIME0.  */
+extern double difftime (time_t __time1, time_t __time0)
+     __THROW __attribute__ ((__const__));
+#endif /* __UCLIBC_HAS_FLOATS__ */
+
+/* Return the `time_t' representation of TP and normalize TP.  */
+extern time_t mktime (struct tm *__tp) __THROW;
+
+
+/* Format TP into S according to FORMAT.
+   Write no more than MAXSIZE characters and return the number
+   of characters written, or 0 if it would exceed MAXSIZE.  */
+extern size_t strftime (char *__restrict __s, size_t __maxsize,
+			__const char *__restrict __format,
+			__const struct tm *__restrict __tp) __THROW;
+__END_NAMESPACE_STD
+
+# ifdef __USE_XOPEN
+/* Parse S according to FORMAT and store binary time information in TP.
+   The return value is a pointer to the first unparsed character in S.  */
+extern char *strptime (__const char *__restrict __s,
+		       __const char *__restrict __fmt, struct tm *__tp)
+     __THROW;
+# endif
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+# ifdef __USE_GNU
+/* Similar to the two functions above but take the information from
+   the provided locale and not the global locale.  */
+# include <xlocale.h>
+
+extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
+			  __const char *__restrict __format,
+			  __const struct tm *__restrict __tp,
+			  __locale_t __loc) __THROW;
+
+extern char *strptime_l (__const char *__restrict __s,
+			 __const char *__restrict __fmt, struct tm *__tp,
+			 __locale_t __loc) __THROW;
+
+
+extern size_t __strftime_l (char *__restrict __s, size_t __maxsize,
+							__const char *__restrict __format,
+							__const struct tm *__restrict __tp,
+							__locale_t __loc) __THROW;
+
+extern char *__strptime_l (__const char *__restrict __s,
+						   __const char *__restrict __fmt, struct tm *__tp,
+						   __locale_t __loc) __THROW;
+
+# endif
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Return the `struct tm' representation of *TIMER
+   in Universal Coordinated Time (aka Greenwich Mean Time).  */
+extern struct tm *gmtime (__const time_t *__timer) __THROW;
+
+/* Return the `struct tm' representation
+   of *TIMER in the local timezone.  */
+extern struct tm *localtime (__const time_t *__timer) __THROW;
+__END_NAMESPACE_STD
+
+# if defined __USE_POSIX || defined __USE_MISC
+/* Return the `struct tm' representation of *TIMER in UTC,
+   using *TP to store the result.  */
+extern struct tm *gmtime_r (__const time_t *__restrict __timer,
+			    struct tm *__restrict __tp) __THROW;
+
+/* Return the `struct tm' representation of *TIMER in local time,
+   using *TP to store the result.  */
+extern struct tm *localtime_r (__const time_t *__restrict __timer,
+			       struct tm *__restrict __tp) __THROW;
+# endif	/* POSIX or misc */
+
+__BEGIN_NAMESPACE_STD
+/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
+   that is the representation of TP in this format.  */
+extern char *asctime (__const struct tm *__tp) __THROW;
+
+/* Equivalent to `asctime (localtime (timer))'.  */
+extern char *ctime (__const time_t *__timer) __THROW;
+__END_NAMESPACE_STD
+
+# if defined __USE_POSIX || defined __USE_MISC
+/* Reentrant versions of the above functions.  */
+
+/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
+   that is the representation of TP in this format.  */
+extern char *asctime_r (__const struct tm *__restrict __tp,
+			char *__restrict __buf) __THROW;
+
+/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
+extern char *ctime_r (__const time_t *__restrict __timer,
+		      char *__restrict __buf) __THROW;
+# endif	/* POSIX or misc */
+
+
+/* Defined in localtime.c.  */
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning "mjn3 FIXME: __tzname, __daylight, and __timezone have a prototype but are not defined."
+extern char *__tzname[2];	/* Current timezone names.  */
+extern int __daylight;		/* If daylight-saving time is ever in use.  */
+extern long int __timezone;	/* Seconds west of UTC.  */
+#endif /* __UCLIBC_MJN3_ONLY__ */
+
+
+# ifdef	__USE_POSIX
+/* Same as above.  */
+extern char *tzname[2];
+
+/* Set time conversion information from the TZ environment variable.
+   If TZ is not defined, a locale-dependent default is used.  */
+extern void tzset (void) __THROW;
+# endif
+
+# if defined __USE_SVID || defined __USE_XOPEN
+extern int daylight;
+extern long int timezone;
+# endif
+
+# ifdef __USE_SVID
+/* Set the system time to *WHEN.
+   This call is restricted to the superuser.  */
+extern int stime (__const time_t *__when) __THROW;
+# endif
+
+
+/* Nonzero if YEAR is a leap year (every 4 years,
+   except every 100th isn't, and every 400th is).  */
+# define __isleap(year)	\
+  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
+
+
+# ifdef __USE_MISC
+/* Miscellaneous functions many Unices inherited from the public domain
+   localtime package.  These are included only for compatibility.  */
+
+/* Like `mktime', but for TP represents Universal Time, not local time.  */
+extern time_t timegm (struct tm *__tp) __THROW;
+
+/* Another name for `mktime'.  */
+extern time_t timelocal (struct tm *__tp) __THROW;
+
+/* Return the number of days in YEAR.  */
+extern int dysize (int __year) __THROW  __attribute__ ((__const__));
+# endif
+
+
+# ifdef __USE_POSIX199309
+/* Pause execution for a number of nanoseconds.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int nanosleep (__const struct timespec *__requested_time,
+		      struct timespec *__remaining);
+
+
+/* Get resolution of clock CLOCK_ID.  */
+extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __THROW;
+
+/* Get current value of clock CLOCK_ID and store it in TP.  */
+extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __THROW;
+
+/* Set clock CLOCK_ID to value TP.  */
+extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp) __THROW;
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning "mjn3 FIXME: a bunch of unimplemented function prototypes."
+#  ifdef __USE_XOPEN2K
+/* High-resolution sleep with the specified clock.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int clock_nanosleep (clockid_t __clock_id, int __flags,
+			    __const struct timespec *__req,
+			    struct timespec *__rem);
+
+/* Return clock ID for CPU-time clock.  */
+extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __THROW;
+#  endif
+
+
+/* Create new per-process timer using CLOCK_ID.  */
+extern int timer_create (clockid_t __clock_id,
+			 struct sigevent *__restrict __evp,
+			 timer_t *__restrict __timerid) __THROW;
+
+/* Delete timer TIMERID.  */
+extern int timer_delete (timer_t __timerid) __THROW;
+
+/* Set timer TIMERID to VALUE, returning old value in OVLAUE.  */
+extern int timer_settime (timer_t __timerid, int __flags,
+			  __const struct itimerspec *__restrict __value,
+			  struct itimerspec *__restrict __ovalue) __THROW;
+
+/* Get current value of timer TIMERID and store it in VLAUE.  */
+extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
+     __THROW;
+
+/* Get expiration overrun for timer TIMERID.  */
+extern int timer_getoverrun (timer_t __timerid) __THROW;
+#endif /* __UCLIBC_MJN3_ONLY__ */
+# endif
+
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning "mjn3 FIXME: a bunch of unimplemented function prototypes."
+# ifdef __USE_XOPEN_EXTENDED
+/* Set to one of the following values to indicate an error.
+     1  the DATEMSK environment variable is null or undefined,
+     2  the template file cannot be opened for reading,
+     3  failed to get file status information,
+     4  the template file is not a regular file,
+     5  an error is encountered while reading the template file,
+     6  memory allication failed (not enough memory available),
+     7  there is no line in the template that matches the input,
+     8  invalid input specification Example: February 31 or a time is
+        specified that can not be represented in a time_t (representing
+	the time in seconds since 00:00:00 UTC, January 1, 1970) */
+extern int getdate_err;
+
+/* Parse the given string as a date specification and return a value
+   representing the value.  The templates from the file identified by
+   the environment variable DATEMSK are used.  In case of an error
+   `getdate_err' is set.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+extern struct tm *getdate (__const char *__string);
+# endif
+
+# ifdef __USE_GNU
+/* Since `getdate' is not reentrant because of the use of `getdate_err'
+   and the static buffer to return the result in, we provide a thread-safe
+   variant.  The functionality is the same.  The result is returned in
+   the buffer pointed to by RESBUFP and in case of an error the return
+   value is != 0 with the same values as given above for `getdate_err'.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int getdate_r (__const char *__restrict __string,
+		      struct tm *__restrict __resbufp);
+# endif
+#endif /* __UCLIBC_MJN3_ONLY__ */
+
+__END_DECLS
+
+#endif /* <time.h> included.  */
+
+#endif /* <time.h> not already included.  */
diff -pruwN busybox-1.01/include2/ucontext.h busybox-1.01-livebox/include2/ucontext.h
--- busybox-1.01/include2/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/ucontext.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,32 @@
+/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UCONTEXT_H
+#define _UCONTEXT_H	1
+
+#include <features.h>
+
+/* Get machine dependent definition of data structures.  */
+#include <sys/ucontext.h>
+
+/* The System V ABI user-level context switching support functions
+ * are marked obsolescent by SuSv3, and are not implemented by
+ * uClibc.  This header is therefore empty.  */
+
+
+#endif /* ucontext.h */
diff -pruwN busybox-1.01/include2/unistd.h busybox-1.01-livebox/include2/unistd.h
--- busybox-1.01/include2/unistd.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/unistd.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,941 @@
+/* Copyright (C) 1991-1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
+ */
+
+#ifndef	_UNISTD_H
+#define	_UNISTD_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* These may be used to determine what facilities are present at compile time.
+   Their values can be obtained at run time from `sysconf'.  */
+
+/* POSIX Standard approved as ISO/IEC 9945-1 as of August, 1988 and
+   extended by POSIX-1b (aka POSIX-4) and POSIX-1c (aka POSIX threads).  */
+#define	_POSIX_VERSION	199506L
+
+/* These are not #ifdef __USE_POSIX2 because they are
+   in the theoretically application-owned namespace.  */
+
+/* POSIX Standard approved as ISO/IEC 9945-2 as of December, 1993.  */
+#define	_POSIX2_C_VERSION	199209L
+
+/* The utilities on GNU systems also correspond to this version.  */
+#define _POSIX2_VERSION	199209L
+
+/* If defined, the implementation supports the
+   C Language Bindings Option.  */
+#define	_POSIX2_C_BIND	1
+
+/* If defined, the implementation supports the
+   C Language Development Utilities Option.  */
+#define	_POSIX2_C_DEV	1
+
+/* If defined, the implementation supports the
+   Software Development Utilities Option.  */
+#define	_POSIX2_SW_DEV	1
+
+/* If defined, the implementation supports the
+   creation of locales with the localedef utility.  */
+#define _POSIX2_LOCALEDEF       1
+
+/* X/Open version number to which the library conforms.  It is selectable.  */
+#ifdef __USE_UNIX98
+# define _XOPEN_VERSION	500
+#else
+# define _XOPEN_VERSION	4
+#endif
+
+/* Commands and utilities from XPG4 are available.  */
+#define _XOPEN_XCU_VERSION	4
+
+/* We are compatible with the old published standards as well.  */
+#define _XOPEN_XPG2	1
+#define _XOPEN_XPG3	1
+#define _XOPEN_XPG4	1
+
+/* The X/Open Unix extensions are available.  */
+#define _XOPEN_UNIX	1
+
+/* Encryption is present.  */
+#define	_XOPEN_CRYPT	1
+
+/* The enhanced internationalization capabilities according to XPG4.2
+   are present.  */
+#define	_XOPEN_ENH_I18N	1
+
+/* The legacy interfaces are also available.  */
+#define _XOPEN_LEGACY	1
+
+
+/* Get values of POSIX options:
+
+   If these symbols are defined, the corresponding features are
+   always available.  If not, they may be available sometimes.
+   The current values can be obtained with `sysconf'.
+
+   _POSIX_JOB_CONTROL		Job control is supported.
+   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
+				and a saved set-group-ID.
+   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
+   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
+   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
+   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
+   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
+   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
+   _POSIX_FSYNC			The fsync function is present.
+   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
+   _POSIX_MEMLOCK		Locking of all memory is supported.
+   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
+   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
+   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
+   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
+   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
+   _POSIX_THREADS		POSIX.1c pthreads are supported.
+   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
+   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
+   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
+   _POSIX_THREAD_PRIORITY_SCHEDULING
+				POSIX.1c thread execution scheduling supported.
+   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
+   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
+   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
+   _POSIX_PII			Protocol-independent interfaces are supported.
+   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
+   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
+   _POSIX_PII_INTERNET		Internet family of protocols supported.
+   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
+   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
+   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
+   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
+   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
+   _POSIX_POLL			Implementation supports `poll' function.
+   _POSIX_SELECT		Implementation supports `select' and `pselect'.
+
+   _XOPEN_REALTIME		X/Open realtime support is available.
+   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
+   _XOPEN_SHM			Shared memory interface according to XPG4.2.
+
+   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
+				int, long, pointer, and off_t types.
+   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
+				int, long, and pointer and off_t with at least
+				64 bits.
+   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
+				int, and 64-bit long, pointer, and off_t types.
+   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
+				least 32 bits int and long, pointer, and off_t
+				with at least 64 bits.
+
+   If any of these symbols is defined as -1, the corresponding option is not
+   true for any file.  If any is defined as other than -1, the corresponding
+   option is true for all files.  If a symbol is not defined at all, the value
+   for a specific file can be obtained from `pathconf' and `fpathconf'.
+
+   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
+				the owner of a file.  `chown' can only be used
+				to change the group ID of a file to a group of
+				which the calling process is a member.
+   _POSIX_NO_TRUNC		Pathname components longer than
+				NAME_MAX generate an error.
+   _POSIX_VDISABLE		If defined, if the value of an element of the
+				`c_cc' member of `struct termios' is
+				_POSIX_VDISABLE, no character will have the
+				effect associated with that element.
+   _POSIX_SYNC_IO		Synchronous I/O may be performed.
+   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
+   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.
+
+   Support for the Large File Support interface is not generally available.
+   If it is available the following constants are defined to one.
+   _LFS64_LARGEFILE		Low-level I/O supports large files.
+   _LFS64_STDIO			Standard I/O supports large files.
+   */
+
+#include <bits/posix_opt.h>
+
+/* Get the environment definitions from Unix98.  */
+#ifdef __USE_UNIX98
+# include <bits/environments.h>
+#endif
+
+/* Standard file descriptors.  */
+#define	STDIN_FILENO	0	/* Standard input.  */
+#define	STDOUT_FILENO	1	/* Standard output.  */
+#define	STDERR_FILENO	2	/* Standard error output.  */
+
+
+/* All functions that are not declared anywhere else.  */
+
+#include <bits/types.h>
+
+#ifndef	__ssize_t_defined
+typedef __ssize_t ssize_t;
+# define __ssize_t_defined
+#endif
+
+#define	__need_size_t
+#define __need_NULL
+#include <stddef.h>
+
+#ifdef __USE_XOPEN
+/* The Single Unix specification says that some more types are
+   available here.  */
+# ifndef __gid_t_defined
+typedef __gid_t gid_t;
+#  define __gid_t_defined
+# endif
+
+# ifndef __uid_t_defined
+typedef __uid_t uid_t;
+#  define __uid_t_defined
+# endif
+
+# ifndef __off_t_defined
+#  ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+#  else
+typedef __off64_t off_t;
+#  endif
+#  define __off_t_defined
+# endif
+# if defined __USE_LARGEFILE64 && !defined __off64_t_defined
+typedef __off64_t off64_t;
+#  define __off64_t_defined
+# endif
+
+# ifndef __useconds_t_defined
+typedef __useconds_t useconds_t;
+#  define __useconds_t_defined
+# endif
+
+# ifndef __pid_t_defined
+typedef __pid_t pid_t;
+#  define __pid_t_defined
+# endif
+#endif	/* X/Open */
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED
+# ifndef __intptr_t_defined
+typedef __intptr_t intptr_t;
+#  define __intptr_t_defined
+# endif
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN
+# ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+#  define __socklen_t_defined
+# endif
+#endif
+
+/* Values for the second argument to access.
+   These may be OR'd together.  */
+#define	R_OK	4		/* Test for read permission.  */
+#define	W_OK	2		/* Test for write permission.  */
+#define	X_OK	1		/* Test for execute permission.  */
+#define	F_OK	0		/* Test for existence.  */
+
+/* Test for access to NAME using the real UID and real GID.  */
+extern int access (__const char *__name, int __type) __THROW;
+
+
+/* Values for the WHENCE argument to lseek.  */
+#ifndef	_STDIO_H		/* <stdio.h> has the same definitions.  */
+# define SEEK_SET	0	/* Seek from beginning of file.  */
+# define SEEK_CUR	1	/* Seek from current position.  */
+# define SEEK_END	2	/* Seek from end of file.  */
+#endif
+
+#if defined __USE_BSD && !defined L_SET
+/* Old BSD names for the same constants; just for compatibility.  */
+# define L_SET		SEEK_SET
+# define L_INCR		SEEK_CUR
+# define L_XTND		SEEK_END
+#endif
+
+
+/* Move FD's file position to OFFSET bytes from the
+   beginning of the file (if WHENCE is SEEK_SET),
+   the current position (if WHENCE is SEEK_CUR),
+   or the end of the file (if WHENCE is SEEK_END).
+   Return the new file position.  */
+#ifndef __USE_FILE_OFFSET64
+extern __off_t lseek (int __fd, __off_t __offset, int __whence) __THROW;
+#else
+# ifdef __REDIRECT
+extern __off64_t __REDIRECT (lseek,
+			     (int __fd, __off64_t __offset, int __whence)
+			     __THROW,
+			     lseek64);
+# else
+#  define lseek lseek64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence) __THROW;
+#endif
+
+/* Close the file descriptor FD.  */
+extern int close (int __fd) __THROW;
+
+/* Read NBYTES into BUF from FD.  Return the
+   number read, -1 for errors or 0 for EOF.  */
+extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __THROW;
+
+/* Write N bytes of BUF to FD.  Return the number written, or -1.  */
+extern ssize_t write (int __fd, __const void *__buf, size_t __n) __THROW;
+
+#ifdef __USE_UNIX98
+# ifndef __USE_FILE_OFFSET64
+extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset)
+     __THROW;
+extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
+		       __off_t __offset) __THROW;
+# else
+#  ifdef __REDIRECT
+extern ssize_t __REDIRECT (pread, (int __fd, void *__buf, size_t __nbytes,
+				   __off64_t __offset) __THROW,
+			   pread64);
+extern ssize_t __REDIRECT (pwrite, (int __fd, __const void *__buf,
+				    size_t __nbytes, __off64_t __offset)
+			   __THROW,
+			pwrite64);
+#  else
+#   define pread pread64
+#   define pwrite pwrite64
+#  endif
+# endif
+
+# ifdef __USE_LARGEFILE64
+/* Read NBYTES into BUF from FD at the given position OFFSET without
+   changing the file pointer.  Return the number read, -1 for errors
+   or 0 for EOF.  */
+extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
+			__off64_t __offset) __THROW;
+/* Write N bytes of BUF to FD at the given position OFFSET without
+   changing the file pointer.  Return the number written, or -1.  */
+extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
+			 __off64_t __offset) __THROW;
+# endif
+#endif
+
+/* Create a one-way communication channel (pipe).
+   If successful, two file descriptors are stored in PIPEDES;
+   bytes written on PIPEDES[1] can be read from PIPEDES[0].
+   Returns 0 if successful, -1 if not.  */
+extern int pipe (int __pipedes[2]) __THROW;
+
+/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
+   If SECONDS is zero, any currently scheduled alarm will be cancelled.
+   The function returns the number of seconds remaining until the last
+   alarm scheduled would have signaled, or zero if there wasn't one.
+   There is no return value to indicate an error, but you can set `errno'
+   to 0 and check its value after calling `alarm', and this might tell you.
+   The signal may come late due to processor scheduling.  */
+extern unsigned int alarm (unsigned int __seconds) __THROW;
+
+/* Make the process sleep for SECONDS seconds, or until a signal arrives
+   and is not ignored.  The function returns the number of seconds less
+   than SECONDS which it actually slept (thus zero if it slept the full time).
+   If a signal handler does a `longjmp' or modifies the handling of the
+   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
+   signal afterwards is undefined.  There is no return value to indicate
+   error, but if `sleep' returns SECONDS, it probably didn't work.  */
+extern unsigned int sleep (unsigned int __seconds) __THROW;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Set an alarm to go off (generating a SIGALRM signal) in VALUE
+   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
+   timer is reset to go off every INTERVAL microseconds thereafter.
+   Returns the number of microseconds remaining before the alarm.  */
+extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
+     __THROW;
+
+/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
+   or ignored.  */
+extern int usleep (__useconds_t __useconds) __THROW;
+#endif
+
+
+/* Suspend the process until a signal arrives.
+   This always returns -1 and sets `errno' to EINTR.  */
+extern int pause (void) __THROW;
+
+
+/* Change the owner and group of FILE.  */
+extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
+     __THROW;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Change the owner and group of the file that FD is open on.  */
+extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __THROW;
+
+
+/* Change owner and group of FILE, if it is a symbolic
+   link the ownership of the symbolic link is changed.  */
+extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
+     __THROW;
+
+#endif /* Use BSD || X/Open Unix.  */
+
+/* Change the process's working directory to PATH.  */
+extern int chdir (__const char *__path) __THROW;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Change the process's working directory to the one FD is open on.  */
+extern int fchdir (int __fd) __THROW;
+#endif
+
+/* Get the pathname of the current working directory,
+   and put it in SIZE bytes of BUF.  Returns NULL if the
+   directory couldn't be determined or SIZE was too small.
+   If successful, returns BUF.  In GNU, if BUF is NULL,
+   an array is allocated with `malloc'; the array is SIZE
+   bytes long, unless SIZE == 0, in which case it is as
+   big as necessary.  */
+extern char *getcwd (char *__buf, size_t __size) __THROW;
+
+/* Return a malloc'd string containing the current directory name.
+   If the environment variable `PWD' is set, and its value is correct,
+   that value is used.  */
+extern char *get_current_dir_name (void) __THROW;
+
+
+
+/* Duplicate FD, returning a new file descriptor on the same file.  */
+extern int dup (int __fd) __THROW;
+
+/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */
+extern int dup2 (int __fd, int __fd2) __THROW;
+
+/* NULL-terminated array of "NAME=VALUE" environment variables.  */
+extern char **__environ;
+#ifdef __USE_GNU
+extern char **environ;
+#endif
+
+
+/* Replace the current process, executing PATH with arguments ARGV and
+   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */
+extern int execve (__const char *__path, char *__const __argv[],
+		   char *__const __envp[]) __THROW;
+
+/* Execute PATH with arguments ARGV and environment from `environ'.  */
+extern int execv (__const char *__path, char *__const __argv[]) __THROW;
+
+/* Execute PATH with all arguments after PATH until a NULL pointer,
+   and the argument after that for environment.  */
+extern int execle (__const char *__path, __const char *__arg, ...) __THROW;
+
+/* Execute PATH with all arguments after PATH until
+   a NULL pointer and environment from `environ'.  */
+extern int execl (__const char *__path, __const char *__arg, ...) __THROW;
+
+/* Execute FILE, searching in the `PATH' environment variable if it contains
+   no slashes, with arguments ARGV and environment from `environ'.  */
+extern int execvp (__const char *__file, char *__const __argv[]) __THROW;
+
+/* Execute FILE, searching in the `PATH' environment variable if
+   it contains no slashes, with all arguments after FILE until a
+   NULL pointer and environment from `environ'.  */
+extern int execlp (__const char *__file, __const char *__arg, ...) __THROW;
+
+
+#if defined __USE_MISC || defined __USE_XOPEN
+/* Add INC to priority of the current process.  */
+extern int nice (int __inc) __THROW;
+#endif
+
+
+/* Terminate program execution with the low-order 8 bits of STATUS.  */
+extern void _exit (int __status) __attribute__ ((__noreturn__));
+
+
+/* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
+   the `_SC_*' symbols for the NAME argument to `sysconf';
+   and the `_CS_*' symbols for the NAME argument to `confstr'.  */
+#include <bits/confname.h>
+
+/* Get file-specific configuration information about PATH.  */
+extern long int pathconf (__const char *__path, int __name) __THROW;
+
+/* Get file-specific configuration about descriptor FD.  */
+extern long int fpathconf (int __fd, int __name) __THROW;
+
+/* Get the value of the system variable NAME.  */
+extern long int sysconf (int __name) __THROW __attribute__ ((__const__));
+
+#ifdef	__USE_POSIX2
+/* Get the value of the string-valued system variable NAME.  */
+extern size_t confstr (int __name, char *__buf, size_t __len) __THROW;
+#endif
+
+
+/* Get the process ID of the calling process.  */
+extern __pid_t getpid (void) __THROW;
+
+/* Get the process ID of the calling process's parent.  */
+extern __pid_t getppid (void) __THROW;
+
+/* Get the process group ID of the calling process.
+   This function is different on old BSD. */
+#ifndef __FAVOR_BSD
+extern __pid_t getpgrp (void) __THROW;
+#else
+# ifdef __REDIRECT
+extern __pid_t __REDIRECT (getpgrp, (__pid_t __pid) __THROW, __getpgid);
+# else
+#  define getpgrp __getpgid
+# endif
+#endif
+
+/* Get the process group ID of process PID.  */
+extern __pid_t __getpgid (__pid_t __pid) __THROW;
+#ifdef __USE_XOPEN_EXTENDED
+extern __pid_t getpgid (__pid_t __pid) __THROW;
+#endif
+
+
+/* Set the process group ID of the process matching PID to PGID.
+   If PID is zero, the current process's process group ID is set.
+   If PGID is zero, the process ID of the process is used.  */
+extern int setpgid (__pid_t __pid, __pid_t __pgid) __THROW;
+
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Both System V and BSD have `setpgrp' functions, but with different
+   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
+   (above).  The System V function takes no arguments and puts the calling
+   process in its on group like `setpgid (0, 0)'.
+
+   New programs should always use `setpgid' instead.
+
+   The default in GNU is to provide the System V function.  The BSD
+   function is available under -D_BSD_SOURCE.  */
+
+# ifndef __FAVOR_BSD
+
+/* Set the process group ID of the calling process to its own PID.
+   This is exactly the same as `setpgid (0, 0)'.  */
+extern int setpgrp (void) __THROW;
+
+# else
+
+/* Another name for `setpgid' (above).  */
+#  ifdef __REDIRECT
+extern int __REDIRECT (setpgrp, (__pid_t __pid, __pid_t __pgrp) __THROW,
+		       setpgid);
+#  else
+#   define setpgrp setpgid
+#  endif
+
+# endif	/* Favor BSD.  */
+#endif	/* Use SVID or BSD.  */
+
+/* Create a new session with the calling process as its leader.
+   The process group IDs of the session and the calling process
+   are set to the process ID of the calling process, which is returned.  */
+extern __pid_t setsid (void) __THROW;
+
+#ifdef __USE_XOPEN_EXTENDED
+/* Return the session ID of the given process.  */
+extern __pid_t getsid (__pid_t __pid) __THROW;
+#endif
+
+/* Get the real user ID of the calling process.  */
+extern __uid_t getuid (void) __THROW;
+
+/* Get the effective user ID of the calling process.  */
+extern __uid_t geteuid (void) __THROW;
+
+/* Get the real group ID of the calling process.  */
+extern __gid_t getgid (void) __THROW;
+
+/* Get the effective group ID of the calling process.  */
+extern __gid_t getegid (void) __THROW;
+
+/* If SIZE is zero, return the number of supplementary groups
+   the calling process is in.  Otherwise, fill in the group IDs
+   of its supplementary groups in LIST and return the number written.  */
+extern int getgroups (int __size, __gid_t __list[]) __THROW;
+
+/* Set the user ID of the calling process to UID.
+   If the calling process is the super-user, set the real
+   and effective user IDs, and the saved set-user-ID to UID;
+   if not, the effective user ID is set to UID.  */
+extern int setuid (__uid_t __uid) __THROW;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Set the real user ID of the calling process to RUID,
+   and the effective user ID of the calling process to EUID.  */
+extern int setreuid (__uid_t __ruid, __uid_t __euid) __THROW;
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+/* Set the effective user ID of the calling process to UID.  */
+extern int seteuid (__uid_t __uid) __THROW;
+#endif /* Use BSD.  */
+
+/* Set the group ID of the calling process to GID.
+   If the calling process is the super-user, set the real
+   and effective group IDs, and the saved set-group-ID to GID;
+   if not, the effective group ID is set to GID.  */
+extern int setgid (__gid_t __gid) __THROW;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Set the real group ID of the calling process to RGID,
+   and the effective group ID of the calling process to EGID.  */
+extern int setregid (__gid_t __rgid, __gid_t __egid) __THROW;
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+/* Set the effective group ID of the calling process to GID.  */
+extern int setegid (__gid_t __gid) __THROW;
+#endif /* Use BSD.  */
+
+#ifdef __USE_GNU
+/* Fetch the effective user ID, real user ID, and saved-set user ID,
+   of the calling process.  */
+extern int getresuid (__uid_t *__euid, __uid_t *__ruid, __uid_t *__suid);
+
+/* Fetch the effective group ID, real group ID, and saved-set group ID,
+   of the calling process.  */
+extern int getresgid (__gid_t *__egid, __gid_t *__rgid, __gid_t *__sgid);
+
+/* Set the effective user ID, real user ID, and saved-set user ID,
+   of the calling process to EUID, RUID, and SUID, respectively.  */
+extern int setresuid (__uid_t __euid, __uid_t __ruid, __uid_t __suid);
+
+/* Set the effective group ID, real group ID, and saved-set group ID,
+   of the calling process to EGID, RGID, and SGID, respectively.  */
+extern int setresgid (__gid_t __egid, __gid_t __rgid, __gid_t __sgid);
+#endif
+
+
+/* Clone the calling process, creating an exact copy.
+   Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+extern __pid_t fork (void) __THROW;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+extern __pid_t vfork (void) __THROW;
+#endif /* Use BSD. */
+
+
+/* Return the pathname of the terminal FD is open on, or NULL on errors.
+   The returned storage is good only until the next call to this function.  */
+extern char *ttyname (int __fd) __THROW;
+
+/* Store at most BUFLEN characters of the pathname of the terminal FD is
+   open on in BUF.  Return 0 on success, otherwise an error number.  */
+extern int ttyname_r (int __fd, char *__buf, size_t __buflen) __THROW;
+
+/* Return 1 if FD is a valid descriptor associated
+   with a terminal, zero if not.  */
+extern int isatty (int __fd) __THROW;
+
+
+
+/* Make a link to FROM named TO.  */
+extern int link (__const char *__from, __const char *__to) __THROW;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Make a symbolic link to FROM named TO.  */
+extern int symlink (__const char *__from, __const char *__to) __THROW;
+
+/* Read the contents of the symbolic link PATH into no more than
+   LEN bytes of BUF.  The contents are not null-terminated.
+   Returns the number of characters read, or -1 for errors.  */
+extern int readlink (__const char *__restrict __path, char *__restrict __buf,
+		     size_t __len) __THROW;
+#endif /* Use BSD.  */
+
+/* Remove the link NAME.  */
+extern int unlink (__const char *__name) __THROW;
+
+/* Remove the directory PATH.  */
+extern int rmdir (__const char *__path) __THROW;
+
+
+/* Return the foreground process group ID of FD.  */
+extern __pid_t tcgetpgrp (int __fd) __THROW;
+
+/* Set the foreground process group ID of FD set PGRP_ID.  */
+extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __THROW;
+
+
+/* Return the login name of the user.  */
+extern char *getlogin (void) __THROW;
+#if defined __USE_REENTRANT || defined __USE_UNIX98
+/* Return at most NAME_LEN characters of the login name of the user in NAME.
+   If it cannot be determined or some other error occurred, return the error
+   code.  Otherwise return 0.  */
+extern int getlogin_r (char *__name, size_t __name_len) __THROW;
+#endif
+
+
+
+#ifdef	__USE_POSIX2
+/* Get definitions and prototypes for functions to process the
+   arguments in ARGV (ARGC of them, minus the program name) for
+   options given in OPTS.  */
+# define __need_getopt
+# include <bits/getopt.h>
+#endif
+
+
+#if defined __USE_BSD || defined __USE_UNIX98
+/* Put the name of the current host in no more than LEN bytes of NAME.
+   The result is null-terminated if LEN is large enough for the full
+   name and the terminator.  */
+extern int gethostname (char *__name, size_t __len) __THROW;
+#endif
+
+
+#if defined __USE_BSD || (defined __USE_XOPEN && !defined __USE_UNIX98)
+/* Set the name of the current host to NAME, which is LEN bytes long.
+   This call is restricted to the super-user.  */
+extern int sethostname (__const char *__name, size_t __len) __THROW;
+
+/* Set the current machine's Internet number to ID.
+   This call is restricted to the super-user.  */
+extern int sethostid (long int __id) __THROW;
+
+
+/* Get and set the NIS (aka YP) domain name, if any.
+   Called just like `gethostname' and `sethostname'.
+   The NIS domain name is usually the empty string when not using NIS.  */
+extern int getdomainname (char *__name, size_t __len) __THROW;
+extern int setdomainname (__const char *__name, size_t __len) __THROW;
+
+
+/* Revoke access permissions to all processes currently communicating
+   with the control terminal, and then send a SIGHUP signal to the process
+   group of the control terminal.  */
+extern int vhangup (void) __THROW;
+
+
+
+/* Turn accounting on if NAME is an existing file.  The system will then write
+   a record for each process as it terminates, to this file.  If NAME is NULL,
+   turn accounting off.  This call is restricted to the super-user.  */
+extern int acct (__const char *__name) __THROW;
+
+
+/* Successive calls return the shells listed in `/etc/shells'.  */
+extern char *getusershell (void) __THROW;
+extern void endusershell (void) __THROW; /* Discard cached info.  */
+extern void setusershell (void) __THROW; /* Rewind and re-read the file.  */
+
+
+/* Put the program in the background, and dissociate from the controlling
+   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
+   redirects stdin, stdout, and stderr to /dev/null.  */
+extern int daemon (int __nochdir, int __noclose) __THROW;
+#endif /* Use BSD || X/Open.  */
+
+
+#if defined __USE_BSD || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
+/* Make PATH be the root directory (the starting point for absolute paths).
+   This call is restricted to the super-user.  */
+extern int chroot (__const char *__path) __THROW;
+
+/* Prompt with PROMPT and read a string from the terminal without echoing.
+   Uses /dev/tty if possible; otherwise stderr and stdin.  */
+extern char *getpass (__const char *__prompt) __THROW;
+#endif /* Use BSD || X/Open.  */
+
+
+#if defined __USE_BSD || defined __USE_XOPEN
+/* Make all changes done to FD actually appear on disk.  */
+extern int fsync (int __fd) __THROW;
+#endif /* Use BSD || X/Open.  */
+
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+
+/* Return the current machine's Internet number.  */
+extern long int gethostid (void) __THROW;
+
+/* Make all changes done to all files actually appear on disk.  */
+extern void sync (void) __THROW;
+
+
+/* Return the number of bytes in a page.  This is the system's page size,
+   which is not necessarily the same as the hardware page size.  */
+extern int getpagesize (void)  __THROW __attribute__ ((__const__));
+
+
+/* Truncate FILE to LENGTH bytes.  */
+# ifndef __USE_FILE_OFFSET64
+extern int truncate (__const char *__file, __off_t __length) __THROW;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (truncate,
+		       (__const char *__file, __off64_t __length) __THROW,
+		       truncate64);
+#  else
+#   define truncate truncate64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int truncate64 (__const char *__file, __off64_t __length) __THROW;
+# endif
+
+/* Truncate the file FD is open on to LENGTH bytes.  */
+# ifndef __USE_FILE_OFFSET64
+extern int ftruncate (int __fd, __off_t __length) __THROW;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (ftruncate, (int __fd, __off64_t __length) __THROW,
+		       ftruncate64);
+#  else
+#   define ftruncate ftruncate64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int ftruncate64 (int __fd, __off64_t __length) __THROW;
+# endif
+
+
+/* Return the maximum number of file descriptors
+   the current process could possibly have.  */
+extern int getdtablesize (void) __THROW;
+
+#endif /* Use BSD || X/Open Unix.  */
+
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED
+
+/* Set the end of accessible data space (aka "the break") to ADDR.
+   Returns zero on success and -1 for errors (with errno set).  */
+extern int brk (void *__addr) __THROW;
+
+/* Increase or decrease the end of accessible data space by DELTA bytes.
+   If successful, returns the address the previous end of data space
+   (i.e. the beginning of the new space, if DELTA > 0);
+   returns (void *) -1 for errors (with errno set).  */
+extern void *sbrk (intptr_t __delta) __THROW;
+#endif
+
+
+#ifdef __USE_MISC
+/* Invoke `system call' number SYSNO, passing it the remaining arguments.
+   This is completely system-dependent, and not often useful.
+
+   In Unix, `syscall' sets `errno' for all errors and most calls return -1
+   for errors; in many systems you cannot pass arguments or get return
+   values for all system calls (`pipe', `fork', and `getppid' typically
+   among them).
+
+   In Mach, all system calls take normal arguments and always return an
+   error code (zero for success).  */
+extern long int syscall (long int __sysno, ...) __THROW;
+
+#endif	/* Use misc.  */
+
+
+#if (defined __USE_MISC || defined __USE_XOPEN_EXTENDED) && !defined F_LOCK
+/* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both
+   files consistent.  Some systems have them there and some here, and some
+   software depends on the macros being defined without including both.  */
+
+/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
+   LEN is always relative to the current file position.
+   The CMD argument is one of the following.  */
+
+# define F_ULOCK 0	/* Unlock a previously locked region.  */
+# define F_LOCK  1	/* Lock a region for exclusive use.  */
+# define F_TLOCK 2	/* Test and lock a region for exclusive use.  */
+# define F_TEST  3	/* Test a region for other processes locks.  */
+
+# ifndef __USE_FILE_OFFSET64
+extern int lockf (int __fd, int __cmd, __off_t __len) __THROW;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (lockf, (int __fd, int __cmd, __off64_t __len) __THROW,
+		       lockf64);
+#  else
+#   define lockf lockf64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int lockf64 (int __fd, int __cmd, __off64_t __len) __THROW;
+# endif
+#endif /* Use misc and F_LOCK not already defined.  */
+
+
+#ifdef __USE_GNU
+
+/* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'
+   set to EINTR.  */
+
+# define TEMP_FAILURE_RETRY(expression) \
+  (__extension__							      \
+    ({ long int __result;						      \
+       do __result = (long int) (expression);				      \
+       while (__result == -1L && errno == EINTR);			      \
+       __result; }))
+#endif
+
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+/* Synchronize at least the data part of a file with the underlying
+   media.  */
+extern int fdatasync (int __fildes) __THROW;
+#endif /* Use POSIX199309 */
+
+
+/* XPG4.2 specifies that prototypes for the encryption functions must
+   be defined here.  */
+#ifdef	__USE_XOPEN
+/* Encrypt at most 8 characters from KEY using salt to perturb DES.  */
+extern char *crypt (__const char *__key, __const char *__salt) __THROW;
+
+/* Encrypt data in BLOCK in place if EDFLAG is zero; otherwise decrypt
+   block in place.  */
+extern void encrypt (char *__block, int __edflag) __THROW;
+
+
+/* Swab pairs bytes in the first N bytes of the area pointed to by
+   FROM and copy the result to TO.  The value of TO must not be in the
+   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM
+   is without partner.  */
+extern void swab (__const void *__restrict __from, void *__restrict __to,
+		  ssize_t __n) __THROW;
+#endif
+
+
+/* The Single Unix specification demands this prototype to be here.
+   It is also found in <stdio.h>.  */
+#ifdef __USE_XOPEN
+/* Return the name of the controlling terminal.  */
+extern char *ctermid (char *__s) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* unistd.h  */
diff -pruwN busybox-1.01/include2/utime.h busybox-1.01-livebox/include2/utime.h
--- busybox-1.01/include2/utime.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/utime.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,51 @@
+/* Copyright (C) 1991, 92, 96, 97, 98, 99 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	POSIX Standard: 5.6.6 Set File Access and Modification Times  <utime.h>
+ */
+
+#ifndef	_UTIME_H
+#define	_UTIME_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/types.h>
+
+#ifdef __USE_XOPEN
+# define __need_time_t
+# include <time.h>
+#endif
+
+/* Structure describing file times.  */
+struct utimbuf
+  {
+    __time_t actime;		/* Access time.  */
+    __time_t modtime;		/* Modification time.  */
+  };
+
+/* Set the access and modification times of FILE to those given in
+   *FILE_TIMES.  If FILE_TIMES is NULL, set them to the current time.  */
+extern int utime (__const char *__file,
+		  __const struct utimbuf *__file_times) __THROW;
+
+__END_DECLS
+
+#endif /* utime.h */
diff -pruwN busybox-1.01/include2/wchar.h busybox-1.01-livebox/include2/wchar.h
--- busybox-1.01/include2/wchar.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/include2/wchar.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,788 @@
+/* Copyright (C) 1995-2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *      ISO C99 Standard: 7.24
+ *	Extended multibyte and wide character utilities	<wchar.h>
+ */
+
+#ifndef _WCHAR_H
+
+#ifndef __need_mbstate_t
+# define _WCHAR_H 1
+# include <features.h>
+#endif
+
+#ifndef __UCLIBC_HAS_WCHAR__
+#error Attempted to include wchar.h when uClibc built without wide char support.
+#endif
+
+#ifdef _WCHAR_H
+/* Get FILE definition.  */
+# define __need___FILE
+# ifdef __USE_UNIX98
+#  define __need_FILE
+# endif
+# include <stdio.h>
+/* Get va_list definition.  */
+# define __need___va_list
+# include <stdarg.h>
+
+/* Get size_t, wchar_t, wint_t and NULL from <stddef.h>.  */
+# define __need_size_t
+# define __need_wchar_t
+# define __need_NULL
+#endif
+#define __need_wint_t
+#include <stddef.h>
+
+#include <bits/wchar.h>
+
+/* We try to get wint_t from <stddef.h>, but not all GCC versions define it
+   there.  So define it ourselves if it remains undefined.  */
+#ifndef _WINT_T
+/* Integral type unchanged by default argument promotions that can
+   hold any value corresponding to members of the extended character
+   set, as well as at least one value that does not correspond to any
+   member of the extended character set.  */
+# define _WINT_T
+typedef unsigned int wint_t;
+#else
+/* Work around problems with the <stddef.h> file which doesn't put
+   wint_t in the std namespace.  */
+# if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES \
+     && defined __WINT_TYPE__
+__BEGIN_NAMESPACE_STD
+typedef __WINT_TYPE__ wint_t;
+__END_NAMESPACE_STD
+# endif
+#endif
+
+
+#ifndef __mbstate_t_defined
+# define __mbstate_t_defined	1
+/* Conversion state information.  */
+#if 1
+typedef struct
+{
+	wchar_t __mask;
+	wchar_t __wc;
+} __mbstate_t;
+#else
+typedef struct
+{
+  int __count;
+  union
+  {
+    wint_t __wch;
+    char __wchb[4];
+  } __value;		/* Value so far.  */
+} __mbstate_t;
+#endif
+#endif
+#undef __need_mbstate_t
+
+
+/* The rest of the file is only used if used if __need_mbstate_t is not
+   defined.  */
+#ifdef _WCHAR_H
+
+__BEGIN_NAMESPACE_C99
+/* Public type.  */
+typedef __mbstate_t mbstate_t;
+__END_NAMESPACE_C99
+#ifdef __USE_GNU
+__USING_NAMESPACE_C99(mbstate_t)
+#endif
+
+#ifndef WCHAR_MIN
+/* These constants might also be defined in <inttypes.h>.  */
+# define WCHAR_MIN __WCHAR_MIN
+# define WCHAR_MAX __WCHAR_MAX
+#endif
+
+#ifndef WEOF
+# define WEOF (0xffffffffu)
+#endif
+
+/* For XPG4 compliance we have to define the stuff from <wctype.h> here
+   as well.  */
+#if defined __USE_XOPEN && !defined __USE_UNIX98
+# include <wctype.h>
+#endif
+
+
+__BEGIN_DECLS
+
+__BEGIN_NAMESPACE_STD
+/* This incomplete type is defined in <time.h> but needed here because
+   of `wcsftime'.  */
+struct tm;
+/* XXX We have to clean this up at some point.  Since tm is in the std
+   namespace but wcsftime is in __c99 the type wouldn't be found
+   without inserting it in the global namespace.  */
+__USING_NAMESPACE_STD(tm)
+__END_NAMESPACE_STD
+
+
+__BEGIN_NAMESPACE_C99
+/* Copy SRC to DEST.  */
+extern wchar_t *wcscpy (wchar_t *__restrict __dest,
+			__const wchar_t *__restrict __src) __THROW;
+/* Copy no more than N wide-characters of SRC to DEST.  */
+extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
+			 __const wchar_t *__restrict __src, size_t __n)
+     __THROW;
+
+/* Append SRC onto DEST.  */
+extern wchar_t *wcscat (wchar_t *__restrict __dest,
+			__const wchar_t *__restrict __src) __THROW;
+/* Append no more than N wide-characters of SRC onto DEST.  */
+extern wchar_t *wcsncat (wchar_t *__restrict __dest,
+			 __const wchar_t *__restrict __src, size_t __n)
+     __THROW;
+
+/* Compare S1 and S2.  */
+extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
+     __THROW __attribute_pure__;
+/* Compare N wide-characters of S1 and S2.  */
+extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
+     __THROW __attribute_pure__;
+__END_NAMESPACE_C99
+
+#ifdef __USE_GNU
+/* Compare S1 and S2, ignoring case.  */
+extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) __THROW;
+
+/* Compare no more than N chars of S1 and S2, ignoring case.  */
+extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
+			size_t __n) __THROW;
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+/* Similar to the two functions above but take the information from
+   the provided locale and not the global locale.  */
+# include <xlocale.h>
+
+extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
+			 __locale_t __loc) __THROW;
+extern int __wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
+			 __locale_t __loc) __THROW;
+
+extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
+			  size_t __n, __locale_t __loc) __THROW;
+extern int __wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
+			  size_t __n, __locale_t __loc) __THROW;
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+#endif
+
+__BEGIN_NAMESPACE_C99
+/* Compare S1 and S2, both interpreted as appropriate to the
+   LC_COLLATE category of the current locale.  */
+extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) __THROW;
+/* Transform S2 into array pointed to by S1 such that if wcscmp is
+   applied to two transformed strings the result is the as applying
+   `wcscoll' to the original strings.  */
+extern size_t wcsxfrm (wchar_t *__restrict __s1,
+		       __const wchar_t *__restrict __s2, size_t __n) __THROW;
+__END_NAMESPACE_C99
+
+#ifdef __USE_GNU
+#ifdef __UCLIBC_HAS_XLOCALE__
+/* Similar to the two functions above but take the information from
+   the provided locale and not the global locale.  */
+
+/* Compare S1 and S2, both interpreted as appropriate to the
+   LC_COLLATE category of the given locale.  */
+extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
+		      __locale_t __loc) __THROW;
+extern int __wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
+		      __locale_t __loc) __THROW;
+
+/* Transform S2 into array pointed to by S1 such that if wcscmp is
+   applied to two transformed strings the result is the as applying
+   `wcscoll' to the original strings.  */
+extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
+			 size_t __n, __locale_t __loc) __THROW;
+extern size_t __wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
+			 size_t __n, __locale_t __loc) __THROW;
+
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+
+/* Duplicate S, returning an identical malloc'd string.  */
+extern wchar_t *wcsdup (__const wchar_t *__s) __THROW __attribute_malloc__;
+#endif
+
+__BEGIN_NAMESPACE_C99
+/* Find the first occurrence of WC in WCS.  */
+extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
+     __THROW __attribute_pure__;
+/* Find the last occurrence of WC in WCS.  */
+extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
+     __THROW __attribute_pure__;
+__END_NAMESPACE_C99
+
+#ifdef __USE_GNU
+/* This function is similar to `wcschr'.  But it returns a pointer to
+   the closing NUL wide character in case C is not found in S.  */
+extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
+     __THROW __attribute_pure__;
+#endif
+
+__BEGIN_NAMESPACE_C99
+/* Return the length of the initial segmet of WCS which
+   consists entirely of wide characters not in REJECT.  */
+extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
+     __THROW __attribute_pure__;
+/* Return the length of the initial segmet of WCS which
+   consists entirely of wide characters in  ACCEPT.  */
+extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
+     __THROW __attribute_pure__;
+/* Find the first occurrence in WCS of any character in ACCEPT.  */
+extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
+     __THROW __attribute_pure__;
+/* Find the first occurrence of NEEDLE in HAYSTACK.  */
+extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
+     __THROW __attribute_pure__;
+
+/* Divide WCS into tokens separated by characters in DELIM.  */
+extern wchar_t *wcstok (wchar_t *__restrict __s,
+			__const wchar_t *__restrict __delim,
+			wchar_t **__restrict __ptr) __THROW;
+
+/* Return the number of wide characters in S.  */
+extern size_t wcslen (__const wchar_t *__s) __THROW __attribute_pure__;
+__END_NAMESPACE_C99
+
+#ifdef __USE_XOPEN
+/* Another name for `wcsstr' from XPG4.  */
+extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
+     __THROW __attribute_pure__;
+#endif
+
+#ifdef __USE_GNU
+/* Return the number of wide characters in S, but at most MAXLEN.  */
+extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
+     __THROW __attribute_pure__;
+#endif
+
+
+__BEGIN_NAMESPACE_C99
+/* Search N wide characters of S for C.  */
+extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
+     __THROW __attribute_pure__;
+
+/* Compare N wide characters of S1 and S2.  */
+extern int wmemcmp (__const wchar_t *__restrict __s1,
+		    __const wchar_t *__restrict __s2, size_t __n)
+     __THROW __attribute_pure__;
+
+/* Copy N wide characters of SRC to DEST.  */
+extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
+			 __const wchar_t *__restrict __s2, size_t __n) __THROW;
+
+/* Copy N wide characters of SRC to DEST, guaranteeing
+   correct behavior for overlapping strings.  */
+extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
+     __THROW;
+
+/* Set N wide characters of S to C.  */
+extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __THROW;
+__END_NAMESPACE_C99
+
+#ifdef __USE_GNU
+/* Copy N wide characters of SRC to DEST and return pointer to following
+   wide character.  */
+extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
+			  __const wchar_t *__restrict __s2, size_t __n)
+     __THROW;
+#endif
+
+
+__BEGIN_NAMESPACE_C99
+/* Determine whether C constitutes a valid (one-byte) multibyte
+   character.  */
+extern wint_t btowc (int __c) __THROW;
+
+/* Determine whether C corresponds to a member of the extended
+   character set whose multibyte representation is a single byte.  */
+extern int wctob (wint_t __c) __THROW;
+
+/* Determine whether PS points to an object representing the initial
+   state.  */
+extern int mbsinit (__const mbstate_t *__ps) __THROW __attribute_pure__;
+
+/* Write wide character representation of multibyte character pointed
+   to by S to PWC.  */
+extern size_t mbrtowc (wchar_t *__restrict __pwc,
+		       __const char *__restrict __s, size_t __n,
+		       mbstate_t *__p) __THROW;
+
+/* Write multibyte representation of wide character WC to S.  */
+extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
+		       mbstate_t *__restrict __ps) __THROW;
+
+/* Return number of bytes in multibyte character pointed to by S.  */
+extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
+			mbstate_t *__restrict __ps) __THROW;
+extern size_t mbrlen (__const char *__restrict __s, size_t __n,
+		      mbstate_t *__restrict __ps) __THROW;
+
+/* Write wide character representation of multibyte character string
+   SRC to DST.  */
+extern size_t mbsrtowcs (wchar_t *__restrict __dst,
+			 __const char **__restrict __src, size_t __len,
+			 mbstate_t *__restrict __ps) __THROW;
+
+/* Write multibyte character representation of wide character string
+   SRC to DST.  */
+extern size_t wcsrtombs (char *__restrict __dst,
+			 __const wchar_t **__restrict __src, size_t __len,
+			 mbstate_t *__restrict __ps) __THROW;
+__END_NAMESPACE_C99
+
+
+#ifdef	__USE_GNU
+/* Write wide character representation of at most NMC bytes of the
+   multibyte character string SRC to DST.  */
+extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
+			  __const char **__restrict __src, size_t __nmc,
+			  size_t __len, mbstate_t *__restrict __ps) __THROW;
+
+/* Write multibyte character representation of at most NWC characters
+   from the wide character string SRC to DST.  */
+extern size_t wcsnrtombs (char *__restrict __dst,
+			  __const wchar_t **__restrict __src,
+			  size_t __nwc, size_t __len,
+			  mbstate_t *__restrict __ps) __THROW;
+#endif	/* use GNU */
+
+
+/* The following functions are extensions found in X/Open CAE.  */
+#ifdef __USE_XOPEN
+/* Determine number of column positions required for C.  */
+extern int wcwidth (wchar_t __c) __THROW;
+
+/* Determine number of column positions required for first N wide
+   characters (or fewer if S ends before this) in S.  */
+extern int wcswidth (__const wchar_t *__s, size_t __n) __THROW;
+#endif	/* Use X/Open.  */
+
+
+__BEGIN_NAMESPACE_C99
+#ifdef __UCLIBC_HAS_FLOATS__
+/* Convert initial portion of the wide string NPTR to `double'
+   representation.  */
+extern double wcstod (__const wchar_t *__restrict __nptr,
+		      wchar_t **__restrict __endptr) __THROW;
+
+#ifdef __USE_ISOC99
+/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
+extern float wcstof (__const wchar_t *__restrict __nptr,
+		     wchar_t **__restrict __endptr) __THROW;
+extern long double wcstold (__const wchar_t *__restrict __nptr,
+			    wchar_t **__restrict __endptr) __THROW;
+#endif /* C99 */
+#endif /* __UCLIBC_HAS_FLOATS__ */
+
+
+/* Convert initial portion of wide string NPTR to `long int'
+   representation.  */
+extern long int wcstol (__const wchar_t *__restrict __nptr,
+			wchar_t **__restrict __endptr, int __base) __THROW;
+
+/* Convert initial portion of wide string NPTR to `unsigned long int'
+   representation.  */
+extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
+				  wchar_t **__restrict __endptr, int __base)
+     __THROW;
+
+#if defined __USE_ISOC99 || (defined __GNUC__ && defined __USE_GNU)
+/* Convert initial portion of wide string NPTR to `long int'
+   representation.  */
+__extension__
+extern long long int wcstoll (__const wchar_t *__restrict __nptr,
+			      wchar_t **__restrict __endptr, int __base)
+     __THROW;
+
+/* Convert initial portion of wide string NPTR to `unsigned long long int'
+   representation.  */
+__extension__
+extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
+					wchar_t **__restrict __endptr,
+					int __base) __THROW;
+#endif /* ISO C99 or GCC and GNU.  */
+__END_NAMESPACE_C99
+
+#if defined __GNUC__ && defined __USE_GNU
+/* Convert initial portion of wide string NPTR to `long int'
+   representation.  */
+__extension__
+extern long long int wcstoq (__const wchar_t *__restrict __nptr,
+			     wchar_t **__restrict __endptr, int __base)
+     __THROW;
+
+/* Convert initial portion of wide string NPTR to `unsigned long long int'
+   representation.  */
+__extension__
+extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
+				       wchar_t **__restrict __endptr,
+				       int __base) __THROW;
+#endif /* GCC and use GNU.  */
+
+#ifdef __USE_GNU
+#ifdef __UCLIBC_HAS_XLOCALE__
+/* The concept of one static locale per category is not very well
+   thought out.  Many applications will need to process its data using
+   information from several different locales.  Another application is
+   the implementation of the internationalization handling in the
+   upcoming ISO C++ standard library.  To support this another set of
+   the functions using locale data exist which have an additional
+   argument.
+
+   Attention: all these functions are *not* standardized in any form.
+   This is a proof-of-concept implementation.  */
+
+/* Structure for reentrant locale using functions.  This is an
+   (almost) opaque type for the user level programs.  */
+# include <xlocale.h>
+
+/* Special versions of the functions above which take the locale to
+   use as an additional parameter.  */
+extern long int wcstol_l (__const wchar_t *__restrict __nptr,
+			  wchar_t **__restrict __endptr, int __base,
+			  __locale_t __loc) __THROW;
+extern long int __wcstol_l (__const wchar_t *__restrict __nptr,
+			  wchar_t **__restrict __endptr, int __base,
+			  __locale_t __loc) __THROW;
+
+extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
+				    wchar_t **__restrict __endptr,
+				    int __base, __locale_t __loc) __THROW;
+extern unsigned long int __wcstoul_l (__const wchar_t *__restrict __nptr,
+				    wchar_t **__restrict __endptr,
+				    int __base, __locale_t __loc) __THROW;
+
+__extension__
+extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
+				wchar_t **__restrict __endptr,
+				int __base, __locale_t __loc) __THROW;
+__extension__
+extern long long int __wcstoll_l (__const wchar_t *__restrict __nptr,
+				wchar_t **__restrict __endptr,
+				int __base, __locale_t __loc) __THROW;
+
+__extension__
+extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
+					  wchar_t **__restrict __endptr,
+					  int __base, __locale_t __loc)
+     __THROW;
+__extension__
+extern unsigned long long int __wcstoull_l (__const wchar_t *__restrict __nptr,
+					  wchar_t **__restrict __endptr,
+					  int __base, __locale_t __loc)
+     __THROW;
+
+#ifdef __UCLIBC_HAS_FLOATS__
+extern double wcstod_l (__const wchar_t *__restrict __nptr,
+			wchar_t **__restrict __endptr, __locale_t __loc)
+     __THROW;
+extern double __wcstod_l (__const wchar_t *__restrict __nptr,
+			wchar_t **__restrict __endptr, __locale_t __loc)
+     __THROW;
+
+extern float wcstof_l (__const wchar_t *__restrict __nptr,
+		       wchar_t **__restrict __endptr, __locale_t __loc)
+     __THROW;
+extern float __wcstof_l (__const wchar_t *__restrict __nptr,
+		       wchar_t **__restrict __endptr, __locale_t __loc)
+     __THROW;
+
+extern long double wcstold_l (__const wchar_t *__restrict __nptr,
+			      wchar_t **__restrict __endptr,
+			      __locale_t __loc) __THROW;
+extern long double __wcstold_l (__const wchar_t *__restrict __nptr,
+			      wchar_t **__restrict __endptr,
+			      __locale_t __loc) __THROW;
+#endif /* __UCLIBC_HAS_FLOATS__ */
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+#endif /* GNU */
+
+
+#ifdef	__USE_GNU
+/* Copy SRC to DEST, returning the address of the terminating L'\0' in
+   DEST.  */
+extern wchar_t *wcpcpy (wchar_t *__dest, __const wchar_t *__src) __THROW;
+
+/* Copy no more than N characters of SRC to DEST, returning the address of
+   the last character written into DEST.  */
+extern wchar_t *wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n)
+     __THROW;
+#endif	/* use GNU */
+
+
+/* Wide character I/O functions.  */
+#if defined __USE_ISOC99 || defined __USE_UNIX98
+__BEGIN_NAMESPACE_C99
+
+/* Select orientation for stream.  */
+extern int fwide (__FILE *__fp, int __mode) __THROW;
+
+
+/* Write formatted output to STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fwprintf (__FILE *__restrict __stream,
+		     __const wchar_t *__restrict __format, ...)
+     /* __attribute__ ((__format__ (__wprintf__, 2, 3))) */;
+/* Write formatted output to stdout.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int wprintf (__const wchar_t *__restrict __format, ...)
+     /* __attribute__ ((__format__ (__wprintf__, 1, 2))) */;
+/* Write formatted output of at most N characters to S.  */
+extern int swprintf (wchar_t *__restrict __s, size_t __n,
+		     __const wchar_t *__restrict __format, ...)
+     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 4))) */;
+
+/* Write formatted output to S from argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vfwprintf (__FILE *__restrict __s,
+		      __const wchar_t *__restrict __format,
+		      __gnuc_va_list __arg)
+     /* __attribute__ ((__format__ (__wprintf__, 2, 0))) */;
+/* Write formatted output to stdout from argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vwprintf (__const wchar_t *__restrict __format,
+		     __gnuc_va_list __arg)
+     /* __attribute__ ((__format__ (__wprintf__, 1, 0))) */;
+/* Write formatted output of at most N character to S from argument
+   list ARG.  */
+extern int vswprintf (wchar_t *__restrict __s, size_t __n,
+		      __const wchar_t *__restrict __format,
+		      __gnuc_va_list __arg)
+     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 0))) */;
+
+
+/* Read formatted input from STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fwscanf (__FILE *__restrict __stream,
+		    __const wchar_t *__restrict __format, ...)
+     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
+/* Read formatted input from stdin.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int wscanf (__const wchar_t *__restrict __format, ...)
+     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
+/* Read formatted input from S.  */
+extern int swscanf (__const wchar_t *__restrict __s,
+		    __const wchar_t *__restrict __format, ...)
+     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
+
+__END_NAMESPACE_C99
+#endif /* Use ISO C99 and Unix98. */
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+
+/* Read formatted input from S into argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vfwscanf (__FILE *__restrict __s,
+		     __const wchar_t *__restrict __format,
+		     __gnuc_va_list __arg)
+     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
+/* Read formatted input from stdin into argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vwscanf (__const wchar_t *__restrict __format,
+		    __gnuc_va_list __arg)
+     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
+/* Read formatted input from S into argument list ARG.  */
+extern int vswscanf (__const wchar_t *__restrict __s,
+		     __const wchar_t *__restrict __format,
+		     __gnuc_va_list __arg)
+     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
+
+__END_NAMESPACE_C99
+#endif /* Use ISO C99. */
+
+
+__BEGIN_NAMESPACE_C99
+/* Read a character from STREAM.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.  */
+extern wint_t fgetwc (__FILE *__stream);
+extern wint_t getwc (__FILE *__stream);
+
+/* Read a character from stdin.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern wint_t getwchar (void);
+
+
+/* Write a character to STREAM.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.  */
+extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
+extern wint_t putwc (wchar_t __wc, __FILE *__stream);
+
+/* Write a character to stdout.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+extern wint_t putwchar (wchar_t __wc);
+
+
+/* Get a newline-terminated wide character string of finite length
+   from STREAM.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
+			__FILE *__restrict __stream);
+
+/* Write a string to STREAM.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+extern int fputws (__const wchar_t *__restrict __ws,
+		   __FILE *__restrict __stream);
+
+
+/* Push a character back onto the input buffer of STREAM.
+
+   This function is a possible cancellation points and therefore not
+   marked with __THROW.  */
+extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
+__END_NAMESPACE_C99
+
+
+#ifdef __USE_GNU
+/* These are defined to be equivalent to the `char' functions defined
+   in POSIX.1:1996.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern wint_t getwc_unlocked (__FILE *__stream);
+extern wint_t getwchar_unlocked (void);
+
+/* This is the wide character version of a GNU extension.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern wint_t fgetwc_unlocked (__FILE *__stream);
+
+/* Faster version when locking is not necessary.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
+
+/* These are defined to be equivalent to the `char' functions defined
+   in POSIX.1:1996.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
+extern wint_t putwchar_unlocked (wchar_t __wc);
+
+
+/* This function does the same as `fgetws' but does not lock the stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
+				 __FILE *__restrict __stream);
+
+/* This function does the same as `fputws' but does not lock the stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fputws_unlocked (__const wchar_t *__restrict __ws,
+			    __FILE *__restrict __stream);
+#endif
+
+
+__BEGIN_NAMESPACE_C99
+/* Format TP into S according to FORMAT.
+   Write no more than MAXSIZE wide characters and return the number
+   of wide characters written, or 0 if it would exceed MAXSIZE.  */
+extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
+			__const wchar_t *__restrict __format,
+			__const struct tm *__restrict __tp) __THROW;
+__END_NAMESPACE_C99
+
+# ifdef __USE_GNU
+#ifdef __UCLIBC_HAS_XLOCALE__
+# include <xlocale.h>
+
+/* Similar to `wcsftime' but takes the information from
+   the provided locale and not the global locale.  */
+extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
+			  __const wchar_t *__restrict __format,
+			  __const struct tm *__restrict __tp,
+			  __locale_t __loc) __THROW;
+extern size_t __wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
+			  __const wchar_t *__restrict __format,
+			  __const struct tm *__restrict __tp,
+			  __locale_t __loc) __THROW;
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+# endif
+
+/* The X/Open standard demands that most of the functions defined in
+   the <wctype.h> header must also appear here.  This is probably
+   because some X/Open members wrote their implementation before the
+   ISO C standard was published and introduced the better solution.
+   We have to provide these definitions for compliance reasons but we
+   do this nonsense only if really necessary.  */
+#if defined __USE_UNIX98 && !defined __USE_GNU
+# define __need_iswxxx
+# include <wctype.h>
+#endif
+
+__END_DECLS
+
+#endif	/* _WCHAR_H defined */
+
+#endif /* wchar.h  */
diff -pruwN busybox-1.01/.indent.pro busybox-1.01-livebox/.indent.pro
--- busybox-1.01/.indent.pro	2005-08-17 03:29:17.000000000 +0200
+++ busybox-1.01-livebox/.indent.pro	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -pruwN busybox-1.01/init/init.c busybox-1.01-livebox/init/init.c
--- busybox-1.01/init/init.c	2005-08-17 03:29:16.000000000 +0200
+++ busybox-1.01-livebox/init/init.c	2011-02-01 13:48:39.000000000 +0100
@@ -429,11 +429,13 @@ static pid_t run(const struct init_actio
 	char *s, *tmpCmd, *cmd[INIT_BUFFS_SIZE], *cmdpath;
 	char buf[INIT_BUFFS_SIZE + 6];	/* INIT_BUFFS_SIZE+strlen("exec ")+1 */
 	sigset_t nmask, omask;
+#if !defined(__UCLIBC__) || defined(__ARCH_HAS_MMU__)
 	static const char press_enter[] =
 #ifdef CUSTOMIZED_BANNER
 #include CUSTOMIZED_BANNER
 #endif
 		"\nPlease press Enter to activate this console. ";
+#endif
 
 	/* Block sigchild while forking.  */
 	sigemptyset(&nmask);
@@ -976,9 +978,11 @@ static void parse_inittab(void)
 		new_init_action(RESTART, "/sbin/init", "");
 		/* Askfirst shell on tty1-4 */
 		new_init_action(ASKFIRST, bb_default_login_shell, "");
+#if 0
 		new_init_action(ASKFIRST, bb_default_login_shell, VC_2);
 		new_init_action(ASKFIRST, bb_default_login_shell, VC_3);
 		new_init_action(ASKFIRST, bb_default_login_shell, VC_4);
+#endif
 		/* sysinit */
 		new_init_action(SYSINIT, INIT_SCRIPT, "");
 
diff -pruwN busybox-1.01/libbb/procps.c busybox-1.01-livebox/libbb/procps.c
--- busybox-1.01/libbb/procps.c	2005-08-17 03:29:14.000000000 +0200
+++ busybox-1.01-livebox/libbb/procps.c	2011-02-01 13:48:39.000000000 +0100
@@ -16,6 +16,9 @@
 
 #include "libbb.h"
 
+#undef PAGE_SHIFT
+#define PAGE_SHIFT 12
+
 extern procps_status_t * procps_scan(int save_user_arg0
 #ifdef CONFIG_SELINUX
 	, int use_selinux , security_id_t *sid
diff -pruwN busybox-1.01/libbb/procps.c.orig busybox-1.01-livebox/libbb/procps.c.orig
--- busybox-1.01/libbb/procps.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/libbb/procps.c.orig	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,158 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Utility routines.
+ *
+ * Copyright 1998 by Albert Cahalan; all rights reserved.
+ * Copyright (C) 2002 by Vladimir Oleynik <dzo@simtreas.ru>
+ * GNU Library General Public License Version 2, or any later version
+ *
+ */
+
+#include <dirent.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <asm/page.h>
+
+#include "libbb.h"
+
+extern procps_status_t * procps_scan(int save_user_arg0
+#ifdef CONFIG_SELINUX
+	, int use_selinux , security_id_t *sid
+#endif
+	)
+{
+	static DIR *dir;
+	struct dirent *entry;
+	static procps_status_t ret_status;
+	char *name;
+	int n;
+	char status[32];
+	char buf[1024];
+	FILE *fp;
+	procps_status_t curstatus;
+	int pid;
+	long tasknice;
+	struct stat sb;
+
+	if (!dir) {
+		dir = opendir("/proc");
+		if(!dir)
+			bb_error_msg_and_die("Can't open /proc");
+	}
+	for(;;) {
+		if((entry = readdir(dir)) == NULL) {
+			closedir(dir);
+			dir = 0;
+			return 0;
+		}
+		name = entry->d_name;
+		if (!(*name >= '0' && *name <= '9'))
+			continue;
+
+		memset(&curstatus, 0, sizeof(procps_status_t));
+		pid = atoi(name);
+		curstatus.pid = pid;
+
+		sprintf(status, "/proc/%d", pid);
+		if(stat(status, &sb))
+			continue;
+		my_getpwuid(curstatus.user, sb.st_uid, sizeof(curstatus.user));
+
+		sprintf(status, "/proc/%d/stat", pid);
+		if((fp = fopen(status, "r")) == NULL)
+			continue;
+#ifdef CONFIG_SELINUX
+		if(use_selinux)
+		{
+			if(fstat_secure(fileno(fp), &sb, sid))
+				continue;
+		}
+		else
+#endif
+		name = fgets(buf, sizeof(buf), fp);
+		fclose(fp);
+		if(name == NULL)
+			continue;
+		name = strrchr(buf, ')'); /* split into "PID (cmd" and "<rest>" */
+		if(name == 0 || name[1] != ' ')
+			continue;
+		*name = 0;
+		sscanf(buf, "%*s (%15c", curstatus.short_cmd);
+		n = sscanf(name+2,
+		"%c %d "
+		"%*s %*s %*s %*s "     /* pgrp, session, tty, tpgid */
+		"%*s %*s %*s %*s %*s " /* flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
+#ifdef FEATURE_CPU_USAGE_PERCENTAGE
+		"%lu %lu "
+#else
+		"%*s %*s "
+#endif
+		"%*s %*s %*s "         /* cutime, cstime, priority */
+		"%ld "
+		"%*s %*s %*s "         /* timeout, it_real_value, start_time */
+		"%*s "                 /* vsize */
+		"%ld",
+		curstatus.state, &curstatus.ppid,
+#ifdef FEATURE_CPU_USAGE_PERCENTAGE
+		&curstatus.utime, &curstatus.stime,
+#endif
+		&tasknice,
+		&curstatus.rss);
+#ifdef FEATURE_CPU_USAGE_PERCENTAGE
+		if(n != 6)
+#else
+		if(n != 4)
+#endif
+			continue;
+
+		if (curstatus.rss == 0 && curstatus.state[0] != 'Z')
+			curstatus.state[1] = 'W';
+		else
+			curstatus.state[1] = ' ';
+		if (tasknice < 0)
+			curstatus.state[2] = '<';
+		else if (tasknice > 0)
+			curstatus.state[2] = 'N';
+		else
+			curstatus.state[2] = ' ';
+
+#ifdef PAGE_SHIFT
+		curstatus.rss <<= (PAGE_SHIFT - 10);     /* 2**10 = 1kb */
+#else
+		curstatus.rss *= (getpagesize() >> 10);     /* 2**10 = 1kb */
+#endif
+
+		if(save_user_arg0) {
+			sprintf(status, "/proc/%d/cmdline", pid);
+			if((fp = fopen(status, "r")) == NULL)
+				continue;
+			if((n=fread(buf, 1, sizeof(buf)-1, fp)) > 0) {
+				if(buf[n-1]=='\n')
+					buf[--n] = 0;
+				name = buf;
+				while(n) {
+					if(((unsigned char)*name) < ' ')
+						*name = ' ';
+					name++;
+					n--;
+				}
+				*name = 0;
+				if(buf[0])
+					curstatus.cmd = strdup(buf);
+				/* if NULL it work true also */
+			}
+			fclose(fp);
+		}
+		return memcpy(&ret_status, &curstatus, sizeof(procps_status_t));
+	}
+}
+
+/* END CODE */
+/*
+Local Variables:
+c-file-style: "linux"
+c-basic-offset: 4
+tab-width: 4
+End:
+*/
diff -pruwN busybox-1.01/Makefile busybox-1.01-livebox/Makefile
--- busybox-1.01/Makefile	2005-08-17 03:29:17.000000000 +0200
+++ busybox-1.01-livebox/Makefile	2011-02-01 13:48:39.000000000 +0100
@@ -125,7 +125,7 @@ include $(patsubst %,%/Makefile.in, $(SR
 
 busybox: $(ALL_MAKEFILES) .depend include/config.h $(libraries-y)
 	$(CC) $(LDFLAGS) -o $@ -Wl,--start-group $(libraries-y) $(LIBRARIES) -Wl,--end-group
-	$(STRIPCMD) $@
+	$(STRIPCMD) -o $@.stripped $@
 
 busybox.links: $(top_srcdir)/applets/busybox.mkll include/config.h $(top_srcdir)/include/applets.h
 	- $(SHELL) $^ >$@
diff -pruwN busybox-1.01/modutils/insmod.c busybox-1.01-livebox/modutils/insmod.c
--- busybox-1.01/modutils/insmod.c	2005-08-17 03:29:11.000000000 +0200
+++ busybox-1.01-livebox/modutils/insmod.c	2011-02-01 13:48:39.000000000 +0100
@@ -71,6 +71,7 @@
  *
  */
 
+#include "busybox.h"
 #include <stdlib.h>
 #include <stdio.h>
 #include <stddef.h>
@@ -83,7 +84,11 @@
 #include <getopt.h>
 #include <fcntl.h>
 #include <sys/utsname.h>
-#include "busybox.h"
+#ifdef CONFIG_FEATURE_2_4_MODULES
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <linux/module.h>
+#endif
 
 #if !defined(CONFIG_FEATURE_2_4_MODULES) && \
 	!defined(CONFIG_FEATURE_2_6_MODULES)
@@ -278,6 +283,11 @@ extern int insmod_ng_main( int argc, cha
 #error Sorry, but insmod.c does not yet support this architecture...
 #endif
 
+#if defined(__mips__)
+#define is_shn_common(shndx) ((shndx)==SHN_COMMON || (shndx)==SHN_MIPS_SCOMMON)
+#else
+#define is_shn_common(shndx) ((shndx)==SHN_COMMON)
+#endif
 
 //----------------------------------------------------------------------------
 //--------modutils module.h, lines 45-242
@@ -308,7 +318,7 @@ extern int insmod_ng_main( int argc, cha
 #ifndef MODUTILS_MODULE_H
 static const int MODUTILS_MODULE_H = 1;
 
-#ident "$Id: insmod.c,v 1.125 2004/09/02 23:03:25 andersen Exp $"
+#ident "$Id: insmod.c,v 1.1.4.1.2.2 2005/11/15 22:23:54 alex Exp $"
 
 /*======================================================================*/
 /* For sizeof() which are related to the module platform and not to the
@@ -414,14 +424,6 @@ int init_module(const char *name, const
 int query_module(const char *name, int which, void *buf,
 		size_t bufsize, size_t *ret);
 
-/* Values for query_module's which.  */
-
-static const int QM_MODULES = 1;
-static const int QM_DEPS = 2;
-static const int QM_REFS = 3;
-static const int QM_SYMBOLS = 4;
-static const int QM_INFO = 5;
-
 /*======================================================================*/
 /* The system calls unchanged between 2.0 and 2.1.  */
 
@@ -466,7 +468,7 @@ int delete_module(const char *);
 #ifndef MODUTILS_OBJ_H
 static const int MODUTILS_OBJ_H = 1;
 
-#ident "$Id: insmod.c,v 1.125 2004/09/02 23:03:25 andersen Exp $"
+#ident "$Id: insmod.c,v 1.1.4.1.2.2 2005/11/15 22:23:54 alex Exp $"
 
 /* The relocatable object is manipulated using elfin types.  */
 
@@ -618,7 +620,7 @@ static void obj_allocate_commons(struct
 
 static unsigned long obj_load_size (struct obj_file *f);
 
-static int obj_relocate (struct obj_file *f, ElfW(Addr) base);
+static int obj_relocate (struct obj_file *f, ElfW(Addr) base, char *m_name);
 
 static struct obj_file *obj_load(FILE *f, int loadprogbits);
 
@@ -640,7 +642,9 @@ static enum obj_reloc arch_apply_relocat
 
 static void arch_create_got (struct obj_file *f);
 
+#ifdef CONFIG_FEATURE_CHECK_TAINTED_MODULE
 static int obj_gpl_license(struct obj_file *f, const char **license);
+#endif
 
 #endif /* obj.h */
 //----------------------------------------------------------------------------
@@ -657,6 +661,7 @@ static int obj_gpl_license(struct obj_fi
 
 
 #define _PATH_MODULES	"/lib/modules"
+#define KMEM_DEV "/dev/kmem"
 static const int STRVERSIONLEN = 32;
 
 /*======================================================================*/
@@ -1769,10 +1774,10 @@ obj_add_symbol(struct obj_file *f, const
 				goto found;
 			/* Don't unify COMMON symbols with object types the programmer
 			   doesn't expect.  */
-			else if (secidx == SHN_COMMON
+			else if (is_shn_common(secidx)
 					&& (o_type == STT_NOTYPE || o_type == STT_OBJECT))
 				return sym;
-			else if (o_secidx == SHN_COMMON
+			else if (is_shn_common(o_secidx)
 					&& (n_type == STT_NOTYPE || n_type == STT_OBJECT))
 				goto found;
 			else {
@@ -2583,11 +2588,11 @@ static int new_create_module_ksymtab(str
 
 
 static int
-new_init_module(const char *m_name, struct obj_file *f, unsigned long m_size)
+new_init_module(const char *m_name, struct obj_file *f, unsigned long m_size,
+	void *image)
 {
 	struct new_module *module;
 	struct obj_section *sec;
-	void *image;
 	int ret;
 	tgt_long m_addr;
 
@@ -2649,15 +2654,13 @@ new_init_module(const char *m_name, stru
 	/* Whew!  All of the initialization is complete.  Collect the final
 	   module image and give it to the kernel.  */
 
-	image = xmalloc(m_size);
-	obj_create_image(f, image);
+	if (obj_create_image(f, image) < 0)
+		return 0;
 
 	ret = init_module(m_name, (struct new_module *) image);
 	if (ret)
 		bb_perror_msg("init_module: %s", m_name);
 
-	free(image);
-
 	return ret == 0;
 }
 
@@ -2745,7 +2748,7 @@ static void obj_allocate_commons(struct
 	for (i = 0; i < HASH_BUCKETS; ++i) {
 		struct obj_symbol *sym;
 		for (sym = f->symtab[i]; sym; sym = sym->next)
-			if (sym->secidx == SHN_COMMON) {
+			if (is_shn_common(sym->secidx)) {
 				/* Collect all COMMON symbols and sort them by size so as to
 				   minimize space wasted by alignment requirements.  */
 				{
@@ -2764,7 +2767,7 @@ static void obj_allocate_commons(struct
 
 	for (i = 1; i < f->local_symtab_size; ++i) {
 		struct obj_symbol *sym = f->local_symtab[i];
-		if (sym && sym->secidx == SHN_COMMON) {
+		if (sym && is_shn_common(sym->secidx)) {
 			struct common_entry **p, *n;
 			for (p = &common_head; *p; p = &(*p)->next)
 				if (sym == (*p)->sym)
@@ -2863,7 +2866,7 @@ static unsigned long obj_load_size(struc
 	return dot;
 }
 
-static int obj_relocate(struct obj_file *f, ElfW(Addr) base)
+static int obj_relocate(struct obj_file *f, ElfW(Addr) base, char *m_name)
 {
 	int i, n = f->header.e_shnum;
 	int ret = 1;
@@ -2874,6 +2877,42 @@ static int obj_relocate(struct obj_file
 	for (i = 0; i < n; ++i)
 		f->sections[i]->header.sh_addr += base;
 
+#ifdef CONFIG_RG_KGDB
+	/* DEBUG: Print a command for gdb to add module symbols to debug modules */
+	if (!cCONFIG_RG_INSMOD_SILENT)
+	{
+		tgt_long bss = 0;
+		tgt_long data = 0;
+		tgt_long text = 0;
+
+		for (i = 0; i < n; ++i)
+		{
+			char *secname = (char *)f->sections[i]->name;
+
+			if (!secname)
+				continue;
+			
+			if (!strcmp(secname, ".data"))
+				data = f->sections[i]->header.sh_addr;
+			else if (!strcmp(secname, ".text"))
+				text = f->sections[i]->header.sh_addr;
+			else if (!strcmp(secname, ".bss"))
+				bss = f->sections[i]->header.sh_addr;
+		}
+
+		if (text)
+			printf("insmod: add-symbol-file PATH/%s.o %#lx", m_name, text);
+		else
+			printf("insmod: no text section for module %s", m_name);
+		
+		if (data)
+			printf(" -s .data %#lx", data);
+		if (bss)
+			printf(" -s .bss %#lx", bss);
+		printf("\n");
+	}
+#endif
+
 	/* And iterate over all of the relocations.  */
 
 	for (i = 0; i < n; ++i) {
@@ -2995,9 +3034,26 @@ bad_reloc:
 
 static int obj_create_image(struct obj_file *f, char *image)
 {
+	int rc = 0, mem_fd;
 	struct obj_section *sec;
 	ElfW(Addr) base = f->baseaddr;
 
+	/* By default, we try to allocate the module image directly in kernel
+	 * space to save memory.
+	 */
+	mem_fd = open(KMEM_DEV, O_RDWR | O_SYNC);
+	if (mem_fd < 0)
+	{
+		fprintf(stderr, "insmod: Error opening %s. resorting to default insmod "
+			"behaviour\n", KMEM_DEV);
+		rc = 1;
+	}
+	else
+	{
+		sec = obj_find_section(f, ".this");
+		((struct module *)sec->contents)->flags |= MOD_KERN_MEM;
+	}
+
 	for (sec = f->load_order; sec; sec = sec->load_next) {
 		char *secimg;
 
@@ -3006,11 +3062,36 @@ static int obj_create_image(struct obj_f
 
 		secimg = image + (sec->header.sh_addr - base);
 
+		if (rc==1)
+		{
 		/* Note that we allocated data for NOBITS sections earlier.  */
 		memcpy(secimg, sec->contents, sec->header.sh_size);
 	}
+		else
+		{
+			int offset, written;
 
-	return 1;
+			/* we must not overwrite the first 2 fields of the 'struct module'
+			 * in the kernel space. Otherwise we will over-write the 'next'
+			 * field and will destroy the kernel`s "module_list".
+			 */
+			offset = secimg==image ? sizeof(long unsigned int) +
+				sizeof(struct module *) : 0;
+			lseek(mem_fd, (off_t)secimg + offset, SEEK_SET);
+			written = write(mem_fd, sec->contents+offset,
+				sec->header.sh_size-offset);
+			if (written!=sec->header.sh_size-offset)
+			{
+				printf("insmod: error writing to %s.\n", KMEM_DEV);
+				rc = -1;
+				break;
+			}
+		}
+	}
+	if (mem_fd > 0)
+		close(mem_fd);
+
+	return rc;
 }
 
 /*======================================================================*/
@@ -3180,7 +3261,11 @@ static struct obj_file *obj_load(FILE *
 					sym = (ElfW(Sym) *) sec->contents;
 
 					/* Allocate space for a table of local symbols.  */
+#ifdef __mips__
+					j = f->local_symtab_size = nsym; 
+#else
 					j = f->local_symtab_size = sec->header.sh_info;
+#endif
 					f->local_symtab = xcalloc(j, sizeof(struct obj_symbol *));
 
 					/* Insert all symbols into the hash table.  */
@@ -3793,7 +3878,7 @@ extern int insmod_main( int argc, char *
 	} else
 		m_filename = bb_xstrdup(argv[optind]);
 
-	if (!flag_quiet)
+	if (flag_verbose)
 		printf("Using %s\n", m_filename);
 
 #ifdef CONFIG_FEATURE_2_6_MODULES
@@ -3927,12 +4012,12 @@ extern int insmod_main( int argc, char *
 	}
 #endif
 
-	if (!obj_relocate(f, m_addr)) {
+	if (!obj_relocate(f, m_addr, m_name)) {
 		delete_module(m_name);
 		goto out;
 	}
 
-	if (!new_init_module(m_name, f, m_size))
+	if (!new_init_module(m_name, f, m_size, (void *)m_addr))
 	{
 		delete_module(m_name);
 		goto out;
@@ -3946,6 +4031,8 @@ extern int insmod_main( int argc, char *
 	exit_status = EXIT_SUCCESS;
 
 out:
+	if (exit_status == EXIT_FAILURE)
+		printf("insmod: failed loading module %s\n", m_name);
 #ifdef CONFIG_FEATURE_CLEAN_UP
 	if(fp)
 		fclose(fp);
@@ -3966,7 +4053,6 @@ out:
 #ifdef CONFIG_FEATURE_2_6_MODULES
 
 #include <sys/mman.h>
-#include <asm/unistd.h>
 #include <sys/syscall.h>
 
 /* We use error numbers in a loose translation... */
diff -pruwN busybox-1.01/modutils/lsmod.c busybox-1.01-livebox/modutils/lsmod.c
--- busybox-1.01/modutils/lsmod.c	2005-08-17 03:29:11.000000000 +0200
+++ busybox-1.01-livebox/modutils/lsmod.c	2011-02-01 13:48:39.000000000 +0100
@@ -103,13 +103,13 @@ extern int lsmod_main(int argc, char **a
 	char *module_names, *mn, *deps, *dn;
 	size_t bufsize, depsize, nmod, count, i, j;
 
-	module_names = xmalloc(bufsize = 256);
+	module_names = xmalloc(bufsize = 512);
 	if (my_query_module(NULL, QM_MODULES, (void **)&module_names, &bufsize,
 				&nmod)) {
 		bb_perror_msg_and_die("QM_MODULES");
 	}
 
-	deps = xmalloc(depsize = 256);
+	deps = xmalloc(depsize = 512);
 	printf("Module                  Size  Used by");
 	check_tainted();
 
@@ -164,10 +164,52 @@ extern int lsmod_main(int argc, char **a
 {
 	printf("Module                  Size  Used by");
 	check_tainted();
+#if defined(CONFIG_FEATURE_2_6_MODULES)
+	{
+	  FILE *file;
+	  char line[4096];
+
+	  file = fopen("/proc/modules", "r");
 
+	  if (!file) 
+	    bb_error_msg_and_die("Opening /proc/modules");
+
+	  while (fgets(line, sizeof(line), file)) {
+	    char *tok;
+	    
+	    tok = strtok(line, " \t");
+	    printf("%-19s", tok);
+	    tok = strtok(NULL, " \t\n");
+	    printf(" %8s", tok);
+	    tok = strtok(NULL, " \t\n");
+	    /* Null if no module unloading support. */
+	    if (tok) {
+	      printf("  %s", tok);
+	      tok = strtok(NULL, "\n");
+	      if (!tok)
+		tok = "";
+	      /* New-style has commas, or -.  If so,
+		 truncate (other fields might follow). */
+	      else if (strchr(tok, ',')) {
+		tok = strtok(tok, "\t ");
+		/* Strip trailing comma. */
+		if (tok[strlen(tok)-1] == ',')
+		  tok[strlen(tok)-1] = '\0';
+	      } else if (tok[0] == '-'
+			 && (tok[1] == '\0' || isspace(tok[1])))
+		tok = "";
+	      printf(" %s", tok);
+	    }
+	    printf("\n");
+	  }
+	  fclose(file);
+	  return 0;
+	}
+#else
 	if (bb_xprint_file_by_name("/proc/modules") < 0) {
 		return 0;
 	}
+#endif  /*  CONFIG_FEATURE_2_6_MODULES  */
 	return 1;
 }
 
diff -pruwN busybox-1.01/Rules.mak busybox-1.01-livebox/Rules.mak
--- busybox-1.01/Rules.mak	2005-08-17 03:29:17.000000000 +0200
+++ busybox-1.01-livebox/Rules.mak	2011-02-01 13:48:39.000000000 +0100
@@ -80,7 +80,7 @@ BB_SRC_DIR=
 #GCCINCDIR:=$(shell gcc -print-search-dirs | sed -ne "s/install: \(.*\)/\1include/gp")
 
 WARNINGS=-Wall -Wstrict-prototypes -Wshadow
-CFLAGS=-I$(top_builddir)/include -I$(top_srcdir)/include -I$(srcdir)
+CFLAGS=-I$(top_builddir)/include -I$(top_builddir)/include2 -I$(top_srcdir)/include -I$(srcdir)
 ARFLAGS=cru
 
 #--------------------------------------------------------
Les fichiers binaires busybox-1.01/scripts/.fuse_hidden0000129f00000001 et busybox-1.01-livebox/scripts/.fuse_hidden0000129f00000001 sont diffrents.
Les fichiers binaires busybox-1.01/scripts/.nfs0000000000a3fab100a08ab9 et busybox-1.01-livebox/scripts/.nfs0000000000a3fab100a08ab9 sont diffrents.
diff -pruwN busybox-1.01/shell/ash.c busybox-1.01-livebox/shell/ash.c
--- busybox-1.01/shell/ash.c	2005-08-17 03:29:12.000000000 +0200
+++ busybox-1.01-livebox/shell/ash.c	2011-02-01 13:48:39.000000000 +0100
@@ -59,7 +59,7 @@
 
 #define IFS_BROKEN
 
-#define PROFILE 0
+#define PROFILE_BUSYBOX 0
 
 #ifdef DEBUG
 #define _GNU_SOURCE
@@ -7866,7 +7866,7 @@ changemail(const char *val)
 /*      $NetBSD: main.c,v 1.46 2002/12/11 19:12:18 christos Exp $       */
 
 
-#if PROFILE
+#if PROFILE_BUSYBOX
 static short profile_buf[16384];
 extern int etext();
 #endif
@@ -7895,7 +7895,7 @@ ash_main(int argc, char **argv)
 	dash_errno = __errno_location();
 #endif
 
-#if PROFILE
+#if PROFILE_BUSYBOX
 	monitor(4, etext, profile_buf, sizeof profile_buf, 50);
 #endif
 	state = 0;
@@ -8004,7 +8004,7 @@ state3:
 state4: /* XXX ??? - why isn't this before the "if" statement */
 		cmdloop(1);
 	}
-#if PROFILE
+#if PROFILE_BUSYBOX
 	monitor(0);
 #endif
 #if GPROF
diff -pruwN busybox-1.01/shell/lash.c busybox-1.01-livebox/shell/lash.c
--- busybox-1.01/shell/lash.c	2005-08-17 03:29:12.000000000 +0200
+++ busybox-1.01-livebox/shell/lash.c	2011-02-01 13:48:39.000000000 +0100
@@ -382,11 +382,76 @@ static int builtin_pwd(struct child_prog
 	return EXIT_SUCCESS;
 }
 
+/* var is in var=value format. For example: IS_TEST=1 */
+typedef struct var_list_t {
+	struct var_list_t *next;
+	char *var;
+} var_list_t;
+
+static var_list_t *export_vars;
+
+static void del_export_var(char *var)
+{
+	var_list_t *t, **v;
+	char *s;
+	int namelen, cmplen;
+	
+	s = strchr(var, '=');
+	
+	namelen = s ? s - var : strlen(var);
+	/* search for var */
+	for (v = &export_vars; *v; v = &(*v)->next)
+	{
+		s = strchr((*v)->var, '=');
+		cmplen = s ? s - (*v)->var : strlen((*v)->var);
+		if (cmplen == namelen && !strncmp((*v)->var, var, cmplen))
+			break;
+	}
+	/* check if found */
+	if (!*v)
+		return;
+	/* remove it */
+	t = *v;
+	*v = (*v)->next;
+	free(t->var);
+	free(t);
+}
+
+static var_list_t *new_export_var(char *var)
+{
+	var_list_t *new;
+
+	if (!(new = malloc(sizeof(*new))))
+		return NULL;
+	if (!(new->var = strdup(var)))
+	{
+		free(new);
+		return NULL;
+	}
+	new->next = NULL;
+	return new;
+}
+
+int atexit_set;
+static void free_export_vars(void)
+{
+	var_list_t *v;
+	
+	while(export_vars)
+	{
+		v = export_vars;
+		export_vars = export_vars->next;
+		free(v->var);
+		free(v);
+	}
+}
+
 /* built-in 'export VAR=value' handler */
 static int builtin_export(struct child_prog *child)
 {
 	int res;
 	char *v = child->argv[1];
+	var_list_t *t;
 
 	if (v == NULL) {
 		char **e;
@@ -395,7 +460,35 @@ static int builtin_export(struct child_p
 		}
 		return 0;
 	}
-	res = putenv(v);
+
+	/* We do: create new entry, putenv and then add to list, because we do not
+	 * want putenv to have a set variable that is not allocated.
+	 */
+	if (!(t = new_export_var(v)))
+	{
+		fprintf(stderr, "export: %m\n");
+		return 1;
+	}
+
+	res = putenv(t->var);
+	if (res)
+	{
+		free(t->var);
+		free(t);
+	}
+	else
+	{
+		del_export_var(v);
+		t->next = export_vars;
+		export_vars = t;
+		
+		if (!atexit_set)
+		{
+			atexit(free_export_vars);
+			atexit_set = 1;
+		}
+	}
+
 	if (res)
 		fprintf(stderr, "export: %m\n");
 #ifdef CONFIG_FEATURE_SH_FANCY_PROMPT
@@ -1339,6 +1432,8 @@ static void insert_job(struct job *newjo
 		/* suppress messages when run from /linuxrc mag@sysgo.de */
 		if (tcsetpgrp(shell_terminal, newjob->pgrp) && errno != ENOTTY)
 			bb_perror_msg("tcsetpgrp");
+		/* Tell the child to continue if got SIGTTIN */
+		kill(newjob->pgrp, SIGCONT);
 	}
 #endif
 }
@@ -1346,7 +1441,7 @@ static void insert_job(struct job *newjo
 static int run_command(struct job *newjob, int inbg, int outpipe[2])
 {
 	/* struct job *thejob; */
-	int i;
+	int i, leader;
 	int nextin, nextout;
 	int pipefds[2];				/* pipefd[0] is for reading */
 	struct built_in_command *x;
@@ -1393,6 +1488,15 @@ static int run_command(struct job *newjo
 		if (!(child->pid = vfork()))
 #endif
 		{
+			/* Put the process into first ID's group */
+			leader = i ? newjob->progs[0].pid : 0;
+
+			if (setpgid(0,0))
+			{
+				perror("Can't setpgid");
+				exit(1);
+			}
+
 			/* Set the handling for job control signals back to the default.  */
 			signal(SIGINT, SIG_DFL);
 			signal(SIGQUIT, SIG_DFL);
@@ -1500,8 +1604,12 @@ static int busy_loop(FILE * input)
 		} else {
 			/* a job is running in the foreground; wait for it */
 			i = 0;
-			while (!job_list.fg->progs[i].pid ||
-				   job_list.fg->progs[i].is_stopped == 1) i++;
+			while ((i < job_list.fg->num_progs) && 
+				(!job_list.fg->progs[i].pid || 
+				job_list.fg->progs[i].is_stopped == 1))
+			{
+				i++;
+			}
 
 			if (waitpid(job_list.fg->progs[i].pid, &status, WUNTRACED)<0) {
 				if (errno != ECHILD) {
diff -pruwN busybox-1.01/util-linux/boot.c busybox-1.01-livebox/util-linux/boot.c
--- busybox-1.01/util-linux/boot.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/boot.c	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,370 @@
+/* boot.c  -  Read and analyze ia PC/MS-DOS boot sector */
+
+/* Written 1993 by Werner Almesberger */
+
+/* FAT32, VFAT, Atari format support, and various fixes additions May 1998
+ * by Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de> */
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+
+#include "common.h"
+#include "dosfsck.h"
+#include "io.h"
+#include "boot.h"
+
+
+#define ROUND_TO_MULTIPLE(n,m) ((n) && (m) ? (n)+(m)-1-((n)-1)%(m) : 0)
+    /* don't divide by zero */
+
+static struct {
+    __u8 media;
+    char *descr;
+} mediabytes[] = {
+    { 0xf0, "5.25\" or 3.5\" HD floppy" },
+    { 0xf8, "hard disk" },
+    { 0xf9, "3,5\" 720k floppy 2s/80tr/9sec or "
+            "5.25\" 1.2M floppy 2s/80tr/15sec" },
+    { 0xfa, "5.25\" 320k floppy 1s/80tr/8sec" },
+    { 0xfb, "3.5\" 640k floppy 2s/80tr/8sec" },
+    { 0xfc, "5.25\" 180k floppy 1s/40tr/9sec" },
+    { 0xfd, "5.25\" 360k floppy 2s/40tr/9sec" },
+    { 0xfe, "5.25\" 160k floppy 1s/40tr/8sec" },
+    { 0xff, "5.25\" 320k floppy 2s/40tr/8sec" },
+};
+
+#if defined __alpha || defined __ia64__ || defined __s390x__ || defined __x86_64__ || defined __ppc64__
+/* Unaligned fields must first be copied byte-wise */
+#define GET_UNALIGNED_W(f)			\
+    ({						\
+	unsigned short __v;			\
+	memcpy( &__v, &f, sizeof(__v) );	\
+	CF_LE_W( *(unsigned short *)&f );	\
+    })
+#else
+#define GET_UNALIGNED_W(f) CF_LE_W( *(unsigned short *)&f )
+#endif
+
+
+static char *get_media_descr( unsigned char media )
+{
+    int i;
+
+    for( i = 0; i < sizeof(mediabytes)/sizeof(*mediabytes); ++i ) {
+	if (mediabytes[i].media == media)
+	    return( mediabytes[i].descr );
+    }
+    return( "undefined" );
+}
+
+static void dump_boot(DOS_FS *fs,struct boot_sector *b,unsigned lss)
+{
+    unsigned short sectors;
+    
+    printf("Boot sector contents:\n");
+    if (!atari_format) {
+	char id[9];
+	strncpy(id,b->system_id,8);
+	id[8] = 0;
+	printf("System ID \"%s\"\n",id);
+    }
+    else {
+	/* On Atari, a 24 bit serial number is stored at offset 8 of the boot
+	 * sector */
+	printf("Serial number 0x%x\n",
+	       b->system_id[5] | (b->system_id[6]<<8) | (b->system_id[7]<<16));
+    }
+    printf("Media byte 0x%02x (%s)\n",b->media,get_media_descr(b->media));
+    printf("%10d bytes per logical sector\n",GET_UNALIGNED_W(b->sector_size));
+    printf("%10d bytes per cluster\n",fs->cluster_size);
+    printf("%10d reserved sector%s\n",CF_LE_W(b->reserved),
+	   CF_LE_W(b->reserved) == 1 ? "" : "s");
+    printf("First FAT starts at byte %llu (sector %llu)\n",
+	   (unsigned long long)fs->fat_start,
+	   (unsigned long long)fs->fat_start/lss);
+    printf("%10d FATs, %d bit entries\n",b->fats,fs->fat_bits);
+    printf("%10d bytes per FAT (= %u sectors)\n",fs->fat_size,
+	   fs->fat_size/lss);
+    if (!fs->root_cluster) {
+	printf("Root directory starts at byte %llu (sector %llu)\n",
+	       (unsigned long long)fs->root_start,
+	       (unsigned long long)fs->root_start/lss);
+	printf("%10d root directory entries\n",fs->root_entries);
+    }
+    else {
+	printf( "Root directory start at cluster %lu (arbitrary size)\n",
+		fs->root_cluster);
+    }
+    printf("Data area starts at byte %llu (sector %llu)\n",
+	   (unsigned long long)fs->data_start,
+	   (unsigned long long)fs->data_start/lss);
+    printf("%10lu data clusters (%llu bytes)\n",fs->clusters,
+	   (unsigned long long)fs->clusters*fs->cluster_size);
+    printf("%u sectors/track, %u heads\n",CF_LE_W(b->secs_track),
+	   CF_LE_W(b->heads));
+    printf("%10u hidden sectors\n",
+	   atari_format ?
+	   /* On Atari, the hidden field is only 16 bit wide and unused */
+	   (((unsigned char *)&b->hidden)[0] |
+	    ((unsigned char *)&b->hidden)[1] << 8) :
+	   CF_LE_L(b->hidden));
+    sectors = GET_UNALIGNED_W( b->sectors );
+    printf("%10u sectors total\n", sectors ? sectors : CF_LE_L(b->total_sect));
+}
+
+static void check_backup_boot(DOS_FS *fs, struct boot_sector *b, int lss)
+{
+    struct boot_sector b2;
+
+    if (!fs->backupboot_start) {
+	printf( "There is no backup boot sector.\n" );
+	if (CF_LE_W(b->reserved) < 3) {
+	    printf( "And there is no space for creating one!\n" );
+	    return;
+	}
+	if (interactive)
+	    printf( "1) Create one\n2) Do without a backup\n" );
+	else printf( "  Auto-creating backup boot block.\n" );
+	if (!interactive || get_key("12","?") == '1') {
+	    int bbs;
+	    /* The usual place for the backup boot sector is sector 6. Choose
+	     * that or the last reserved sector. */
+	    if (CF_LE_W(b->reserved) >= 7 && CF_LE_W(b->info_sector) != 6)
+		bbs = 6;
+	    else {
+		bbs = CF_LE_W(b->reserved) - 1;
+		if (bbs == CF_LE_W(b->info_sector))
+		    --bbs; /* this is never 0, as we checked reserved >= 3! */
+	    }
+	    fs->backupboot_start = bbs*lss;
+	    b->backup_boot = CT_LE_W(bbs);
+	    fs_write(fs->backupboot_start,sizeof(*b),b);
+	    fs_write((off_t)offsetof(struct boot_sector,backup_boot),
+		     sizeof(b->backup_boot),&b->backup_boot);
+	    printf( "Created backup of boot sector in sector %d\n", bbs );
+	    return;
+	}
+	else return;
+    }
+    
+    fs_read(fs->backupboot_start,sizeof(b2),&b2);
+    if (memcmp(b,&b2,sizeof(b2)) != 0) {
+	/* there are any differences */
+	__u8 *p, *q;
+	int i, pos, first = 1;
+	char buf[20];
+
+	printf( "There are differences between boot sector and its backup.\n" );
+	printf( "Differences: (offset:original/backup)\n  " );
+	pos = 2;
+	for( p = (__u8 *)b, q = (__u8 *)&b2, i = 0; i < sizeof(b2);
+	     ++p, ++q, ++i ) {
+	    if (*p != *q) {
+		sprintf( buf, "%s%u:%02x/%02x", first ? "" : ", ",
+			 (unsigned)(p-(__u8 *)b), *p, *q );
+		if (pos + strlen(buf) > 78) printf( "\n  " ), pos = 2;
+		printf( "%s", buf );
+		pos += strlen(buf);
+		first = 0;
+	    }
+	}
+	printf( "\n" );
+
+	if (interactive)
+	    printf( "1) Copy original to backup\n"
+		    "2) Copy backup to original\n"
+		    "3) No action\n" );
+	else printf( "  Not automatically fixing this.\n" );
+	switch (interactive ? get_key("123","?") : '3') {
+	  case '1':
+	    fs_write(fs->backupboot_start,sizeof(*b),b);
+	    break;
+	  case '2':
+	    fs_write(0,sizeof(b2),&b2);
+	    break;
+	  default:
+	    break;
+	}
+    }
+}
+
+static void init_fsinfo(struct info_sector *i)
+{
+    i->magic = CT_LE_L(0x41615252);
+    i->signature = CT_LE_L(0x61417272);
+    i->free_clusters = CT_LE_L(-1);
+    i->next_cluster = CT_LE_L(2);
+    i->boot_sign = CT_LE_W(0xaa55);
+}
+
+static void read_fsinfo(DOS_FS *fs, struct boot_sector *b,int lss)
+{
+    struct info_sector i;
+
+    if (!b->info_sector) {
+	printf( "No FSINFO sector\n" );
+	if (interactive)
+	    printf( "1) Create one\n2) Do without FSINFO\n" );
+	else printf( "  Not automatically creating it.\n" );
+	if (interactive && get_key("12","?") == '1') {
+	    /* search for a free reserved sector (not boot sector and not
+	     * backup boot sector) */
+	    __u32 s;
+	    for( s = 1; s < CF_LE_W(b->reserved); ++s )
+		if (s != CF_LE_W(b->backup_boot)) break;
+	    if (s > 0 && s < CF_LE_W(b->reserved)) {
+		init_fsinfo(&i);
+		fs_write((off_t)s*lss,sizeof(i),&i);
+		b->info_sector = CT_LE_W(s);
+		fs_write((off_t)offsetof(struct boot_sector,info_sector),
+			 sizeof(b->info_sector),&b->info_sector);
+		if (fs->backupboot_start)
+		    fs_write(fs->backupboot_start+
+			     offsetof(struct boot_sector,info_sector),
+			     sizeof(b->info_sector),&b->info_sector);
+	    }
+	    else {
+		printf( "No free reserved sector found -- "
+			"no space for FSINFO sector!\n" );
+		return;
+	    }
+	}
+	else return;
+    }
+    
+    fs->fsinfo_start = CF_LE_W(b->info_sector)*lss;
+    fs_read(fs->fsinfo_start,sizeof(i),&i);
+    
+    if (i.magic != CT_LE_L(0x41615252) ||
+	i.signature != CT_LE_L(0x61417272) ||
+	i.boot_sign != CT_LE_W(0xaa55)) {
+	printf( "FSINFO sector has bad magic number(s):\n" );
+	if (i.magic != CT_LE_L(0x41615252))
+	    printf( "  Offset %llu: 0x%08x != expected 0x%08x\n",
+		    (unsigned long long)offsetof(struct info_sector,magic),
+		    CF_LE_L(i.magic),0x41615252);
+	if (i.signature != CT_LE_L(0x61417272))
+	    printf( "  Offset %llu: 0x%08x != expected 0x%08x\n",
+		    (unsigned long long)offsetof(struct info_sector,signature),
+		    CF_LE_L(i.signature),0x61417272);
+	if (i.boot_sign != CT_LE_W(0xaa55))
+	    printf( "  Offset %llu: 0x%04x != expected 0x%04x\n",
+		    (unsigned long long)offsetof(struct info_sector,boot_sign),
+		    CF_LE_W(i.boot_sign),0xaa55);
+	if (interactive)
+	    printf( "1) Correct\n2) Don't correct (FSINFO invalid then)\n" );
+	else printf( "  Auto-correcting it.\n" );
+	if (!interactive || get_key("12","?") == '1') {
+	    init_fsinfo(&i);
+	    fs_write(fs->fsinfo_start,sizeof(i),&i);
+	}
+	else fs->fsinfo_start = 0;
+    }
+
+    if (fs->fsinfo_start)
+	fs->free_clusters = CF_LE_L(i.free_clusters);
+}
+
+void read_boot(DOS_FS *fs)
+{
+    struct boot_sector b;
+    unsigned total_sectors;
+    unsigned short logical_sector_size, sectors;
+    unsigned fat_length;
+    off_t data_size;
+
+    fs_read(0,sizeof(b),&b);
+    logical_sector_size = GET_UNALIGNED_W(b.sector_size);
+    if (!logical_sector_size) die("Logical sector size is zero.");
+    fs->cluster_size = b.cluster_size*logical_sector_size;
+    if (!fs->cluster_size) die("Cluster size is zero.");
+    if (b.fats != 2 && b.fats != 1)
+	die("Currently, only 1 or 2 FATs are supported, not %d.\n",b.fats);
+    fs->nfats = b.fats;
+    sectors = GET_UNALIGNED_W(b.sectors);
+    total_sectors = sectors ? sectors : CF_LE_L(b.total_sect);
+    if (verbose) printf("Checking we can access the last sector of the filesystem\n");
+    /* Can't access last odd sector anyway, so round down */
+    fs_test((off_t)((total_sectors & ~1)-1)*(off_t)logical_sector_size,
+	    logical_sector_size);
+    fat_length = CF_LE_W(b.fat_length) ?
+		 CF_LE_W(b.fat_length) : CF_LE_L(b.fat32_length);
+    fs->fat_start = (off_t)CF_LE_W(b.reserved)*logical_sector_size;
+    fs->root_start = ((off_t)CF_LE_W(b.reserved)+b.fats*fat_length)*
+      logical_sector_size;
+    fs->root_entries = GET_UNALIGNED_W(b.dir_entries);
+    fs->data_start = fs->root_start+ROUND_TO_MULTIPLE(fs->root_entries <<
+      MSDOS_DIR_BITS,logical_sector_size);
+    data_size = (off_t)total_sectors*logical_sector_size-fs->data_start;
+    fs->clusters = data_size/fs->cluster_size;
+    fs->root_cluster = 0; /* indicates standard, pre-FAT32 root dir */
+    fs->fsinfo_start = 0; /* no FSINFO structure */
+    fs->free_clusters = -1; /* unknown */
+    if (!b.fat_length && b.fat32_length) {
+	fs->fat_bits = 32;
+	fs->root_cluster = CF_LE_L(b.root_cluster);
+	if (!fs->root_cluster && fs->root_entries)
+	    /* M$ hasn't specified this, but it looks reasonable: If
+	     * root_cluster is 0 but there is a separate root dir
+	     * (root_entries != 0), we handle the root dir the old way. Give a
+	     * warning, but convertig to a root dir in a cluster chain seems
+	     * to complex for now... */
+	    printf( "Warning: FAT32 root dir not in cluster chain! "
+		    "Compability mode...\n" );
+	else if (!fs->root_cluster && !fs->root_entries)
+	    die("No root directory!");
+	else if (fs->root_cluster && fs->root_entries)
+	    printf( "Warning: FAT32 root dir is in a cluster chain, but "
+		    "a separate root dir\n"
+		    "  area is defined. Cannot fix this easily.\n" );
+
+	fs->backupboot_start = CF_LE_W(b.backup_boot)*logical_sector_size;
+	check_backup_boot(fs,&b,logical_sector_size);
+	
+	read_fsinfo(fs,&b,logical_sector_size);
+    }
+    else if (!atari_format) {
+	/* On real MS-DOS, a 16 bit FAT is used whenever there would be too
+	 * much clusers otherwise. */
+	fs->fat_bits = (fs->clusters > MSDOS_FAT12) ? 16 : 12;
+    }
+    else {
+	/* On Atari, things are more difficult: GEMDOS always uses 12bit FATs
+	 * on floppies, and always 16 bit on harddisks. */
+	fs->fat_bits = 16; /* assume 16 bit FAT for now */
+	/* If more clusters than fat entries in 16-bit fat, we assume
+	 * it's a real MSDOS FS with 12-bit fat. */
+	if (fs->clusters+2 > fat_length*logical_sector_size*8/16 ||
+	    /* if it's a floppy disk --> 12bit fat */
+	    device_no == 2 ||
+	    /* if it's a ramdisk or loopback device and has one of the usual
+	     * floppy sizes -> 12bit FAT  */
+	    ((device_no == 1 || device_no == 7) &&
+	     (total_sectors == 720 || total_sectors == 1440 ||
+	      total_sectors == 2880)))
+	    fs->fat_bits = 12;
+    }
+    /* On FAT32, the high 4 bits of a FAT entry are reserved */
+    fs->eff_fat_bits = (fs->fat_bits == 32) ? 28 : fs->fat_bits;
+    fs->fat_size = fat_length*logical_sector_size;
+    if (fs->clusters > ((unsigned long long)fs->fat_size*8/fs->fat_bits)-2)
+	die("File system has %d clusters but only space for %d FAT entries.",
+	  fs->clusters,((unsigned long long)fs->fat_size*8/fs->fat_bits)-2);
+    if (!fs->root_entries && !fs->root_cluster)
+	die("Root directory has zero size.");
+    if (fs->root_entries & (MSDOS_DPS-1))
+	die("Root directory (%d entries) doesn't span an integral number of "
+	  "sectors.",fs->root_entries);
+    if (logical_sector_size & (SECTOR_SIZE-1))
+	die("Logical sector size (%d bytes) is not a multiple of the physical "
+	  "sector size.",logical_sector_size);
+    /* ++roman: On Atari, these two fields are often left uninitialized */
+    if (!atari_format && (!b.secs_track || !b.heads))
+	die("Invalid disk format in boot sector.");
+    if (verbose) dump_boot(fs,&b,logical_sector_size);
+}
+
+/* Local Variables: */
+/* tab-width: 8     */
+/* End:             */
diff -pruwN busybox-1.01/util-linux/boot.h busybox-1.01-livebox/util-linux/boot.h
--- busybox-1.01/util-linux/boot.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/boot.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,13 @@
+/* boot.h  -  Read and analyze ia PC/MS-DOS boot sector */
+
+/* Written 1993 by Werner Almesberger */
+
+
+#ifndef _BOOT_H
+#define _BOOT_H
+
+void read_boot(DOS_FS *fs);
+
+/* Reads the boot sector from the currently open device and initializes *FS */
+
+#endif
diff -pruwN busybox-1.01/util-linux/check.c busybox-1.01-livebox/util-linux/check.c
--- busybox-1.01/util-linux/check.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/check.c	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,861 @@
+/* check.c  -  Check and repair a PC/MS-DOS file system */
+
+/* Written 1993 by Werner Almesberger */
+
+/* FAT32, VFAT, Atari format support, and various fixes additions May 1998
+ * by Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de> */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <time.h>
+
+#include "common.h"
+#include "dosfsck.h"
+#include "io.h"
+#include "fat.h"
+#include "file.h"
+#include "lfn.h"
+#include "check.h"
+
+
+static DOS_FILE *root;
+
+/* get start field of a dir entry */
+#define FSTART(p,fs) \
+  ((unsigned long)CF_LE_W(p->dir_ent.start) | \
+   (fs->fat_bits == 32 ? CF_LE_W(p->dir_ent.starthi) << 16 : 0))
+
+#define MODIFY(p,i,v)					\
+  do {							\
+    if (p->offset) {					\
+	p->dir_ent.i = v;				\
+	fs_write(p->offset+offsetof(DIR_ENT,i),		\
+		 sizeof(p->dir_ent.i),&p->dir_ent.i);	\
+    }							\
+  } while(0)
+
+#define MODIFY_START(p,v,fs)						\
+  do {									\
+    unsigned long __v = (v);						\
+    if (!p->offset) {							\
+	/* writing to fake entry for FAT32 root dir */			\
+	if (!__v) die("Oops, deleting FAT32 root dir!");		\
+	fs->root_cluster = __v;						\
+	p->dir_ent.start = CT_LE_W(__v&0xffff);				\
+	p->dir_ent.starthi = CT_LE_W(__v>>16);				\
+	__v = CT_LE_L(__v);						\
+	fs_write((loff_t)offsetof(struct boot_sector,root_cluster),	\
+	         sizeof(((struct boot_sector *)0)->root_cluster),	\
+		 &__v);							\
+    }									\
+    else {								\
+	MODIFY(p,start,CT_LE_W((__v)&0xffff));				\
+	if (fs->fat_bits == 32)						\
+	    MODIFY(p,starthi,CT_LE_W((__v)>>16));			\
+    }									\
+  } while(0)
+
+
+loff_t alloc_rootdir_entry(DOS_FS *fs, DIR_ENT *de, const char *pattern)
+{
+    static int curr_num = 0;
+    loff_t offset;
+
+    if (fs->root_cluster) {
+	DIR_ENT d2;
+	int i = 0, got = 0;
+	unsigned long clu_num, prev = 0;
+	loff_t offset2;
+	
+	clu_num = fs->root_cluster;
+	offset = cluster_start(fs,clu_num);
+	while (clu_num > 0 && clu_num != -1) {
+	    fs_read(offset,sizeof(DIR_ENT),&d2);
+	    if (IS_FREE(d2.name) && d2.attr != VFAT_LN_ATTR) {
+		got = 1;
+		break;
+	    }
+	    i += sizeof(DIR_ENT);
+	    offset += sizeof(DIR_ENT);
+	    if ((i % fs->cluster_size) == 0) {
+		prev = clu_num;
+		if ((clu_num = next_cluster(fs,clu_num)) == 0 || clu_num == -1)
+		    break;
+		offset = cluster_start(fs,clu_num);
+	    }
+	}
+	if (!got) {
+	    /* no free slot, need to extend root dir: alloc next free cluster
+	     * after previous one */
+	    if (!prev)
+		die("Root directory has no cluster allocated!");
+	    for (clu_num = prev+1; clu_num != prev; clu_num++) {
+		if (clu_num >= fs->clusters+2) clu_num = 2;
+		if (!fs->fat[clu_num].value)
+		    break;
+	    }
+	    if (clu_num == prev)
+		die("Root directory full and no free cluster");
+	    set_fat(fs,prev,clu_num);
+	    set_fat(fs,clu_num,-1);
+	    set_owner(fs, clu_num, get_owner(fs, fs->root_cluster));
+	    /* clear new cluster */
+	    memset( &d2, 0, sizeof(d2) );
+	    offset = cluster_start(fs,clu_num);
+	    for( i = 0; i < fs->cluster_size; i += sizeof(DIR_ENT) )
+		fs_write( offset+i, sizeof(d2), &d2 );
+	}
+	memset(de,0,sizeof(DIR_ENT));
+	while (1) {
+	    sprintf(de->name,pattern,curr_num);
+	    clu_num = fs->root_cluster;
+	    i = 0;
+	    offset2 = cluster_start(fs,clu_num);
+	    while (clu_num > 0 && clu_num != -1) {
+		fs_read(offset2,sizeof(DIR_ENT),&d2);
+		if (offset2 != offset &&
+		    !strncmp(d2.name,de->name,MSDOS_NAME))
+		    break;
+		i += sizeof(DIR_ENT);
+		offset2 += sizeof(DIR_ENT);
+		if ((i % fs->cluster_size) == 0) {
+		    if ((clu_num = next_cluster(fs,clu_num)) == 0 ||
+			clu_num == -1)
+			break;
+		    offset2 = cluster_start(fs,clu_num);
+		}
+	    }
+	    if (clu_num == 0 || clu_num == -1)
+		break;
+	    if (++curr_num >= 10000) die("Unable to create unique name");
+	}
+    }
+    else {
+	DIR_ENT *lroot;
+	int next_free = 0, scan;
+
+	lroot = alloc(fs->root_entries*sizeof(DIR_ENT));
+	fs_read(fs->root_start,fs->root_entries*sizeof(DIR_ENT),lroot);
+
+	while (next_free < fs->root_entries)
+	    if (IS_FREE(lroot[next_free].name) &&
+		lroot[next_free].attr != VFAT_LN_ATTR)
+		break;
+	    else next_free++;
+	if (next_free == fs->root_entries)
+	    die("Root directory is full.");
+	offset = fs->root_start+next_free*sizeof(DIR_ENT);
+	memset(de,0,sizeof(DIR_ENT));
+	while (1) {
+	    sprintf(de->name,pattern,curr_num);
+	    for (scan = 0; scan < fs->root_entries; scan++)
+		if (scan != next_free &&
+		    !strncmp(lroot[scan].name,de->name,MSDOS_NAME))
+		    break;
+	    if (scan == fs->root_entries) break;
+	    if (++curr_num >= 10000) die("Unable to create unique name");
+	}
+	free(lroot);
+    }
+    ++n_files;
+    return offset;
+}
+
+
+static char *path_name(DOS_FILE *file)
+{
+    static char path[PATH_MAX*2];
+
+    if (!file) *path = 0;
+    else {
+	if (strlen(path_name(file->parent)) > PATH_MAX)
+	    die("Path name too long.");
+	if (strcmp(path,"/") != 0) strcat(path,"/");
+	strcpy(strrchr(path,0),file->lfn?file->lfn:file_name(file->dir_ent.name));
+    }
+    return path;
+}
+
+
+static int day_n[] = { 0,31,59,90,120,151,181,212,243,273,304,334,0,0,0,0 };
+		  /* JanFebMarApr May Jun Jul Aug Sep Oct Nov Dec */
+
+
+/* Convert a MS-DOS time/date pair to a UNIX date (seconds since 1 1 70). */
+
+time_t date_dos2unix(unsigned short time1,unsigned short date)
+{
+    int month,year;
+    time_t secs;
+
+    month = ((date >> 5) & 15)-1;
+    year = date >> 9;
+    secs = (time1 & 31)*2+60*((time1 >> 5) & 63)+(time1 >> 11)*3600+86400*
+      ((date & 31)-1+day_n[month]+(year/4)+year*365-((year & 3) == 0 &&
+      month < 2 ? 1 : 0)+3653);
+                       /* days since 1.1.70 plus 80's leap day */
+    return secs;
+}
+
+
+static char *file_stat(DOS_FILE *file)
+{
+    static char temp[100];
+    struct tm *tm;
+    char tmp[100];
+    time_t date;
+
+    date = date_dos2unix(CF_LE_W(file->dir_ent.time),CF_LE_W(file->
+      dir_ent.date));
+    tm = localtime(&date);
+    strftime(tmp,99,"%H:%M:%S %b %d %Y",tm);
+    sprintf(temp,"  Size %u bytes, date %s",CF_LE_L(file->dir_ent.size),tmp);
+    return temp;
+}
+
+
+static int bad_name(unsigned char *name)
+{
+    int i, spc, suspicious = 0;
+    char *bad_chars = atari_format ? "*?\\/:" : "*?<>|\"\\/:";
+
+    /* Do not complain about (and auto-correct) the extended attribute files
+     * of OS/2. */
+    if (strncmp(name,"EA DATA  SF",11) == 0 ||
+        strncmp(name,"WP ROOT  SF",11) == 0) return 0;
+    
+    for (i = 0; i < 8; i++) {
+	if (name[i] < ' ' || name[i] == 0x7f) return 1;
+	if (name[i] > 0x7f) ++suspicious;
+	if (strchr(bad_chars,name[i])) return 1;
+    }
+
+    for (i = 8; i < 11; i++) {
+	if (name[i] < ' ' || name[i] == 0x7f) return 1;
+	if (name[i] > 0x7f) ++suspicious;
+	if (strchr(bad_chars,name[i])) return 1;
+    }
+
+    spc = 0;
+    for (i = 0; i < 8; i++) {
+	if (name[i] == ' ')
+	    spc = 1;
+	else if (spc)
+	    /* non-space after a space not allowed, space terminates the name
+	     * part */
+	    return 1;
+    }
+
+    spc = 0;
+    for (i = 8; i < 11; i++) {
+	if (name[i] == ' ')
+	    spc = 1;
+	else if (spc)
+	    /* non-space after a space not allowed, space terminates the name
+	     * part */
+	    return 1;
+    }
+
+    /* Under GEMDOS, chars >= 128 are never allowed. */
+    if (atari_format && suspicious)
+	return 1;
+    
+    /* Only complain about too much suspicious chars in interactive mode,
+     * never correct them automatically. The chars are all basically ok, so we
+     * shouldn't auto-correct such names. */
+    if (interactive && suspicious > 6)
+	return 1;
+    return 0;
+}
+
+
+static void drop_file(DOS_FS *fs,DOS_FILE *file)
+{
+    unsigned long cluster;
+
+    MODIFY(file,name[0],DELETED_FLAG);
+    for (cluster = FSTART(file,fs); cluster > 0 && cluster <
+      fs->clusters+2; cluster = next_cluster(fs,cluster))
+	set_owner(fs,cluster,NULL);
+    --n_files;
+}
+
+
+static void truncate_file(DOS_FS *fs,DOS_FILE *file,unsigned long clusters)
+{
+    int deleting;
+    unsigned long walk,next,prev;
+    
+    walk = FSTART(file,fs);
+    prev = 0;
+    if ((deleting = !clusters)) MODIFY_START(file,0,fs);
+    while (walk > 0 && walk != -1) {
+	next = next_cluster(fs,walk);
+	if (deleting) set_fat(fs,walk,0);
+	else if ((deleting = !--clusters)) set_fat(fs,walk,-1);
+	prev = walk;
+	walk = next;
+    }
+}
+
+
+static void auto_rename(DOS_FILE *file)
+{
+    DOS_FILE *first,*walk;
+    int number;
+
+    if (!file->offset) return;	/* cannot rename FAT32 root dir */
+    first = file->parent ? file->parent->first : root;
+    number = 0;
+    while (1) {
+	sprintf(file->dir_ent.name,"FSCK%04d",number);
+	strncpy(file->dir_ent.ext,"REN",3);
+	for (walk = first; walk; walk = walk->next)
+	    if (walk != file && !strncmp(walk->dir_ent.name,file->dir_ent.
+	      name,MSDOS_NAME)) break;
+	if (!walk) {
+	    fs_write(file->offset,MSDOS_NAME,file->dir_ent.name);
+	    return;
+	}
+	number++;
+    }
+    die("Can't generate a unique name.");
+}
+
+
+static void rename_file(DOS_FILE *file)
+{
+    unsigned char name[46];
+    unsigned char *walk,*here;
+
+    if (!file->offset) {
+	printf( "Cannot rename FAT32 root dir\n" );
+	return;	/* cannot rename FAT32 root dir */
+    }
+    while (1) {
+	printf("New name: ");
+	fflush(stdout);
+	if (fgets(name,45,stdin)) {
+	    if ((here = strchr(name,'\n'))) *here = 0;
+	    for (walk = strrchr(name,0); walk >= name && (*walk == ' ' ||
+	      *walk == '\t'); walk--);
+	    walk[1] = 0;
+	    for (walk = name; *walk == ' ' || *walk == '\t'; walk++);
+	    if (file_cvt(walk,file->dir_ent.name)) {
+		fs_write(file->offset,MSDOS_NAME,file->dir_ent.name);
+		return;
+	    }
+	}
+    }
+}
+
+
+static int handle_dot(DOS_FS *fs,DOS_FILE *file,int dots)
+{
+    char *name;
+
+    name = strncmp(file->dir_ent.name,MSDOS_DOT,MSDOS_NAME) ? ".." : ".";
+    if (!(file->dir_ent.attr & ATTR_DIR)) {
+	printf("%s\n  Is a non-directory.\n",path_name(file));
+	if (interactive)
+	    printf("1) Drop it\n2) Auto-rename\n3) Rename\n"
+	      "4) Convert to directory\n");
+	else printf("  Auto-renaming it.\n");
+	switch (interactive ? get_key("1234","?") : '2') {
+	    case '1':
+		drop_file(fs,file);
+		return 1;
+	    case '2':
+		auto_rename(file);
+		printf("  Renamed to %s\n",file_name(file->dir_ent.name));
+		return 0;
+	    case '3':
+		rename_file(file);
+		return 0;
+	    case '4':
+		MODIFY(file,size,CT_LE_L(0));
+		MODIFY(file,attr,file->dir_ent.attr | ATTR_DIR);
+		break;
+	}
+    }
+    if (!dots) {
+	printf("Root contains directory \"%s\". Dropping it.\n",name);
+	drop_file(fs,file);
+	return 1;
+    }
+    return 0;
+}
+
+
+static int check_file(DOS_FS *fs,DOS_FILE *file)
+{
+    DOS_FILE *owner;
+    int restart;
+    unsigned long expect,curr,this,clusters,prev,walk,clusters2;
+
+    if (file->dir_ent.attr & ATTR_DIR) {
+	if (CF_LE_L(file->dir_ent.size)) {
+	    printf("%s\n  Directory has non-zero size. Fixing it.\n",
+	      path_name(file));
+	    MODIFY(file,size,CT_LE_L(0));
+	}
+	if (file->parent && !strncmp(file->dir_ent.name,MSDOS_DOT,MSDOS_NAME)) {
+	    expect = FSTART(file->parent,fs);
+	    if (FSTART(file,fs) != expect) {
+		printf("%s\n  Start (%ld) does not point to parent (%ld)\n",
+		  path_name(file),FSTART(file,fs),expect);
+		MODIFY_START(file,expect,fs);
+	    }
+	    return 0;
+	}
+	if (file->parent && !strncmp(file->dir_ent.name,MSDOS_DOTDOT,
+	  MSDOS_NAME)) {
+	    expect = file->parent->parent ? FSTART(file->parent->parent,fs):0;
+	    if (fs->root_cluster && expect == fs->root_cluster)
+		expect = 0;
+	    if (FSTART(file,fs) != expect) {
+		printf("%s\n  Start (%lu) does not point to .. (%lu)\n",
+		  path_name(file),FSTART(file,fs),expect);
+		MODIFY_START(file,expect,fs);
+	    }
+	    return 0;
+	}
+	if (FSTART(file,fs)==0){
+		printf ("%s\n Start does point to root directory. Deleting dir. \n",
+				path_name(file));
+    		MODIFY(file,name[0],DELETED_FLAG);
+		return 0;
+	}
+    }
+    if (FSTART(file,fs) >= fs->clusters+2) {
+	printf("%s\n  Start cluster beyond limit (%lu > %lu). Truncating file.\n",
+	  path_name(file),FSTART(file,fs),fs->clusters+1);
+	if (!file->offset)
+	    die( "Bad FAT32 root directory! (bad start cluster)\n" );
+	MODIFY_START(file,0,fs);
+    }
+    clusters = prev = 0;
+    for (curr = FSTART(file,fs) ? FSTART(file,fs) :
+      -1; curr != -1; curr = next_cluster(fs,curr)) {
+	if (!fs->fat[curr].value || bad_cluster(fs,curr)) {
+	    printf("%s\n  Contains a %s cluster (%lu). Assuming EOF.\n",
+	      path_name(file),fs->fat[curr].value ? "bad" : "free",curr);
+	    if (prev) set_fat(fs,prev,-1);
+	    else if (!file->offset)
+		die( "FAT32 root dir starts with a bad cluster!" );
+	    else MODIFY_START(file,0,fs);
+	    break;
+	}
+	if (!(file->dir_ent.attr & ATTR_DIR) && CF_LE_L(file->dir_ent.size) <=
+	  clusters*fs->cluster_size) {
+	    printf("%s\n  File size is %u bytes, cluster chain length is > %lu "
+	      "bytes.\n  Truncating file to %u bytes.\n",path_name(file),
+	      CF_LE_L(file->dir_ent.size),clusters*fs->cluster_size,
+	      CF_LE_L(file->dir_ent.size));
+	    truncate_file(fs,file,clusters);
+	    break;
+	}
+	if ((owner = get_owner(fs,curr))) {
+	    int do_trunc = 0;
+	    printf("%s  and\n",path_name(owner));
+	    printf("%s\n  share clusters.\n",path_name(file));
+	    clusters2 = 0;
+	    for (walk = FSTART(owner,fs); walk > 0 && walk != -1; walk =
+	      next_cluster(fs,walk))
+		if (walk == curr) break;
+		else clusters2++;
+	    restart = file->dir_ent.attr & ATTR_DIR;
+	    if (!owner->offset) {
+		printf( "  Truncating second to %lu bytes because first "
+			"is FAT32 root dir.\n", clusters2*fs->cluster_size );
+		do_trunc = 2;
+	    }
+	    else if (!file->offset) {
+		printf( "  Truncating first to %lu bytes because second "
+			"is FAT32 root dir.\n", clusters*fs->cluster_size );
+		do_trunc = 1;
+	    }
+	    else if (interactive)
+		printf("1) Truncate first to %lu bytes%s\n"
+		  "2) Truncate second to %lu bytes\n",clusters*fs->cluster_size,
+		  restart ? " and restart" : "",clusters2*fs->cluster_size);
+	    else printf("  Truncating second to %lu bytes.\n",clusters2*
+		  fs->cluster_size);
+	    if (do_trunc != 2 &&
+		(do_trunc == 1 ||
+		 (interactive && get_key("12","?") == '1'))) {
+		prev = 0;
+		clusters = 0;
+		for (this = FSTART(owner,fs); this > 0 && this != -1; this =
+		  next_cluster(fs,this)) {
+		    if (this == curr) {
+			if (prev) set_fat(fs,prev,-1);
+			else MODIFY_START(owner,0,fs);
+			MODIFY(owner,size,CT_LE_L(clusters*fs->cluster_size));
+			if (restart) return 1;
+			while (this > 0 && this != -1) {
+			    set_owner(fs,this,NULL);
+			    this = next_cluster(fs,this);
+			}
+			break;
+		    }
+		    clusters++;
+		    prev = this;
+		}
+		if (this != curr)
+		    die("Internal error: didn't find cluster %d in chain"
+		      " starting at %d",curr,FSTART(owner,fs));
+	    }
+	    else {
+		if (prev) set_fat(fs,prev,-1);
+		else MODIFY_START(file,0,fs);
+		break;
+	    }
+	}
+	set_owner(fs,curr,file);
+	clusters++;
+	prev = curr;
+    }
+    if (!(file->dir_ent.attr & ATTR_DIR) && CF_LE_L(file->dir_ent.size) >
+      clusters*fs->cluster_size) {
+	printf("%s\n  File size is %u bytes, cluster chain length is %lu bytes."
+	  "\n  Truncating file to %lu bytes.\n",path_name(file),CF_LE_L(file->
+	  dir_ent.size),clusters*fs->cluster_size,clusters*fs->cluster_size);
+	MODIFY(file,size,CT_LE_L(clusters*fs->cluster_size));
+    }
+    return 0;
+}
+
+
+static int check_files(DOS_FS *fs,DOS_FILE *start)
+{
+    while (start) {
+	if (check_file(fs,start)) return 1;
+	start = start->next;
+    }
+    return 0;
+}
+
+
+static int check_dir(DOS_FS *fs,DOS_FILE **lroot,int dots)
+{
+    DOS_FILE *parent,**walk,**scan;
+    int dot,dotdot,skip,redo;
+    int good,bad;
+
+    if (!*lroot) return 0;
+    parent = (*lroot)->parent;
+    good = bad = 0;
+    for (walk = lroot; *walk; walk = &(*walk)->next)
+	if (bad_name((*walk)->dir_ent.name)) bad++;
+	else good++;
+    if (*lroot && parent && good+bad > 4 && bad > good/2) {
+	printf("%s\n  Has a large number of bad entries. (%d/%d)\n",
+	  path_name(parent),bad,good+bad);
+	if (!dots) printf( "  Not dropping root directory.\n" );
+	else if (!interactive) printf("  Not dropping it in auto-mode.\n");
+	else if (get_key("yn","Drop directory ? (y/n)") == 'y') {
+	    truncate_file(fs,parent,0);
+	    MODIFY(parent,name[0],DELETED_FLAG);
+	    /* buglet: deleted directory stays in the list. */
+	    return 1;
+	}
+    }
+    dot = dotdot = redo = 0;
+    walk = lroot;
+    while (*walk) {
+	if (!strncmp((*walk)->dir_ent.name,MSDOS_DOT,MSDOS_NAME) ||
+	  !strncmp((*walk)->dir_ent.name,MSDOS_DOTDOT,MSDOS_NAME)) {
+	    if (handle_dot(fs,*walk,dots)) {
+		*walk = (*walk)->next;
+		continue;
+	    }
+	    if (!strncmp((*walk)->dir_ent.name,MSDOS_DOT,MSDOS_NAME)) dot++;
+	    else dotdot++;
+	}
+	if (!((*walk)->dir_ent.attr & ATTR_VOLUME) &&
+	    bad_name((*walk)->dir_ent.name)) {
+	    printf("%s\n  Bad file name.\n",path_name(*walk));
+	    if (interactive)
+		printf("1) Drop file\n2) Rename file\n3) Auto-rename\n"
+		  "4) Keep it\n");
+	    else printf("  Auto-renaming it.\n");
+	    switch (interactive ? get_key("1234","?") : '3') {
+		case '1':
+		    drop_file(fs,*walk);
+		    walk = &(*walk)->next;
+		    continue;
+		case '2':
+		    rename_file(*walk);
+		    redo = 1;
+		    break;
+		case '3':
+		    auto_rename(*walk);
+		    printf("  Renamed to %s\n",file_name((*walk)->dir_ent.
+		      name));
+		    break;
+		case '4':
+		    break;
+	    }
+	}
+	/* don't check for duplicates of the volume label */
+	if (!((*walk)->dir_ent.attr & ATTR_VOLUME)) {
+	    scan = &(*walk)->next;
+	    skip = 0;
+	    while (*scan && !skip) {
+		if (!((*scan)->dir_ent.attr & ATTR_VOLUME) &&
+		    !strncmp((*walk)->dir_ent.name,(*scan)->dir_ent.name,MSDOS_NAME)) {
+		    printf("%s\n  Duplicate directory entry.\n  First  %s\n",
+			   path_name(*walk),file_stat(*walk));
+		    printf("  Second %s\n",file_stat(*scan));
+		    if (interactive)
+			printf("1) Drop first\n2) Drop second\n3) Rename first\n"
+			       "4) Rename second\n5) Auto-rename first\n"
+			       "6) Auto-rename second\n");
+		    else printf("  Auto-renaming second.\n");
+		    switch (interactive ? get_key("123456","?") : '6') {
+		      case '1':
+			drop_file(fs,*walk);
+			*walk = (*walk)->next;
+			skip = 1;
+			break;
+		      case '2':
+			drop_file(fs,*scan);
+			*scan = (*scan)->next;
+			continue;
+		      case '3':
+			rename_file(*walk);
+			printf("  Renamed to %s\n",path_name(*walk));
+			redo = 1;
+			break;
+		      case '4':
+			rename_file(*scan);
+			printf("  Renamed to %s\n",path_name(*walk));
+			redo = 1;
+			break;
+		      case '5':
+			auto_rename(*walk);
+			printf("  Renamed to %s\n",file_name((*walk)->dir_ent.
+			  name));
+			break;
+		      case '6':
+			auto_rename(*scan);
+			printf("  Renamed to %s\n",file_name((*scan)->dir_ent.
+			  name));
+			break;
+		    }
+		}
+		scan = &(*scan)->next;
+	    }
+	    if (skip) continue;
+	}
+	if (!redo) walk = &(*walk)->next;
+	else {
+	    walk = lroot;
+	    dot = dotdot = redo = 0;
+	}
+    }
+    if (dots && !dot)
+	printf("%s\n  \".\" is missing. Can't fix this yet.\n",
+	  path_name(parent));
+    if (dots && !dotdot)
+	printf("%s\n  \"..\" is missing. Can't fix this yet.\n",
+	  path_name(parent));
+    return 0;
+}
+
+
+static void test_file(DOS_FS *fs,DOS_FILE *file,int read_test)
+{
+    DOS_FILE *owner;
+    unsigned long walk,prev,clusters,next_clu;
+
+    prev = clusters = 0;
+    for (walk = FSTART(file,fs); walk > 0 && walk < fs->clusters+2;
+      walk = next_clu) {
+	next_clu = next_cluster(fs,walk);
+	if ((owner = get_owner(fs,walk))) {
+	    if (owner == file) {
+		printf("%s\n  Circular cluster chain. Truncating to %lu "
+		  "cluster%s.\n",path_name(file),clusters,clusters == 1 ? "" :
+		  "s");
+		if (prev) set_fat(fs,prev,-1);
+		else if (!file->offset)
+		    die( "Bad FAT32 root directory! (bad start cluster)\n" );
+		else MODIFY_START(file,0,fs);
+	    }
+	    break;
+	}
+	if (bad_cluster(fs,walk)) break;
+	if (read_test) {
+	    if (fs_test(cluster_start(fs,walk),fs->cluster_size)) {
+		prev = walk;
+		clusters++;
+	    }
+	    else {
+		printf("%s\n  Cluster %lu (%lu) is unreadable. Skipping it.\n",
+		  path_name(file),clusters,walk);
+		if (prev) set_fat(fs,prev,next_cluster(fs,walk));
+		else MODIFY_START(file,next_cluster(fs,walk),fs);
+		set_fat(fs,walk,-2);
+	    }
+	}
+	set_owner(fs,walk,file);
+    }
+    for (walk = FSTART(file,fs); walk > 0 && walk < fs->clusters+2;
+      walk = next_cluster(fs,walk))
+	if (bad_cluster(fs,walk)) break;
+	else if (get_owner(fs,walk) == file) set_owner(fs,walk,NULL);
+	    else break;
+}
+
+
+static void undelete(DOS_FS *fs,DOS_FILE *file)
+{
+    unsigned long clusters,left,prev,walk;
+
+    clusters = left = (CF_LE_L(file->dir_ent.size)+fs->cluster_size-1)/
+      fs->cluster_size;
+    prev = 0;
+    for (walk = FSTART(file,fs); left && walk >= 2 && walk <
+       fs->clusters+2 && !fs->fat[walk].value; walk++) {
+	left--;
+	if (prev) set_fat(fs,prev,walk);
+	prev = walk;
+    }
+    if (prev) set_fat(fs,prev,-1);
+    else MODIFY_START(file,0,fs);
+    if (left)
+	printf("Warning: Did only undelete %lu of %lu cluster%s.\n",clusters-left,
+	  clusters,clusters == 1 ? "" : "s");
+   
+}
+
+
+static void new_dir( void )
+{
+    lfn_reset();
+}
+
+
+static void add_file(DOS_FS *fs,DOS_FILE ***chain,DOS_FILE *parent,
+					 loff_t offset,FDSC **cp)
+{
+    DOS_FILE *new;
+    DIR_ENT de;
+    FD_TYPE type;
+
+    if (offset)
+	fs_read(offset,sizeof(DIR_ENT),&de);
+    else {
+	memcpy(de.name,"           ",MSDOS_NAME);
+	de.attr = ATTR_DIR;
+	de.size = de.time = de.date = 0;
+	de.start = CT_LE_W(fs->root_cluster & 0xffff);
+	de.starthi = CT_LE_W((fs->root_cluster >> 16) & 0xffff);
+    }
+    if ((type = file_type(cp,de.name)) != fdt_none) {
+	if (type == fdt_undelete && (de.attr & ATTR_DIR))
+	    die("Can't undelete directories.");
+	file_modify(cp,de.name);
+	fs_write(offset,1,&de);
+    }
+    if (IS_FREE(de.name)) {
+	lfn_check_orphaned();
+	return;
+    }
+    if (de.attr == VFAT_LN_ATTR) {
+	lfn_add_slot(&de,offset);
+	return;
+    }
+    new = qalloc(&mem_queue,sizeof(DOS_FILE));
+    new->lfn = lfn_get(&de);
+    new->offset = offset;
+    memcpy(&new->dir_ent,&de,sizeof(de));
+    new->next = new->first = NULL;
+    new->parent = parent;
+    if (type == fdt_undelete) undelete(fs,new);
+    **chain = new;
+    *chain = &new->next;
+    if (list) {
+	printf("Checking file %s",path_name(new));
+	if (new->lfn)
+	    printf(" (%s)", file_name(new->dir_ent.name) );
+	printf("\n");
+    }
+    if (offset &&
+	strncmp(de.name,MSDOS_DOT,MSDOS_NAME) != 0 &&
+	strncmp(de.name,MSDOS_DOTDOT,MSDOS_NAME) != 0)
+	++n_files;
+    test_file(fs,new,test);
+}
+
+
+static int subdirs(DOS_FS *fs,DOS_FILE *parent,FDSC **cp);
+
+
+static int scan_dir(DOS_FS *fs,DOS_FILE *this,FDSC **cp)
+{
+    DOS_FILE **chain;
+    int i;
+    unsigned long clu_num;
+
+    chain = &this->first;
+    i = 0;
+    clu_num = FSTART(this,fs);
+    new_dir();
+    while (clu_num > 0 && clu_num != -1) {
+	add_file(fs,&chain,this,cluster_start(fs,clu_num)+(i % fs->
+	  cluster_size),cp);
+	i += sizeof(DIR_ENT);
+	if (!(i % fs->cluster_size))
+	    if ((clu_num = next_cluster(fs,clu_num)) == 0 || clu_num == -1)
+		break;
+    }
+    lfn_check_orphaned();
+    if (check_dir(fs,&this->first,this->offset)) return 0;
+    if (check_files(fs,this->first)) return 1;
+    return subdirs(fs,this,cp);
+}
+
+
+static int subdirs(DOS_FS *fs,DOS_FILE *parent,FDSC **cp)
+{
+    DOS_FILE *walk;
+
+    for (walk = parent ? parent->first : root; walk; walk = walk->next)
+	if (walk->dir_ent.attr & ATTR_DIR)
+	    if (strncmp(walk->dir_ent.name,MSDOS_DOT,MSDOS_NAME) &&
+	      strncmp(walk->dir_ent.name,MSDOS_DOTDOT,MSDOS_NAME))
+		if (scan_dir(fs,walk,file_cd(cp,walk->dir_ent.name))) return 1;
+    return 0;
+}
+
+
+int scan_root(DOS_FS *fs)
+{
+    DOS_FILE **chain;
+    int i;
+
+    root = NULL;
+    chain = &root;
+    new_dir();
+    if (fs->root_cluster) {
+	add_file(fs,&chain,NULL,0,&fp_root);
+    }
+    else {
+	for (i = 0; i < fs->root_entries; i++)
+	    add_file(fs,&chain,NULL,fs->root_start+i*sizeof(DIR_ENT),&fp_root);
+    }
+    lfn_check_orphaned();
+    (void) check_dir(fs,&root,0);
+    if (check_files(fs,root)) return 1;
+    return subdirs(fs,NULL,&fp_root);
+}
+
+/* Local Variables: */
+/* tab-width: 8     */
+/* End:             */
diff -pruwN busybox-1.01/util-linux/check.h busybox-1.01-livebox/util-linux/check.h
--- busybox-1.01/util-linux/check.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/check.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,23 @@
+/* check.h  -  Check and repair a PC/MS-DOS file system */
+
+/* Written 1993 by Werner Almesberger */
+
+
+#ifndef _CHECK_H
+#define _CHECK_H
+
+loff_t alloc_rootdir_entry(DOS_FS *fs, DIR_ENT *de, const char *pattern);
+
+/* Allocate a free slot in the root directory for a new file. The file name is
+   constructed after 'pattern', which must include a %d type format for printf
+   and expand to exactly 11 characters. The name actually used is written into
+   the 'de' structure, the rest of *de is cleared. The offset returned is to
+   where in the filesystem the entry belongs. */
+
+int scan_root(DOS_FS *fs);
+
+/* Scans the root directory and recurses into all subdirectories. See check.c
+   for all the details. Returns a non-zero integer if the file system has to
+   be checked again. */
+
+#endif
diff -pruwN busybox-1.01/util-linux/common.c busybox-1.01-livebox/util-linux/common.c
--- busybox-1.01/util-linux/common.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/common.c	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,107 @@
+/* common.c  -  Common functions */
+
+/* Written 1993 by Werner Almesberger */
+
+/* FAT32, VFAT, Atari format support, and various fixes additions May 1998
+ * by Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de> */
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <errno.h>
+
+#include "common.h"
+
+
+typedef struct _link {
+    void *data;
+    struct _link *next;
+} LINK;
+
+
+void die(char *msg,...)
+{
+    va_list args;
+
+    va_start(args,msg);
+    vfprintf(stderr,msg,args);
+    va_end(args);
+    fprintf(stderr,"\n");
+    exit(1);
+}
+
+
+void pdie(char *msg,...)
+{
+    va_list args;
+
+    va_start(args,msg);
+    vfprintf(stderr,msg,args);
+    va_end(args);
+    fprintf(stderr,":%s\n",strerror(errno));
+    exit(1);
+}
+
+
+void *alloc(int size)
+{
+    void *this;
+
+    if ((this = malloc(size))) return this;
+    pdie("malloc");
+    return NULL; /* for GCC */
+}
+
+
+void *qalloc(void **root,int size)
+{
+    LINK *link;
+
+    link = alloc(sizeof(LINK));
+    link->next = *root;
+    *root = link;
+    return link->data = alloc(size);
+}
+
+
+void qfree(void **root)
+{
+    LINK *this;
+
+    while (*root) {
+	this = (LINK *) *root;
+	*root = this->next;
+	free(this->data);
+	free(this);
+    }
+}
+
+
+int min(int a,int b)
+{
+    return a < b ? a : b;
+}
+
+
+char get_key(char *valid,char *prompt)
+{
+    int ch,okay;
+
+    while (1) {
+	if (prompt) printf("%s ",prompt);
+	fflush(stdout);
+	while (ch = getchar(), ch == ' ' || ch == '\t');
+	if (ch == EOF) exit(1);
+	if (!strchr(valid,okay = ch)) okay = 0;
+	while (ch = getchar(), ch != '\n' && ch != EOF);
+	if (ch == EOF) exit(1);
+	if (okay) return okay;
+	printf("Invalid input.\n");
+    }
+}
+
+/* Local Variables: */
+/* tab-width: 8     */
+/* End:             */
diff -pruwN busybox-1.01/util-linux/common.h busybox-1.01-livebox/util-linux/common.h
--- busybox-1.01/util-linux/common.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/common.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,46 @@
+/* common.h  -  Common functions */
+
+/* Written 1993 by Werner Almesberger */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+# define __KERNEL__
+# include <asm/types.h>
+# undef __KERNEL__
+# define MSDOS_FAT12 4084 /* maximum number of clusters in a 12 bit FAT */
+#endif
+
+#ifndef _COMMON_H
+#define _COMMON_H
+
+void die(char *msg,...) __attribute((noreturn));
+
+/* Displays a prinf-style message and terminates the program. */
+
+void pdie(char *msg,...) __attribute((noreturn));
+
+/* Like die, but appends an error message according to the state of errno. */
+
+void *alloc(int size);
+
+/* mallocs SIZE bytes and returns a pointer to the data. Terminates the program
+   if malloc fails. */
+
+void *qalloc(void **root,int size);
+
+/* Like alloc, but registers the data area in a list described by ROOT. */
+
+void qfree(void **root);
+
+/* Deallocates all qalloc'ed data areas described by ROOT. */
+
+int min(int a,int b);
+
+/* Returns the smaller integer value of a and b. */
+
+char get_key(char *valid,char *prompt);
+
+/* Displays PROMPT and waits for user input. Only characters in VALID are
+   accepted. Terminates the program on EOF. Returns the character. */
+
+#endif
diff -pruwN busybox-1.01/util-linux/Config.in busybox-1.01-livebox/util-linux/Config.in
--- busybox-1.01/util-linux/Config.in	2005-08-17 03:29:17.000000000 +0200
+++ busybox-1.01-livebox/util-linux/Config.in	2011-02-01 13:48:39.000000000 +0100
@@ -74,6 +74,22 @@ config CONFIG_FDISK
 	  can be used to list and edit the set of partitions or BSD style
 	  'disk slices' that are defined on a hard drive.
 
+config CONFIG_MKDOSFS
+	bool "mkdosfs"
+	default n
+	help
+	  mkdosfs is used to create an MS-DOS file system under Linux on a device.  
+	  device is the special file corresponding to the device (e.g /dev/hdXX).  
+	  block-count is the number of blocks on the device. If omitted, mkdosfs 
+	  automatically determiness the file system size. 
+
+config CONFIG_DOSFSCK
+	bool "dosfsck"
+	default n
+	help
+		dosfsck verifies the consistency of MS-DOS file systems and optionally 
+		tries to repair them
+
 config FDISK_SUPPORT_LARGE_DISKS
 	bool "  support over 4GB disks"
 	default y
diff -pruwN busybox-1.01/util-linux/dosfsck.c busybox-1.01-livebox/util-linux/dosfsck.c
--- busybox-1.01/util-linux/dosfsck.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/dosfsck.c	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,183 @@
+/* dosfsck.c  -  User interface */
+
+/* Written 1993 by Werner Almesberger */
+
+/* FAT32, VFAT, Atari format support, and various fixes additions May 1998
+ * by Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de> */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <getopt.h>
+
+#include "common.h"
+#include "dosfsck.h"
+#include "io.h"
+#include "boot.h"
+#include "fat.h"
+#include "file.h"
+#include "check.h"
+
+#define VERSION         "2.11"
+#define VERSION_DATE    "12 Mar 2005"
+
+int interactive = 0,list = 0,test = 0,verbose = 0,write_immed = 0;
+int atari_format = 0;
+unsigned n_files = 0;
+void *mem_queue = NULL;
+
+
+static void usage(char *name)
+{
+    fprintf(stderr,"usage: %s [-aAflrtvVwy] [-d path -d ...] "
+      "[-u path -u ...]\n%15sdevice\n",name,"");
+    fprintf(stderr,"  -a       automatically repair the file system\n");
+    fprintf(stderr,"  -A       toggle Atari file system format\n");
+    fprintf(stderr,"  -d path  drop that file\n");
+    fprintf(stderr,"  -f       salvage unused chains to files\n");
+    fprintf(stderr,"  -l       list path names\n");
+    fprintf(stderr,"  -n       no-op, check non-interactively without changing\n");
+    fprintf(stderr,"  -r       interactively repair the file system\n");
+    fprintf(stderr,"  -t       test for bad clusters\n");
+    fprintf(stderr,"  -u path  try to undelete that (non-directory) file\n");
+    fprintf(stderr,"  -v       verbose mode\n");
+    fprintf(stderr,"  -V       perform a verification pass\n");
+    fprintf(stderr,"  -w       write changes to disk immediately\n");
+    fprintf(stderr,"  -y       same as -a, for compat with other *fsck\n");
+    exit(2);
+}
+
+
+/*
+ * ++roman: On m68k, check if this is an Atari; if yes, turn on Atari variant
+ * of MS-DOS filesystem by default.
+ */
+static void check_atari( void )
+{
+#ifdef __mc68000__
+    FILE *f;
+    char line[128], *p;
+
+    if (!(f = fopen( "/proc/hardware", "r" ))) {
+	perror( "/proc/hardware" );
+	return;
+    }
+
+    while( fgets( line, sizeof(line), f ) ) {
+	if (strncmp( line, "Model:", 6 ) == 0) {
+	    p = line + 6;
+	    p += strspn( p, " \t" );
+	    if (strncmp( p, "Atari ", 6 ) == 0)
+		atari_format = 1;
+	    break;
+	}
+    }
+    fclose( f );
+#endif
+}
+
+
+int dosfsck_main(int argc,char **argv)
+{
+    DOS_FS fs;
+    int rw,salvage_files,verify,c;
+    unsigned long free_clusters;
+    
+    rw = salvage_files = verify = 0;
+    interactive = 1;
+    check_atari();
+
+    while ((c = getopt(argc,argv,"Aad:flnrtu:vVwy")) != EOF)
+	switch (c) {
+	    case 'A': /* toggle Atari format */
+	  	atari_format = !atari_format;
+		break;
+	    case 'a':
+	    case 'y':
+		rw = 1;
+		interactive = 0;
+		salvage_files = 1;
+		break;
+	    case 'd':
+		file_add(optarg,fdt_drop);
+		break;
+	    case 'f':
+		salvage_files = 1;
+		break;
+	    case 'l':
+		list = 1;
+		break;
+	    case 'n':
+		rw = 0;
+		interactive = 0;
+		break;
+	    case 'r':
+		rw = 1;
+		interactive = 1;
+		break;
+	    case 't':
+		test = 1;
+		break;
+	    case 'u':
+		file_add(optarg,fdt_undelete);
+		break;
+	    case 'v':
+		verbose = 1;
+		printf("dosfsck " VERSION " (" VERSION_DATE ")\n");
+		break;
+	    case 'V':
+		verify = 1;
+		break;
+	    case 'w':
+		write_immed = 1;
+		break;
+	    default:
+		usage(argv[0]);
+	}
+    if ((test || write_immed) && !rw) {
+	fprintf(stderr,"-t and -w require -a or -r\n");
+	exit(2);
+    }
+    if (optind != argc-1) usage(argv[0]);
+
+    printf( "dosfsck " VERSION ", " VERSION_DATE ", FAT32, LFN\n" );
+    fs_open(argv[optind],rw);
+    read_boot(&fs);
+    if (verify) printf("Starting check/repair pass.\n");
+    while (read_fat(&fs), scan_root(&fs)) qfree(&mem_queue);
+    if (test) fix_bad(&fs);
+    if (salvage_files) reclaim_file(&fs);
+    else reclaim_free(&fs);
+    free_clusters = update_free(&fs);
+    file_unused();
+    qfree(&mem_queue);
+    if (verify) {
+	printf("Starting verification pass.\n");
+	read_fat(&fs);
+	scan_root(&fs);
+	reclaim_free(&fs);
+	qfree(&mem_queue);
+    }
+
+    if (fs_changed()) {
+	if (rw) {
+	    if (interactive)
+		rw = get_key("yn","Perform changes ? (y/n)") == 'y';
+	    else printf("Performing changes.\n");
+	}
+	else
+	    printf("Leaving file system unchanged.\n");
+    }
+
+    printf( "%s: %u files, %lu/%lu clusters\n", argv[optind],
+	    n_files, fs.clusters - free_clusters, fs.clusters );
+
+    return fs_close(rw) ? 1 : 0;
+}
+
+/* Local Variables: */
+/* tab-width: 8     */
+/* End:             */
diff -pruwN busybox-1.01/util-linux/dosfsck.h busybox-1.01-livebox/util-linux/dosfsck.h
--- busybox-1.01/util-linux/dosfsck.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/dosfsck.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,170 @@
+/* dosfsck.h  -  Common data structures and global variables */
+
+/* Written 1993 by Werner Almesberger */
+
+/* FAT32, VFAT, Atari format support, and various fixes additions May 1998
+ * by Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de> */
+
+
+#ifndef _DOSFSCK_H
+#define _DOSFSCK_H
+
+#include <sys/types.h>
+#define _LINUX_STAT_H		/* hack to avoid inclusion of <linux/stat.h> */
+#define _LINUX_STRING_H_	/* hack to avoid inclusion of <linux/string.h>*/
+#define _LINUX_FS_H             /* hack to avoid inclusion of <linux/fs.h> */
+
+#ifdef __KERNEL__
+	#include <asm/byteorder.h>
+	/* Linux user-mode has __BYTE_ORDER defined, but the kernel does not */
+	#ifdef CONFIG_CPU_LITTLE_ENDIAN
+		#define __BYTE_ORDER __LITTLE_ENDIAN
+	#elif defined(CONFIG_CPU_BIG_ENDIAN)
+		#define __BYTE_ORDER __BIG_ENDIAN
+	#else
+		#error "Unable to define __BYTE_ORDER"
+	#endif
+#else
+	#include <endian.h>
+#endif
+
+#include <linux/msdos_fs.h>
+
+#undef CF_LE_W
+#undef CF_LE_L
+#undef CT_LE_W
+#undef CT_LE_L
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+#include <byteswap.h>
+#define CF_LE_W(v) bswap_16(v)
+#define CF_LE_L(v) bswap_32(v)
+#define CT_LE_W(v) CF_LE_W(v)
+#define CT_LE_L(v) CF_LE_L(v)
+#else
+#define CF_LE_W(v) (v)
+#define CF_LE_L(v) (v)
+#define CT_LE_W(v) (v)
+#define CT_LE_L(v) (v)
+#endif /* __BIG_ENDIAN */
+
+#define VFAT_LN_ATTR (ATTR_RO | ATTR_HIDDEN | ATTR_SYS | ATTR_VOLUME)
+
+/* ++roman: Use own definition of boot sector structure -- the kernel headers'
+ * name for it is msdos_boot_sector in 2.0 and fat_boot_sector in 2.1 ... */
+struct boot_sector {
+    __u8	ignored[3];	/* Boot strap short or near jump */
+    __u8	system_id[8];	/* Name - can be used to special case
+				   partition manager volumes */
+    __u8	sector_size[2];	/* bytes per logical sector */
+    __u8	cluster_size;	/* sectors/cluster */
+    __u16	reserved;	/* reserved sectors */
+    __u8	fats;		/* number of FATs */
+    __u8	dir_entries[2];	/* root directory entries */
+    __u8	sectors[2];	/* number of sectors */
+    __u8	media;		/* media code (unused) */
+    __u16	fat_length;	/* sectors/FAT */
+    __u16	secs_track;	/* sectors per track */
+    __u16	heads;		/* number of heads */
+    __u32	hidden;		/* hidden sectors (unused) */
+    __u32	total_sect;	/* number of sectors (if sectors == 0) */
+    
+    /* The following fields are only used by FAT32 */
+    __u32	fat32_length;	/* sectors/FAT */
+    __u16	flags;		/* bit 8: fat mirroring, low 4: active fat */
+    __u8	version[2];	/* major, minor filesystem version */
+    __u32	root_cluster;	/* first cluster in root directory */
+    __u16	info_sector;	/* filesystem info sector */
+    __u16	backup_boot;	/* backup boot sector */
+    __u16	reserved2[6];	/* Unused */
+
+    /* fill up to 512 bytes */
+    __u8	junk[448];
+} __attribute__ ((packed));
+
+struct info_sector {
+    __u32	magic;		/* Magic for info sector ('RRaA') */
+    __u8	junk[0x1dc];
+    __u32	reserved1;	/* Nothing as far as I can tell */
+    __u32	signature;	/* 0x61417272 ('rrAa') */
+    __u32	free_clusters;	/* Free cluster count.  -1 if unknown */
+    __u32	next_cluster;	/* Most recently allocated cluster. */
+    __u32	reserved2[3];
+    __u16	reserved3;
+    __u16	boot_sign;
+};
+
+typedef struct {
+    __u8	name[8],ext[3];	/* name and extension */
+    __u8	attr;		/* attribute bits */
+    __u8	lcase;		/* Case for base and extension */
+    __u8	ctime_ms;	/* Creation time, milliseconds */
+    __u16	ctime;		/* Creation time */
+    __u16	cdate;		/* Creation date */
+    __u16	adate;		/* Last access date */
+    __u16	starthi;	/* High 16 bits of cluster in FAT32 */
+    __u16	time,date,start;/* time, date and first cluster */
+    __u32	size;		/* file size (in bytes) */
+} DIR_ENT;
+
+typedef struct _dos_file {
+    DIR_ENT dir_ent;
+    char *lfn;
+    loff_t offset;
+    struct _dos_file *parent; /* parent directory */
+    struct _dos_file *next; /* next entry */
+    struct _dos_file *first; /* first entry (directory only) */
+} DOS_FILE;
+
+typedef struct {
+    unsigned long value;
+    unsigned long reserved;
+    DOS_FILE *owner;
+    int prev; /* number of previous clusters */
+} FAT_ENTRY;
+
+typedef struct {
+    int nfats;
+    loff_t fat_start;
+    unsigned int fat_size; /* unit is bytes */
+    unsigned int fat_bits; /* size of a FAT entry */
+    unsigned int eff_fat_bits; /* # of used bits in a FAT entry */
+    unsigned long root_cluster; /* 0 for old-style root dir */
+    loff_t root_start;
+    unsigned int root_entries;
+    loff_t data_start;
+    unsigned int cluster_size;
+    unsigned long clusters;
+    loff_t fsinfo_start; /* 0 if not present */
+    long free_clusters;
+    loff_t backupboot_start; /* 0 if not present */
+    FAT_ENTRY *fat;
+} DOS_FS;
+
+#ifndef offsetof
+#define offsetof(t,e)	((int)&(((t *)0)->e))
+#endif
+
+extern int interactive,list,verbose,test,write_immed;
+extern int atari_format;
+extern unsigned n_files;
+extern void *mem_queue;
+
+/* value to use as end-of-file marker */
+#define FAT_EOF(fs)	((atari_format ? 0xfff : 0xff8) | FAT_EXTD(fs))
+#define FAT_IS_EOF(fs,v) ((unsigned long)(v) >= (0xff8|FAT_EXTD(fs)))
+/* value to mark bad clusters */
+#define FAT_BAD(fs)	(0xff7 | FAT_EXTD(fs))
+/* range of values used for bad clusters */
+#define FAT_MIN_BAD(fs)	((atari_format ? 0xff0 : 0xff7) | FAT_EXTD(fs))
+#define FAT_MAX_BAD(fs)	((atari_format ? 0xff7 : 0xff7) | FAT_EXTD(fs))
+#define FAT_IS_BAD(fs,v) ((v) >= FAT_MIN_BAD(fs) && (v) <= FAT_MAX_BAD(fs))
+
+/* return -16 as a number with fs->fat_bits bits */
+#define FAT_EXTD(fs)	(((1 << fs->eff_fat_bits)-1) & ~0xf)
+
+#endif
+
+/* Local Variables: */
+/* tab-width: 8     */
+/* End:             */
diff -pruwN busybox-1.01/util-linux/fat.c busybox-1.01-livebox/util-linux/fat.c
--- busybox-1.01/util-linux/fat.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/fat.c	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,363 @@
+/* fat.c  -  Read/write access to the FAT */
+
+/* Written 1993 by Werner Almesberger */
+
+/* FAT32, VFAT, Atari format support, and various fixes additions May 1998
+ * by Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de> */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "common.h"
+#include "dosfsck.h"
+#include "io.h"
+#include "check.h"
+#include "fat.h"
+
+
+static void get_fat(FAT_ENTRY *entry,void *fat,unsigned long cluster,DOS_FS *fs)
+{
+    unsigned char *ptr;
+
+    switch(fs->fat_bits) {
+      case 12:
+	ptr = &((unsigned char *) fat)[cluster*3/2];
+	entry->value = 0xfff & (cluster & 1 ? (ptr[0] >> 4) | (ptr[1] << 4) :
+	  (ptr[0] | ptr[1] << 8));
+	break;
+      case 16:
+	entry->value = CF_LE_W(((unsigned short *) fat)[cluster]);
+	break;
+      case 32:
+	/* According to M$, the high 4 bits of a FAT32 entry are reserved and
+	 * are not part of the cluster number. So we cut them off. */
+	{
+	    unsigned long e = CF_LE_L(((unsigned int *) fat)[cluster]);
+	    entry->value = e & 0xfffffff;
+	    entry->reserved = e >> 28;
+	}
+	break;
+      default:
+	die("Bad FAT entry size: %d bits.",fs->fat_bits);
+    }
+    entry->owner = NULL;
+}
+
+
+void read_fat(DOS_FS *fs)
+{
+    int eff_size;
+    unsigned long i;
+    void *first,*second,*use;
+    int first_ok,second_ok;
+
+    eff_size = ((fs->clusters+2)*fs->fat_bits+7)/8;
+    first = alloc(eff_size);
+    fs_read(fs->fat_start,eff_size,first);
+    use = first;
+    if (fs->nfats > 1) {
+	second = alloc(eff_size);
+	fs_read(fs->fat_start+fs->fat_size,eff_size,second);
+    }
+    else
+	second = NULL;
+    if (second && memcmp(first,second,eff_size) != 0) {
+	FAT_ENTRY first_media, second_media;
+	get_fat(&first_media,first,0,fs);
+	get_fat(&second_media,second,0,fs);
+	first_ok = (first_media.value & FAT_EXTD(fs)) == FAT_EXTD(fs);
+	second_ok = (second_media.value & FAT_EXTD(fs)) == FAT_EXTD(fs);
+	if (first_ok && !second_ok) {
+	    printf("FATs differ - using first FAT.\n");
+	    fs_write(fs->fat_start+fs->fat_size,eff_size,use = first);
+	}
+	if (!first_ok && second_ok) {
+	    printf("FATs differ - using second FAT.\n");
+	    fs_write(fs->fat_start,eff_size,use = second);
+	}
+	if (first_ok && second_ok) {
+	    if (interactive) {
+		printf("FATs differ but appear to be intact. Use which FAT ?\n"
+		  "1) Use first FAT\n2) Use second FAT\n");
+		if (get_key("12","?") == '1')
+		    fs_write(fs->fat_start+fs->fat_size,eff_size,use = first);
+		else fs_write(fs->fat_start,eff_size,use = second);
+	    }
+	    else {
+		printf("FATs differ but appear to be intact. Using first "
+		  "FAT.\n");
+		fs_write(fs->fat_start+fs->fat_size,eff_size,use = first);
+	    }
+	}
+	if (!first_ok && !second_ok) {
+	    printf("Both FATs appear to be corrupt. Giving up.\n");
+	    exit(1);
+	}
+    }
+    fs->fat = qalloc(&mem_queue,sizeof(FAT_ENTRY)*(fs->clusters+2));
+    for (i = 2; i < fs->clusters+2; i++) get_fat(&fs->fat[i],use,i,fs);
+    for (i = 2; i < fs->clusters+2; i++)
+	if (fs->fat[i].value >= fs->clusters+2 &&
+	    (fs->fat[i].value < FAT_MIN_BAD(fs))) {
+	    printf("Cluster %ld out of range (%ld > %ld). Setting to EOF.\n",
+		   i-2,fs->fat[i].value,fs->clusters+2-1);
+	    set_fat(fs,i,-1);
+	}
+    free(first);
+    if (second)
+	free(second);
+}
+
+
+void set_fat(DOS_FS *fs,unsigned long cluster,unsigned long new)
+{
+    unsigned char data[4];
+    int size;
+    loff_t offs;
+
+    if ((long)new == -1)
+	new = FAT_EOF(fs);
+    else if ((long)new == -2)
+	new = FAT_BAD(fs);
+    switch( fs->fat_bits ) {
+      case 12:
+	offs = fs->fat_start+cluster*3/2;
+	if (cluster & 1) {
+	    data[0] = ((new & 0xf) << 4) | (fs->fat[cluster-1].value >> 8);
+	    data[1] = new >> 4;
+	}
+	else {
+	    data[0] = new & 0xff;
+	    data[1] = (new >> 8) | (cluster == fs->clusters-1 ? 0 :
+	      (0xff & fs->fat[cluster+1].value) << 4);
+	}
+	size = 2;
+	break;
+      case 16:
+	offs = fs->fat_start+cluster*2;
+	*(unsigned short *) data = CT_LE_W(new);
+	size = 2;
+	break;
+      case 32:
+	offs = fs->fat_start+cluster*4;
+	/* According to M$, the high 4 bits of a FAT32 entry are reserved and
+	 * are not part of the cluster number. So we never touch them. */
+	*(unsigned long *) data = CT_LE_L( (new & 0xfffffff) |
+					   (fs->fat[cluster].reserved << 28) );
+	size = 4;
+	break;
+      default:
+	die("Bad FAT entry size: %d bits.",fs->fat_bits);
+    }
+    fs->fat[cluster].value = new;
+    fs_write(offs,size,&data);
+    fs_write(offs+fs->fat_size,size,&data);
+}
+
+
+int bad_cluster(DOS_FS *fs,unsigned long cluster)
+{
+    return FAT_IS_BAD(fs,fs->fat[cluster].value);
+}
+
+
+unsigned long next_cluster(DOS_FS *fs,unsigned long cluster)
+{
+    unsigned long value;
+
+    value = fs->fat[cluster].value;
+    if (FAT_IS_BAD(fs,value))
+	die("Internal error: next_cluster on bad cluster");
+    return FAT_IS_EOF(fs,value) ? -1 : value;
+}
+
+
+loff_t cluster_start(DOS_FS *fs,unsigned long cluster)
+{
+    return fs->data_start+((loff_t)cluster-2)*fs->cluster_size;
+}
+
+
+void set_owner(DOS_FS *fs,unsigned long cluster,DOS_FILE *owner)
+{
+    if (owner && fs->fat[cluster].owner)
+	die("Internal error: attempt to change file owner");
+    fs->fat[cluster].owner = owner;
+}
+
+
+DOS_FILE *get_owner(DOS_FS *fs,unsigned long cluster)
+{
+    return fs->fat[cluster].owner;
+}
+
+
+void fix_bad(DOS_FS *fs)
+{
+    unsigned long i;
+
+    if (verbose)
+	printf("Checking for bad clusters.\n");
+    for (i = 2; i < fs->clusters+2; i++)
+	if (!get_owner(fs,i) && !FAT_IS_BAD(fs,fs->fat[i].value))
+	    if (!fs_test(cluster_start(fs,i),fs->cluster_size)) {
+		printf("Cluster %lu is unreadable.\n",i);
+		set_fat(fs,i,-2);
+	    }
+}
+
+
+void reclaim_free(DOS_FS *fs)
+{
+    int reclaimed;
+    unsigned long i;
+
+    if (verbose)
+	printf("Checking for unused clusters.\n");
+    reclaimed = 0;
+    for (i = 2; i < fs->clusters+2; i++)
+	if (!get_owner(fs,i) && fs->fat[i].value &&
+	    !FAT_IS_BAD(fs,fs->fat[i].value)) {
+	    set_fat(fs,i,0);
+	    reclaimed++;
+	}
+    if (reclaimed)
+	printf("Reclaimed %d unused cluster%s (%d bytes).\n",reclaimed,
+	  reclaimed == 1 ?  "" : "s",reclaimed*fs->cluster_size);
+}
+
+
+static void tag_free(DOS_FS *fs,DOS_FILE *ptr)
+{
+    DOS_FILE *owner;
+    int prev;
+    unsigned long i,walk;
+
+    for (i = 2; i < fs->clusters+2; i++)
+	if (fs->fat[i].value && !FAT_IS_BAD(fs,fs->fat[i].value) &&
+	    !get_owner(fs,i) && !fs->fat[i].prev) {
+	    prev = 0;
+	    for (walk = i; walk > 0 && walk != -1;
+		 walk = next_cluster(fs,walk)) {
+		if (!(owner = get_owner(fs,walk))) set_owner(fs,walk,ptr);
+		else if (owner != ptr)
+		        die("Internal error: free chain collides with file");
+		    else {
+			set_fat(fs,prev,-1);
+			break;
+		    }
+		prev = walk;
+	    }
+	}
+}
+
+
+void reclaim_file(DOS_FS *fs)
+{
+    DOS_FILE dummy;
+    int reclaimed,files,changed;
+    unsigned long i,next,walk;
+
+    if (verbose)
+	printf("Reclaiming unconnected clusters.\n");
+    for (i = 2; i < fs->clusters+2; i++) fs->fat[i].prev = 0;
+    for (i = 2; i < fs->clusters+2; i++) {
+	next = fs->fat[i].value;
+	if (!get_owner(fs,i) && next && next < fs->clusters+2) {
+	    if (get_owner(fs,next) || !fs->fat[next].value ||
+		FAT_IS_BAD(fs,fs->fat[next].value)) set_fat(fs,i,-1);
+	    else fs->fat[next].prev++;
+	}
+    }
+    do {
+	tag_free(fs,&dummy);
+	changed = 0;
+	for (i = 2; i < fs->clusters+2; i++)
+	    if (fs->fat[i].value && !FAT_IS_BAD(fs,fs->fat[i].value) &&
+		!get_owner(fs, i)) {
+		if (!fs->fat[fs->fat[i].value].prev--)
+		    die("Internal error: prev going below zero");
+		set_fat(fs,i,-1);
+		changed = 1;
+		printf("Broke cycle at cluster %lu in free chain.\n",i);
+		break;
+	    }
+    }
+    while (changed);
+    files = reclaimed = 0;
+    for (i = 2; i < fs->clusters+2; i++)
+	if (get_owner(fs,i) == &dummy && !fs->fat[i].prev) {
+	    DIR_ENT de;
+		__u32   tmpVal;
+	    loff_t offset;
+	    files++;
+	    offset = alloc_rootdir_entry(fs,&de,"FSCK%04dREC");
+	    de.start = CT_LE_W(i&0xffff);
+	    if (fs->fat_bits == 32)
+		de.starthi = CT_LE_W(i>>16);
+	    for (walk = i; walk > 0 && walk != -1;
+		 walk = next_cluster(fs,walk)) {
+		tmpVal=CF_LE_L(de.size)+fs->cluster_size;	
+		de.size = CT_LE_L(tmpVal);
+		reclaimed++;
+	    }
+	    fs_write(offset,sizeof(DIR_ENT),&de);
+	}
+    if (reclaimed)
+	printf("Reclaimed %d unused cluster%s (%d bytes) in %d chain%s.\n",
+	  reclaimed,reclaimed == 1 ? "" : "s",reclaimed*fs->cluster_size,files,
+	  files == 1 ? "" : "s");
+}
+
+
+unsigned long update_free(DOS_FS *fs)
+{
+    unsigned long i;
+    unsigned long freesize = 0;
+    int do_set = 0;
+
+    for (i = 2; i < fs->clusters+2; i++)
+	if (!get_owner(fs,i) && !FAT_IS_BAD(fs,fs->fat[i].value))
+	    ++freesize;
+
+    if (!fs->fsinfo_start)
+	return freesize;
+
+    if (verbose)
+	printf("Checking free cluster summary.\n");
+    if (fs->free_clusters >= 0) {
+	if (freesize != fs->free_clusters) {
+	    printf( "Free cluster summary wrong (%ld vs. really %ld)\n",
+		    fs->free_clusters,freesize);
+	    if (interactive)
+		printf( "1) Correct\n2) Don't correct\n" );
+	    else printf( "  Auto-correcting.\n" );
+	    if (!interactive || get_key("12","?") == '1')
+		do_set = 1;
+	}
+    }
+    else {
+	printf( "Free cluster summary uninitialized (should be %ld)\n", freesize );
+	if (interactive)
+	    printf( "1) Set it\n2) Leave it uninitialized\n" );
+	else printf( "  Auto-setting.\n" );
+	if (!interactive || get_key("12","?") == '1')
+	    do_set = 1;
+    }
+
+    if (do_set) {
+	fs->free_clusters = freesize;
+	freesize = CT_LE_L(freesize);
+	fs_write(fs->fsinfo_start+offsetof(struct info_sector,free_clusters),
+		 sizeof(freesize),&freesize);
+    }
+
+    return freesize;
+}
+
+/* Local Variables: */
+/* tab-width: 8     */
+/* End:             */
diff -pruwN busybox-1.01/util-linux/fat.h busybox-1.01-livebox/util-linux/fat.h
--- busybox-1.01/util-linux/fat.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/fat.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,64 @@
+/* fat.h  -  Read/write access to the FAT */
+
+/* Written 1993 by Werner Almesberger */
+
+
+#ifndef _FAT_H
+#define _FAT_H
+
+void read_fat(DOS_FS *fs);
+
+/* Loads the FAT of the file system described by FS. Initializes the FAT,
+   replaces broken FATs and rejects invalid cluster entries. */
+
+void set_fat(DOS_FS *fs,unsigned long cluster,unsigned long new);
+
+/* Changes the value of the CLUSTERth cluster of the FAT of FS to NEW. Special
+   values of NEW are -1 (EOF, 0xff8 or 0xfff8) and -2 (bad sector, 0xff7 or
+   0xfff7) */
+
+int bad_cluster(DOS_FS *fs,unsigned long cluster);
+
+/* Returns a non-zero integer if the CLUSTERth cluster is marked as bad or zero
+   otherwise. */
+
+unsigned long next_cluster(DOS_FS *fs,unsigned long cluster);
+
+/* Returns the number of the cluster following CLUSTER, or -1 if this is the
+   last cluster of the respective cluster chain. CLUSTER must not be a bad
+   cluster. */
+
+loff_t cluster_start(DOS_FS *fs,unsigned long cluster);
+
+/* Returns the byte offset of CLUSTER, relative to the respective device. */
+
+void set_owner(DOS_FS *fs,unsigned long cluster,DOS_FILE *owner);
+
+/* Sets the owner pointer of the respective cluster to OWNER. If OWNER was NULL
+   before, it can be set to NULL or any non-NULL value. Otherwise, only NULL is
+   accepted as the new value. */
+
+DOS_FILE *get_owner(DOS_FS *fs,unsigned long cluster);
+
+/* Returns the owner of the repective cluster or NULL if the cluster has no
+   owner. */
+
+void fix_bad(DOS_FS *fs);
+
+/* Scans the disk for currently unused bad clusters and marks them as bad. */
+
+void reclaim_free(DOS_FS *fs);
+
+/* Marks all allocated, but unused clusters as free. */
+
+void reclaim_file(DOS_FS *fs);
+
+/* Scans the FAT for chains of allocated, but unused clusters and creates files
+   for them in the root directory. Also tries to fix all inconsistencies (e.g.
+   loops, shared clusters, etc.) in the process. */
+
+unsigned long update_free(DOS_FS *fs);
+
+/* Updates free cluster count in FSINFO sector. */
+
+#endif
diff -pruwN busybox-1.01/util-linux/fdisk.c busybox-1.01-livebox/util-linux/fdisk.c
--- busybox-1.01/util-linux/fdisk.c	2005-08-17 03:29:17.000000000 +0200
+++ busybox-1.01-livebox/util-linux/fdisk.c	2011-02-01 13:48:39.000000000 +0100
@@ -13,6 +13,47 @@
 #define UTIL_LINUX_VERSION "2.12"
 
 #define PROC_PARTITIONS "/proc/partitions"
+//#define CONFIG_FEATURE_FDISK_WRITABLE
+
+/* Defines from config.h generated by configure on package util-linux 2.13-pre7 */
+/* These defines make fdisk works properly with NTFS fs on extented partition   */
+#define HAVE_ASM_PAGE_H 1
+#define HAVE_FSEEKO 1
+#define HAVE_FSYNC 1
+#define HAVE_GETDOMAINNAME 1
+#define HAVE_INET_ATON 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_LANGINFO_H 1
+#define HAVE_LCHOWN 1
+#define HAVE_LIBUTIL 1
+#define HAVE_LINUX_BLKPG_H 1
+#define HAVE_LINUX_COMPILER_H 1
+#define HAVE_LINUX_RAW_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_NANOSLEEP 1
+#define HAVE_PERSONALITY 1
+#define HAVE_PTY_H 1
+#define HAVE_SCSI_SCSI_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_STRING_H 1
+#define HAVE_SYS_STAT_H 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_SYS_USER_H 1
+#define HAVE_TM_GMTOFF 1
+#define HAVE_UNISTD_H 1
+#define HAVE_UPDWTMP 1
+#define HAVE_WIDECHAR 1
+#define NEED_LIBCRYPT 1
+#define ONLY_LISTED_SHELLS 1
+#define PG_BELL 1
+#define REQUIRE_PASSWORD 1
+#define STDC_HEADERS 1
+#define USE_TTY_GROUP 1
+#define _FILE_OFFSET_BITS 64
+#define _LARGEFILE_SOURCE 1
+/* End of generated defines */
 
 #include <features.h>
 #include <sys/types.h>
diff -pruwN busybox-1.01/util-linux/file.c busybox-1.01-livebox/util-linux/file.c
--- busybox-1.01/util-linux/file.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/file.c	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,250 @@
+/* file.c  -  Additional file attributes */
+
+/* Written 1993 by Werner Almesberger */
+
+/* FAT32, VFAT, Atari format support, and various fixes additions May 1998
+ * by Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de> */
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+
+#define _LINUX_STAT_H		/* hack to avoid inclusion of <linux/stat.h> */
+#define _LINUX_STRING_H_	/* hack to avoid inclusion of <linux/string.h>*/
+#define _LINUX_FS_H             /* hack to avoid inclusion of <linux/fs.h> */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+# define __KERNEL__
+# include <asm/types.h>
+# undef __KERNEL__
+#endif
+
+#include <linux/msdos_fs.h>
+
+#include "common.h"
+#include "file.h"
+
+
+FDSC *fp_root = NULL;
+
+
+static void put_char(char **p,unsigned char c)
+{
+    if ((c >= ' ' && c < 0x7f) || c >= 0xa0) *(*p)++ = c;
+    else {
+	*(*p)++ = '\\';
+	*(*p)++ = '0'+(c >> 6);
+	*(*p)++ = '0'+((c >> 3) & 7);
+	*(*p)++ = '0'+(c & 7);
+    }
+}
+
+
+char *file_name(unsigned char *fixed)
+{
+    static char path[MSDOS_NAME*4+2];
+    char *p;
+    int i,j;
+
+    p = path;
+    for (i = j =  0; i < 8; i++)
+	if (fixed[i] != ' ') {
+	    while (j++ < i) *p++ = ' ';
+	    put_char(&p,fixed[i]);
+	}
+    if (strncmp(fixed+8,"   ",3)) {
+	*p++ = '.';
+	for (i = j =  0; i < 3; i++)
+	    if (fixed[i+8] != ' ') {
+		while (j++ < i) *p++ = ' ';
+		put_char(&p,fixed[i+8]);
+	    }
+    }
+    *p = 0;
+    return path;
+}
+
+
+int file_cvt(unsigned char *name,unsigned char *fixed)
+{
+    unsigned char c;
+    int size,ext,cnt;
+
+    size = 8;
+    ext = 0;
+    while (*name) {
+	c = *name;
+	if (c < ' ' || c > 0x7e || strchr("*?<>|\"/",c)) {
+	    printf("Invalid character in name. Use \\ooo for special "
+	      "characters.\n");
+	    return 0;
+	}
+	if (c == '.') {
+	    if (ext) {
+		printf("Duplicate dots in name.\n");
+		return 0;
+	    }
+	    while (size--) *fixed++ = ' ';
+	    size = 3;
+	    ext = 1;
+	    name++;
+	    continue;
+	}
+	if (c == '\\') {
+	    c = 0;
+	    for (cnt = 3; cnt; cnt--) {
+		if (*name < '0' || *name > '7') {
+		    printf("Invalid octal character.\n");
+		    return 0;
+		}
+		c = c*8+*name++-'0';
+	    }
+	    if (cnt < 4) {
+		printf("Expected three octal digits.\n");
+		return 0;
+	    }
+	    name += 3;
+	}
+	if (islower(c)) c = toupper(c);
+	if (size) {
+	    *fixed++ = c;
+	    size--;
+	}
+	name++;
+    }
+    if (*name || size == 8) return 0;
+    if (!ext) {
+	while (size--) *fixed++ = ' ';
+	size = 3;
+    }
+    while (size--) *fixed++ = ' ';
+    return 1;
+}
+
+
+void file_add(char *path,FD_TYPE type)
+{
+    FDSC **current,*walk;
+    char name[MSDOS_NAME];
+    char *here;
+
+    current = &fp_root;
+    if (*path != '/') die("%s: Absolute path required.",path);
+    path++;
+    while (1) {
+	if ((here = strchr(path,'/'))) *here = 0;
+	if (!file_cvt(path,name)) exit(2);
+	for (walk = *current; walk; walk = walk->next)
+	    if (!here && (!strncmp(name,walk->name,MSDOS_NAME) || (type ==
+	      fdt_undelete && !strncmp(name+1,walk->name+1,MSDOS_NAME-1))))
+		die("Ambiguous name: \"%s\"",path);
+	    else if (here && !strncmp(name,walk->name,MSDOS_NAME)) break;
+	if (!walk) {
+	    walk = alloc(sizeof(FDSC));
+	    strncpy(walk->name,name,MSDOS_NAME);
+	    walk->type = here ? fdt_none : type;
+	    walk->first = NULL;
+	    walk->next = *current;
+	    *current = walk;
+	}
+	current = &walk->first;
+	if (!here) break;
+	*here = '/';
+	path = here+1;
+    }
+}
+
+
+FDSC **file_cd(FDSC **curr,char *fixed)
+{
+    FDSC **walk;
+
+    if (!curr || !*curr) return NULL;
+    for (walk = curr; *walk; walk = &(*walk)->next)
+	if (!strncmp((*walk)->name,fixed,MSDOS_NAME) && (*walk)->first)
+	    return &(*walk)->first;
+    return NULL;
+}
+
+
+static FDSC **file_find(FDSC **dir,char *fixed)
+{
+    if (!dir || !*dir) return NULL;
+    if (*(unsigned char *) fixed == DELETED_FLAG) {
+	while (*dir) {
+	    if (!strncmp((*dir)->name+1,fixed+1,MSDOS_NAME-1) && !(*dir)->first)
+		return dir;
+	    dir = &(*dir)->next;
+	}
+	return NULL;
+    }
+    while (*dir) {
+	if (!strncmp((*dir)->name,fixed,MSDOS_NAME) && !(*dir)->first)
+	    return dir;
+	dir = &(*dir)->next;
+    }
+    return NULL;
+}
+
+
+FD_TYPE file_type(FDSC **curr,char *fixed)
+{
+    FDSC **this;
+
+    if ((this = file_find(curr,fixed))) return (*this)->type;
+    return fdt_none;
+}
+
+
+void file_modify(FDSC **curr,char *fixed)
+{
+    FDSC **this,*next;
+
+    if (!(this = file_find(curr,fixed)))
+	die("Internal error: file_find failed");
+    switch ((*this)->type) {
+	case fdt_drop:
+	    printf("Dropping %s\n",file_name(fixed));
+	    *(unsigned char *) fixed = DELETED_FLAG;
+	    break;
+	case fdt_undelete:
+	    *fixed = *(*this)->name;
+	    printf("Undeleting %s\n",file_name(fixed));
+	    break;
+	default:
+	    die("Internal error: file_modify");
+    }
+    next = (*this)->next;
+    free(*this);
+    *this = next;
+}
+
+
+static void report_unused(FDSC *this)
+{
+    FDSC *next;
+
+    while (this) {
+	next = this->next;
+	if (this->first) report_unused(this->first);
+	else if (this->type != fdt_none)
+		printf("Warning: did not %s file %s\n",this->type == fdt_drop ?
+		  "drop" : "undelete",file_name(this->name));
+	free(this);
+	this = next;
+    }
+}
+
+
+void file_unused(void)
+{
+    report_unused(fp_root);
+}
+
+/* Local Variables: */
+/* tab-width: 8     */
+/* End:             */
diff -pruwN busybox-1.01/util-linux/file.h busybox-1.01-livebox/util-linux/file.h
--- busybox-1.01/util-linux/file.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/file.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,55 @@
+/* file.h  -  Additional file attributes */
+
+/* Written 1993 by Werner Almesberger */
+
+
+#ifndef _FILE_H
+#define _FILE_H
+
+typedef enum { fdt_none,fdt_drop,fdt_undelete } FD_TYPE;
+
+typedef struct _fptr {
+    char name[MSDOS_NAME];
+    FD_TYPE type;
+    struct _fptr *first; /* first entry */
+    struct _fptr *next; /* next file in directory */
+} FDSC;
+
+
+extern FDSC *fp_root;
+
+
+char *file_name(unsigned char *fixed);
+
+/* Returns a pointer to a pretty-printed representation of a fixed MS-DOS file
+   name. */
+
+int file_cvt(unsigned char *name,unsigned char *fixed);
+
+/* Converts a pretty-printed file name to the fixed MS-DOS format. Returns a
+   non-zero integer on success, zero on failure. */
+
+void file_add(char *path,FD_TYPE type);
+
+/* Define special attributes for a path. TYPE can be either FDT_DROP or
+   FDT_UNDELETE. */
+
+FDSC **file_cd(FDSC **curr,char *fixed);
+
+/* Returns a pointer to the directory descriptor of the subdirectory FIXED of
+   CURR, or NULL if no such subdirectory exists. */
+
+FD_TYPE file_type(FDSC **curr,char *fixed);
+
+/* Returns the attribute of the file FIXED in directory CURR or FDT_NONE if no
+   such file exists or if CURR is NULL. */
+
+void file_modify(FDSC **curr,char *fixed);
+
+/* Performs the necessary operation on the entry of CURR that is named FIXED. */
+
+void file_unused(void);
+
+/* Displays warnings for all unused file attributes. */
+
+#endif
diff -pruwN busybox-1.01/util-linux/io.c busybox-1.01-livebox/util-linux/io.c
--- busybox-1.01/util-linux/io.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/io.c	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,191 @@
+/* io.c  -  Virtual disk input/output */
+
+/* Written 1993 by Werner Almesberger */
+
+/*
+ * Thu Feb 26 01:15:36 CET 1998: Martin Schulze <joey@infodrom.north.de>
+ *	Fixed nasty bug that caused every file with a name like
+ *	xxxxxxxx.xxx to be treated as bad name that needed to be fixed.
+ */
+
+/* FAT32, VFAT, Atari format support, and various fixes additions May 1998
+ * by Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de> */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/fd.h>
+
+#include "dosfsck.h"
+#include "common.h"
+#include "io.h"
+
+
+typedef struct _change {
+    void *data;
+    loff_t pos;
+    int size;
+    struct _change *next;
+} CHANGE;
+
+
+static CHANGE *changes,*last;
+static int fd,did_change = 0;
+
+unsigned device_no;
+
+
+#ifdef __DJGPP__
+#include "volume.h"	/* DOS lowlevel disk access functions */
+#undef llseek
+static loff_t llseek( int fd, loff_t offset, int whence )
+{
+    if ((whence != SEEK_SET) || (fd == 4711)) return -1; /* only those supported */
+    return VolumeSeek(offset);
+}
+#define open OpenVolume
+#define close CloseVolume
+#define read(a,b,c) ReadVolume(b,c)
+#define write(a,b,c) WriteVolume(b,c)
+#endif
+
+void fs_open(char *path,int rw)
+{
+    struct stat stbuf;
+    
+    if ((fd = open(path,rw ? O_RDWR : O_RDONLY)) < 0)
+	pdie("open %s",path);
+    changes = last = NULL;
+    did_change = 0;
+
+#ifndef _DJGPP_
+    if (fstat(fd,&stbuf) < 0)
+	pdie("fstat %s",path);
+    device_no = S_ISBLK(stbuf.st_mode) ? (stbuf.st_rdev >> 8) & 0xff : 0;
+#else
+    if (IsWorkingOnImageFile()) {
+	if (fstat(GetVolumeHandle(),&stbuf) < 0)
+	    pdie("fstat image %s",path);
+	device_no = 0;
+    }
+    else {
+        /* return 2 for floppy, 1 for ramdisk, 7 for loopback  */
+        /* used by boot.c in Atari mode: floppy always FAT12,  */
+        /* loopback / ramdisk only FAT12 if usual floppy size, */
+        /* harddisk always FAT16 on Atari... */
+        device_no = (GetVolumeHandle() < 2) ? 2 : 1;
+        /* telling "floppy" for A:/B:, "ramdisk" for the rest */
+    }
+#endif
+}
+
+
+void fs_read(loff_t pos,int size,void *data)
+{
+    CHANGE *walk;
+    int got;
+
+    if (llseek(fd,pos,0) != pos) pdie("Seek to %lld",pos);
+    if ((got = read(fd,data,size)) < 0) pdie("Read %d bytes at %lld",size,pos);
+    if (got != size) die("Got %d bytes instead of %d at %lld",got,size,pos);
+    for (walk = changes; walk; walk = walk->next) {
+	if (walk->pos < pos+size && walk->pos+walk->size > pos) {
+	    if (walk->pos < pos)
+		memcpy(data,(char *) walk->data+pos-walk->pos,min(size,
+		  walk->size-pos+walk->pos));
+	    else memcpy((char *) data+walk->pos-pos,walk->data,min(walk->size,
+		  size+pos-walk->pos));
+	}
+    }
+}
+
+
+int fs_test(loff_t pos,int size)
+{
+    void *scratch;
+    int okay;
+
+    if (llseek(fd,pos,0) != pos) pdie("Seek to %lld",pos);
+    scratch = alloc(size);
+    okay = read(fd,scratch,size) == size;
+    free(scratch);
+    return okay;
+}
+
+
+void fs_write(loff_t pos,int size,void *data)
+{
+    CHANGE *new;
+    int did;
+
+    if (write_immed) {
+	did_change = 1;
+	if (llseek(fd,pos,0) != pos) pdie("Seek to %lld",pos);
+	if ((did = write(fd,data,size)) == size) return;
+	if (did < 0) pdie("Write %d bytes at %lld",size,pos);
+	die("Wrote %d bytes instead of %d at %lld",did,size,pos);
+    }
+    new = alloc(sizeof(CHANGE));
+    new->pos = pos;
+    memcpy(new->data = alloc(new->size = size),data,size);
+    new->next = NULL;
+    if (last) last->next = new;
+    else changes = new;
+    last = new;
+}
+
+
+static void fs_flush(void)
+{
+    CHANGE *this;
+    int size;
+
+    while (changes) {
+	this = changes;
+	changes = changes->next;
+	if (llseek(fd,this->pos,0) != this->pos)
+	    fprintf(stderr,"Seek to %lld failed: %s\n  Did not write %d bytes.\n",
+	      (long long)this->pos,strerror(errno),this->size);
+	else if ((size = write(fd,this->data,this->size)) < 0)
+		fprintf(stderr,"Writing %d bytes at %lld failed: %s\n",this->size,
+		  (long long)this->pos,strerror(errno));
+	    else if (size != this->size)
+		    fprintf(stderr,"Wrote %d bytes instead of %d bytes at %lld."
+		      "\n",size,this->size,(long long)this->pos);
+	free(this->data);
+	free(this);
+    }
+}
+
+
+int fs_close(int doflush)
+{
+    CHANGE *next;
+    int changed;
+
+    changed = !!changes;
+    if (doflush) fs_flush();
+    else while (changes) {
+	    next = changes->next;
+	    free(changes->data);
+	    free(changes);
+	    changes = next;
+	}
+    if (close(fd) < 0) pdie("closing file system");
+    return changed || did_change;
+}
+
+
+int fs_changed(void)
+{
+    return !!changes || did_change;
+}
+
+/* Local Variables: */
+/* tab-width: 8     */
+/* End:             */
diff -pruwN busybox-1.01/util-linux/io.h busybox-1.01-livebox/util-linux/io.h
--- busybox-1.01/util-linux/io.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/io.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,53 @@
+/* io.h  -  Virtual disk input/output */
+
+/* Written 1993 by Werner Almesberger */
+
+/* FAT32, VFAT, Atari format support, and various fixes additions May 1998
+ * by Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de> */
+
+
+#ifndef _IO_H
+#define _IO_H
+
+#include <sys/types.h> /* for loff_t */
+
+/* In earlier versions, an own llseek() was used, but glibc lseek() is
+ * sufficient (or even better :) for 64 bit offsets in the meantime */
+#define llseek lseek
+
+void fs_open(char *path,int rw);
+
+/* Opens the file system PATH. If RW is zero, the file system is opened
+   read-only, otherwise, it is opened read-write. */
+
+void fs_read(loff_t pos,int size,void *data);
+
+/* Reads SIZE bytes starting at POS into DATA. Performs all applicable
+   changes. */
+
+int fs_test(loff_t pos,int size);
+
+/* Returns a non-zero integer if SIZE bytes starting at POS can be read without
+   errors. Otherwise, it returns zero. */
+
+void fs_write(loff_t pos,int size,void *data);
+
+/* If write_immed is non-zero, SIZE bytes are written from DATA to the disk,
+   starting at POS. If write_immed is zero, the change is added to a list in
+   memory. */
+
+int fs_close(int doflush);
+
+/* Closes the file system, performs all pending changes if WRITE is non-zero
+   and removes the list of changes. Returns a non-zero integer if the file
+   system has been changed since the last fs_open, zero otherwise. */
+
+int fs_changed(void);
+
+/* Determines whether the file system has changed. See fs_close. */
+
+extern unsigned device_no;
+
+/* Major number of device (0 if file) and size (in 512 byte sectors) */
+
+#endif
diff -pruwN busybox-1.01/util-linux/lfn.c busybox-1.01-livebox/util-linux/lfn.c
--- busybox-1.01/util-linux/lfn.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/lfn.c	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,477 @@
+/* lfn.c  -  Functions for handling VFAT long filenames */
+
+/* Written 1998 by Roman Hodek */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <time.h>
+
+#include "common.h"
+#include "io.h"
+#include "dosfsck.h"
+#include "lfn.h"
+#include "file.h"
+
+typedef struct {
+	__u8    id;		/* sequence number for slot */
+	__u8    name0_4[10];	/* first 5 characters in name */
+	__u8    attr;		/* attribute byte */
+	__u8    reserved;	/* always 0 */
+	__u8    alias_checksum;	/* checksum for 8.3 alias */
+	__u8    name5_10[12];	/* 6 more characters in name */
+	__u16   start;		/* starting cluster number, 0 in long slots */
+	__u8    name11_12[4];	/* last 2 characters in name */
+} LFN_ENT;
+
+#define LFN_ID_START	0x40
+#define LFN_ID_SLOTMASK	0x1f
+
+#define CHARS_PER_LFN	13
+
+/* These modul-global vars represent the state of the LFN parser */
+unsigned char *lfn_unicode = NULL;
+unsigned char lfn_checksum;
+int lfn_slot = -1;
+loff_t *lfn_offsets = NULL;
+int lfn_parts = 0;
+
+static unsigned char fat_uni2esc[64] = {
+    '0', '1', '2', '3', '4', '5', '6', '7',
+    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
+    'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
+    'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
+    'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',
+    'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
+    'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
+    'u', 'v', 'w', 'x', 'y', 'z', '+', '-'
+};
+
+/* This defines which unicode chars are directly convertable to ISO-8859-1 */
+#define UNICODE_CONVERTABLE(cl,ch)	(ch == 0 && (cl < 0x80 || cl >= 0xa0))
+
+/* for maxlen param */
+#define UNTIL_0		INT_MAX
+
+/* Convert name part in 'lfn' from unicode to ASCII */
+#define CNV_THIS_PART(lfn)				\
+    ({							\
+	char __part_uni[CHARS_PER_LFN*2];		\
+	copy_lfn_part( __part_uni, lfn );		\
+	cnv_unicode( __part_uni, CHARS_PER_LFN, 0 );	\
+    })
+    
+/* Convert name parts collected so far (from previous slots) from unicode to
+ * ASCII */
+#define CNV_PARTS_SO_FAR()					\
+	(cnv_unicode( lfn_unicode+(lfn_slot*CHARS_PER_LFN*2),	\
+		      lfn_parts*CHARS_PER_LFN, 0 ))
+
+/* This function converts an unicode string to a normal ASCII string, assuming
+ * ISO-8859-1 charset. Characters not in 8859-1 are converted to the same
+ * escape notation as used by the kernel, i.e. the uuencode-like ":xxx" */
+static char *cnv_unicode( const unsigned char *uni, int maxlen, int use_q )
+{
+    const unsigned char *up;
+    unsigned char *out, *cp;
+    int len, val;
+    
+    for( len = 0, up = uni; (up-uni)/2 < maxlen && (up[0] || up[1]); up += 2 ){
+	if (UNICODE_CONVERTABLE(up[0],up[1]))
+	    ++len;
+	else
+	    len += 4;
+    }
+    cp = out = use_q ? qalloc( &mem_queue, len+1 ) : alloc( len+1 );
+
+    for( up = uni; (up-uni)/2 < maxlen && (up[0] || up[1]); up += 2 ) {
+	if (UNICODE_CONVERTABLE(up[0],up[1]))
+	    *cp++ = up[0];
+	else {
+	    /* here the same escape notation is used as in the Linux kernel */
+	    *cp++ = ':';
+	    val = (up[1] << 8) + up[0];
+	    cp[2] = fat_uni2esc[val & 0x3f];
+	    val >>= 6;
+	    cp[1] = fat_uni2esc[val & 0x3f];
+	    val >>= 6;
+	    cp[0] = fat_uni2esc[val & 0x3f];
+	    cp += 3;
+	}
+    }
+    *cp = 0;
+
+    return( out );
+}
+
+
+static void copy_lfn_part( char *dst, LFN_ENT *lfn )
+{
+    memcpy( dst,    lfn->name0_4,   10 );
+    memcpy( dst+10, lfn->name5_10,  12 );
+    memcpy( dst+22, lfn->name11_12, 4 );
+}
+
+
+static void clear_lfn_slots( int start, int end )
+{
+    int i;
+    LFN_ENT empty;
+
+    /* New dir entry is zeroed except first byte, which is set to 0xe5.
+     * This is to avoid that some FAT-reading OSes (not Linux! ;) stop reading
+     * a directory at the first zero entry...
+     */
+    memset( &empty, 0, sizeof(empty) );
+    empty.id = DELETED_FLAG;
+    
+    for( i = start; i <= end; ++i ) {
+	fs_write( lfn_offsets[i], sizeof(LFN_ENT), &empty );
+    }
+}
+
+void lfn_reset( void )
+{
+    if (lfn_unicode)
+	free( lfn_unicode );
+    lfn_unicode = NULL;
+    if (lfn_offsets)
+	free( lfn_offsets );
+    lfn_offsets = NULL;
+    lfn_slot = -1;
+}
+
+
+/* This function is only called with de->attr == VFAT_LN_ATTR. It stores part
+ * of the long name. */
+void lfn_add_slot( DIR_ENT *de, loff_t dir_offset )
+{
+    LFN_ENT *lfn = (LFN_ENT *)de;
+    unsigned offset;
+
+    if (de->attr != VFAT_LN_ATTR)
+	die("lfn_add_slot called with non-LFN directory entry");
+
+    if (lfn->id & LFN_ID_START) {
+	if (lfn_slot != -1) {
+	    int can_clear = 0;
+	    /* There is already a LFN "in progess", so it is an error that a
+	     * new start entry is here. */
+	    /* Causes: 1) if slot# == expected: start bit set mysteriously, 2)
+	     *         old LFN overwritten by new one */
+	    /* Fixes: 1) delete previous LFN 2) if slot# == expected and
+	     *        checksum ok: clear start bit */
+	    /* XXX: Should delay that until next LFN known (then can better
+	     * display the name) */
+	    printf( "A new long file name starts within an old one.\n" );
+	    if ((lfn->id & LFN_ID_SLOTMASK) == lfn_slot &&
+		lfn->alias_checksum == lfn_checksum) {
+		char *part1 = CNV_THIS_PART(lfn);
+		char *part2 = CNV_PARTS_SO_FAR();
+		printf( "  It could be that the LFN start bit is wrong here\n"
+			"  if \"%s\" seems to match \"%s\".\n", part1, part2 );
+		free( part1 );
+		free( part2 );
+		can_clear = 1;
+	    }
+	    if (interactive) {
+		printf( "1: Delete previous LFN\n2: Leave it as it is.\n" );
+		if (can_clear)
+		    printf( "3: Clear start bit and concatenate LFNs\n" );
+	    }
+	    else printf( "  Not auto-correcting this.\n" );
+	    if (interactive) {
+		switch( get_key( can_clear ? "123" : "12", "?" )) {
+		  case '1':
+		    clear_lfn_slots( 0, lfn_parts-1 );
+		    lfn_reset();
+		    break;
+		  case '2':
+		    break;
+		  case '3':
+		    lfn->id &= ~LFN_ID_START;
+		    fs_write( dir_offset+offsetof(LFN_ENT,id),
+			      sizeof(lfn->id), &lfn->id );
+		    break;
+		}
+	    }
+	}
+	lfn_slot = lfn->id & LFN_ID_SLOTMASK;
+	lfn_checksum = lfn->alias_checksum;
+	lfn_unicode = alloc( (lfn_slot*CHARS_PER_LFN+1)*2 );
+	lfn_offsets = alloc( lfn_slot*sizeof(loff_t) );
+	lfn_parts = 0;
+    }
+    else if (lfn_slot == -1) {
+	/* No LFN in progress, but slot found; start bit missing */
+	/* Causes: 1) start bit got lost, 2) Previous slot with start bit got
+	 *         lost */
+	/* Fixes: 1) delete LFN, 2) set start bit */
+	char *part = CNV_THIS_PART(lfn);
+	printf( "Long filename fragment \"%s\" found outside a LFN "
+		"sequence.\n  (Maybe the start bit is missing on the "
+		"last fragment)\n", part );
+	if (interactive) {
+	    printf( "1: Delete fragment\n2: Leave it as it is.\n"
+		    "3: Set start bit\n" );
+	}
+	else printf( "  Not auto-correcting this.\n" );
+	if (interactive) {
+	    switch( get_key( "123", "?" )) {
+	      case '1':
+		if (!lfn_offsets)
+		    lfn_offsets = alloc( sizeof(loff_t) );
+		lfn_offsets[0] = dir_offset;
+		clear_lfn_slots( 0, 0 );
+		lfn_reset();
+		return;
+	      case '2':
+		lfn_reset();
+		return;
+	      case '3':
+		lfn->id |= LFN_ID_START;
+		fs_write( dir_offset+offsetof(LFN_ENT,id),
+			  sizeof(lfn->id), &lfn->id );
+		lfn_slot = lfn->id & LFN_ID_SLOTMASK;
+		lfn_checksum = lfn->alias_checksum;
+		lfn_unicode = alloc( (lfn_slot*CHARS_PER_LFN+1)*2 );
+		lfn_offsets = alloc( lfn_slot*sizeof(loff_t) );
+		lfn_parts = 0;
+		break;
+	    }
+	}
+    }
+    else if ((lfn->id & LFN_ID_SLOTMASK) != lfn_slot) {
+	/* wrong sequence number */
+	/* Causes: 1) seq-no destroyed */
+	/* Fixes: 1) delete LFN, 2) fix number (maybe only if following parts
+	 *        are ok?, maybe only if checksum is ok?) (Attention: space
+	 *        for name was allocated before!) */
+	int can_fix = 0;
+	printf( "Unexpected long filename sequence number "
+		"(%d vs. expected %d).\n",
+		(lfn->id & LFN_ID_SLOTMASK), lfn_slot );
+	if (lfn->alias_checksum == lfn_checksum) {
+	    char *part1 = CNV_THIS_PART(lfn);
+	    char *part2 = CNV_PARTS_SO_FAR();
+	    printf( "  It could be that just the number is wrong\n"
+		    "  if \"%s\" seems to match \"%s\".\n", part1, part2 );
+	    free( part1 );
+	    free( part2 );
+	    can_fix = 1;
+	}
+	if (interactive) {
+	    printf( "1: Delete LFN\n2: Leave it as it is (and ignore LFN so far)\n" );
+	    if (can_fix)
+		printf( "3: Correct sequence number\n" );
+	}
+	else printf( "  Not auto-correcting this.\n" );
+	if (interactive) {
+	    switch( get_key( can_fix ? "123" : "12", "?" )) {
+	      case '1':
+		lfn_offsets[lfn_parts++] = dir_offset;
+		clear_lfn_slots( 0, lfn_parts-1 );
+		lfn_reset();
+		return;
+	      case '2':
+		lfn_reset();
+		return;
+	      case '3':
+		lfn->id = (lfn->id & ~LFN_ID_SLOTMASK) | lfn_slot;
+		fs_write( dir_offset+offsetof(LFN_ENT,id),
+			  sizeof(lfn->id), &lfn->id );
+		break;
+	    }
+	}
+    }
+
+    if (lfn->alias_checksum != lfn_checksum) {
+	/* checksum mismatch */
+	/* Causes: 1) checksum field here destroyed */
+	/* Fixes: 1) delete LFN, 2) fix checksum */
+	printf( "Checksum in long filename part wrong "
+		"(%02x vs. expected %02x).\n",
+		lfn->alias_checksum, lfn_checksum );
+	if (interactive) {
+	    printf( "1: Delete LFN\n2: Leave it as it is.\n"
+		    "3: Correct checksum\n" );
+	}
+	else printf( "  Not auto-correcting this.\n" );
+	if (interactive) {
+	    switch( get_key( "123", "?" )) {
+	      case '1':
+		lfn_offsets[lfn_parts++] = dir_offset;
+		clear_lfn_slots( 0, lfn_parts-1 );
+		lfn_reset();
+		return;
+	      case '2':
+		break;
+	      case '3':
+		lfn->alias_checksum = lfn_checksum;
+		fs_write( dir_offset+offsetof(LFN_ENT,alias_checksum),
+			  sizeof(lfn->alias_checksum), &lfn->alias_checksum );
+		break;
+	    }
+	}
+    }
+
+    if (lfn_slot != -1) {
+	lfn_slot--;
+	offset = lfn_slot * CHARS_PER_LFN*2;
+	copy_lfn_part( lfn_unicode+offset, lfn );
+	if (lfn->id & LFN_ID_START)
+	    lfn_unicode[offset+26] = lfn_unicode[offset+27] = 0;
+	lfn_offsets[lfn_parts++] = dir_offset;
+    }
+
+    if (lfn->reserved != 0) {
+	printf( "Reserved field in VFAT long filename slot is not 0 "
+		"(but 0x%02x).\n", lfn->reserved );
+	if (interactive)
+	    printf( "1: Fix.\n2: Leave it.\n" );
+	else printf( "Auto-setting to 0.\n" );
+	if (!interactive || get_key("12","?") == '1') {
+	    lfn->reserved = 0;
+	    fs_write( dir_offset+offsetof(LFN_ENT,reserved),
+		      sizeof(lfn->reserved), &lfn->reserved );
+	}
+    }
+    if (lfn->start != CT_LE_W(0)) {
+	printf( "Start cluster field in VFAT long filename slot is not 0 "
+		"(but 0x%04x).\n", lfn->start );
+	if (interactive)
+	    printf( "1: Fix.\n2: Leave it.\n" );
+	else printf( "Auto-setting to 0.\n" );
+	if (!interactive || get_key("12","?") == '1') {
+	    lfn->start = CT_LE_W(0);
+	    fs_write( dir_offset+offsetof(LFN_ENT,start),
+		      sizeof(lfn->start),&lfn->start );
+	}
+    }
+}
+
+
+/* This function is always called when de->attr != VFAT_LN_ATTR is found, to
+ * retrieve the previously constructed LFN. */
+char *lfn_get( DIR_ENT *de )
+{
+    char *lfn;
+    __u8 sum;
+    int i;
+    
+    if (de->attr == VFAT_LN_ATTR)
+	die("lfn_get called with LFN directory entry");
+
+#if 0
+    if (de->lcase)
+	printf( "lcase=%02x\n",de->lcase );
+#endif
+
+    if (lfn_slot == -1)
+	/* no long name for this file */
+	return NULL;
+
+    if (lfn_slot != 0) {
+	/* The long name isn't finished yet. */
+	/* Causes: 1) LFN slot overwritten by non-VFAT aware tool */
+	/* Fixes: 1) delete LFN 2) move overwriting entry to somewhere else
+	 * and let user enter missing part of LFN (hard to do :-()
+	 * 3) renumber entries and truncate name */
+	char *long_name = CNV_PARTS_SO_FAR();
+	char *short_name = file_name(de->name);
+	printf( "Unfinished long file name \"%s\".\n"
+		"  (Start may have been overwritten by %s)\n",
+		long_name, short_name );
+	free( long_name );
+	if (interactive) {
+	    printf( "1: Delete LFN\n2: Leave it as it is.\n"
+		    "3: Fix numbering (truncates long name and attaches "
+		    "it to short name %s)\n", short_name );
+	}
+	else printf( "  Not auto-correcting this.\n" );
+	if (interactive) {
+	    switch( get_key( "123", "?" )) {
+	      case '1':
+		clear_lfn_slots( 0, lfn_parts-1 );
+		lfn_reset();
+		return NULL;
+	      case '2':
+		lfn_reset();
+		return NULL;
+	      case '3':
+		for( i = 0; i < lfn_parts; ++i ) {
+		    __u8 id = (lfn_parts-i) | (i==0 ? LFN_ID_START : 0);
+		    fs_write( lfn_offsets[i]+offsetof(LFN_ENT,id),
+			      sizeof(id), &id );
+		}
+		memmove( lfn_unicode, lfn_unicode+lfn_slot*CHARS_PER_LFN*2,
+			 lfn_parts*CHARS_PER_LFN*2 );
+		break;
+	    }
+	}
+    }
+
+    for (sum = 0, i = 0; i < 11; i++)
+	sum = (((sum&1) << 7) | ((sum&0xfe) >> 1)) + de->name[i];
+    if (sum != lfn_checksum) {
+	/* checksum doesn't match, long name doesn't apply to this alias */
+	/* Causes: 1) alias renamed */
+	/* Fixes: 1) Fix checksum in LFN entries */
+	char *long_name = CNV_PARTS_SO_FAR();
+	char *short_name = file_name(de->name);
+	printf( "Wrong checksum for long file name \"%s\".\n"
+		"  (Short name %s may have changed without updating the long name)\n",
+		long_name, short_name );
+	free( long_name );
+	if (interactive) {
+	    printf( "1: Delete LFN\n2: Leave it as it is.\n"
+		    "3: Fix checksum (attaches to short name %s)\n",
+		    short_name );
+	}
+	else printf( "  Not auto-correcting this.\n" );
+	if (interactive) {
+	    switch( get_key( "123", "?" )) {
+	      case '1':
+		clear_lfn_slots( 0, lfn_parts-1 );
+		lfn_reset();
+		return NULL;
+	      case '2':
+		lfn_reset();
+		return NULL;
+	      case '3':
+		for( i = 0; i < lfn_parts; ++i ) {
+		    fs_write( lfn_offsets[i]+offsetof(LFN_ENT,alias_checksum),
+			      sizeof(sum), &sum );
+		}
+		break;
+	    }
+	}
+    }
+
+    lfn = cnv_unicode( lfn_unicode, UNTIL_0, 1 );
+    lfn_reset();
+    return( lfn );
+}
+
+void lfn_check_orphaned(void)
+{
+    char *long_name;
+
+    if (lfn_slot == -1)
+	return;
+
+    long_name = CNV_PARTS_SO_FAR();
+    printf("Orphaned long file name part \"%s\"\n", long_name);
+    if (interactive)
+	printf( "1: Delete.\n2: Leave it.\n" );
+    else printf( "  Auto-deleting.\n" );
+    if (!interactive || get_key("12","?") == '1') {
+	clear_lfn_slots(0, lfn_parts - 1);
+    }
+    lfn_reset();
+}
+
+/* Local Variables: */
+/* tab-width: 8     */
+/* End:             */
diff -pruwN busybox-1.01/util-linux/lfn.h busybox-1.01-livebox/util-linux/lfn.h
--- busybox-1.01/util-linux/lfn.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/lfn.h	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,20 @@
+/* lfn.h  -  Functions for handling VFAT long filenames */
+
+/* Written 1998 by Roman Hodek */
+
+
+#ifndef _LFN_H
+#define _LFN_H
+
+void lfn_reset( void );
+/* Reset the state of the LFN parser. */
+
+void lfn_add_slot( DIR_ENT *de, loff_t dir_offset );
+/* Process a dir slot that is a VFAT LFN entry. */
+
+char *lfn_get( DIR_ENT *de );
+/* Retrieve the long name for the proper dir entry. */
+
+void lfn_check_orphaned(void);
+
+#endif
diff -pruwN busybox-1.01/util-linux/Makefile.in busybox-1.01-livebox/util-linux/Makefile.in
--- busybox-1.01/util-linux/Makefile.in	2005-08-17 03:29:17.000000000 +0200
+++ busybox-1.01-livebox/util-linux/Makefile.in	2011-02-01 13:48:39.000000000 +0100
@@ -29,6 +29,14 @@ UTILLINUX-$(CONFIG_FBSET)		+=fbset.o
 UTILLINUX-$(CONFIG_FDFLUSH)		+=fdflush.o
 UTILLINUX-$(CONFIG_FDFORMAT)		+=fdformat.o
 UTILLINUX-$(CONFIG_FDISK)		+=fdisk.o
+UTILLINUX-$(CONFIG_MOUNT)		+=mount.o
+UTILLINUX-$(CONFIG_NFSMOUNT)		+=nfsmount.o
+UTILLINUX-$(CONFIG_PIVOT_ROOT)		+=pivot_root.o
+UTILLINUX-$(CONFIG_RDATE)		+=rdate.o
+UTILLINUX-$(CONFIG_SWAPONOFF)		+=swaponoff.o
+UTILLINUX-$(CONFIG_UMOUNT)		+=umount.o
+UTILLINUX-$(CONFIG_MKDOSFS)		+=mkdosfs.o
+UTILLINUX-$(CONFIG_DOSFSCK)		+=boot.o check.o common.o dosfsck.o fat.o file.o io.o lfn.o
 UTILLINUX-$(CONFIG_FREERAMDISK)		+=freeramdisk.o
 UTILLINUX-$(CONFIG_FSCK_MINIX)		+=fsck_minix.o
 UTILLINUX-$(CONFIG_GETOPT)		+=getopt.o
@@ -38,12 +46,6 @@ UTILLINUX-$(CONFIG_LOSETUP)		+=losetup.o
 UTILLINUX-$(CONFIG_MKFS_MINIX)		+=mkfs_minix.o
 UTILLINUX-$(CONFIG_MKSWAP)		+=mkswap.o
 UTILLINUX-$(CONFIG_MORE)		+=more.o
-UTILLINUX-$(CONFIG_MOUNT)		+=mount.o
-UTILLINUX-$(CONFIG_NFSMOUNT)		+=nfsmount.o
-UTILLINUX-$(CONFIG_PIVOT_ROOT)		+=pivot_root.o
-UTILLINUX-$(CONFIG_RDATE)		+=rdate.o
-UTILLINUX-$(CONFIG_SWAPONOFF)		+=swaponoff.o
-UTILLINUX-$(CONFIG_UMOUNT)		+=umount.o
 
 libraries-y+=$(UTILLINUX_DIR)$(UTILLINUX_AR)
 
diff -pruwN busybox-1.01/util-linux/mkdosfs.c busybox-1.01-livebox/util-linux/mkdosfs.c
--- busybox-1.01/util-linux/mkdosfs.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.01-livebox/util-linux/mkdosfs.c	2011-02-01 13:48:39.000000000 +0100
@@ -0,0 +1,1735 @@
+/*
+   Filename:     mkdosfs.c
+   Version:      0.3b (Yggdrasil)
+   Author:       Dave Hudson
+   Started:      24th August 1994
+   Last Updated: 7th May 1998
+   Updated by:   Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
+   Target O/S:   Linux (2.x)
+
+   Description: Utility to allow an MS-DOS filesystem to be created
+   under Linux.  A lot of the basic structure of this program has been
+   borrowed from Remy Card's "mke2fs" code.
+
+   As far as possible the aim here is to make the "mkdosfs" command
+   look almost identical to the other Linux filesystem make utilties,
+   eg bad blocks are still specified as blocks, not sectors, but when
+   it comes down to it, DOS is tied to the idea of a sector (512 bytes
+   as a rule), and not the block.  For example the boot block does not
+   occupy a full cluster.
+
+   Fixes/additions May 1998 by Roman Hodek
+   <Roman.Hodek@informatik.uni-erlangen.de>:
+   - Atari format support
+   - New options -A, -S, -C
+   - Support for filesystems > 2GB
+   - FAT32 support
+   
+   Copying:     Copyright 1993, 1994 David Hudson (dave@humbug.demon.co.uk)
+
+   Portions copyright 1992, 1993 Remy Card (card@masi.ibp.fr)
+   and 1991 Linus Torvalds (torvalds@klaava.helsinki.fi)
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+
+/* Include the header files */
+
+#define VERSION                 "2.11"
+#define VERSION_DATE    "12 Mar 2005"
+
+#include <fcntl.h>
+#include <linux/hdreg.h>
+#include <linux/fs.h>
+#include <linux/fd.h>
+#include <endian.h>
+#include <mntent.h>
+#include <signal.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <time.h>
+#include <errno.h>
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+# define __KERNEL__
+# include <asm/types.h>
+# undef __KERNEL__
+#endif
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+
+#include <asm/byteorder.h>
+#ifdef __le16_to_cpu
+/* ++roman: 2.1 kernel headers define these function, they're probably more
+ * efficient then coding the swaps machine-independently. */
+#define CF_LE_W	__le16_to_cpu
+#define CF_LE_L	__le32_to_cpu
+#define CT_LE_W	__cpu_to_le16
+#define CT_LE_L	__cpu_to_le32
+#else
+#define CF_LE_W(v) ((((v) & 0xff) << 8) | (((v) >> 8) & 0xff))
+#define CF_LE_L(v) (((unsigned)(v)>>24) | (((unsigned)(v)>>8)&0xff00) | \
+               (((unsigned)(v)<<8)&0xff0000) | ((unsigned)(v)<<24))
+#define CT_LE_W(v) CF_LE_W(v)
+#define CT_LE_L(v) CF_LE_L(v)
+#endif /* defined(__le16_to_cpu) */
+    
+#else
+
+#define CF_LE_W(v) (v)
+#define CF_LE_L(v) (v)
+#define CT_LE_W(v) (v)
+#define CT_LE_L(v) (v)
+
+#endif /* __BIG_ENDIAN */
+
+/* In earlier versions, an own llseek() was used, but glibc lseek() is
+ * sufficient (or even better :) for 64 bit offsets in the meantime */
+#define llseek lseek
+
+/* Constant definitions */
+
+#define TRUE 1			/* Boolean constants */
+#define FALSE 0
+
+#define TEST_BUFFER_BLOCKS 16
+#define HARD_SECTOR_SIZE   512
+#define SECTORS_PER_BLOCK ( BLOCK_SIZE / HARD_SECTOR_SIZE )
+
+
+/* Macro definitions */
+
+/* Report a failure message and return a failure error code */
+
+#define die( str ) fatal_error( "%s: " str "\n" )
+
+
+/* Mark a cluster in the FAT as bad */
+
+#define mark_sector_bad( sector ) mark_FAT_sector( sector, FAT_BAD )
+
+/* Compute ceil(a/b) */
+
+inline int
+cdiv (int a, int b)
+{
+  return (a + b - 1) / b;
+}
+
+/* MS-DOS filesystem structures -- I included them here instead of
+   including linux/msdos_fs.h since that doesn't include some fields we
+   need */
+
+#define ATTR_RO      1		/* read-only */
+#define ATTR_HIDDEN  2		/* hidden */
+#define ATTR_SYS     4		/* system */
+#define ATTR_VOLUME  8		/* volume label */
+#define ATTR_DIR     16		/* directory */
+#define ATTR_ARCH    32		/* archived */
+
+#define ATTR_NONE    0		/* no attribute bits */
+#define ATTR_UNUSED  (ATTR_VOLUME | ATTR_ARCH | ATTR_SYS | ATTR_HIDDEN)
+	/* attribute bits that are copied "as is" */
+
+/* FAT values */
+#define FAT_EOF      (atari_format ? 0x0fffffff : 0x0ffffff8)
+#define FAT_BAD      0x0ffffff7
+
+#define MSDOS_EXT_SIGN 0x29	/* extended boot sector signature */
+#define MSDOS_FAT12_SIGN "FAT12   "	/* FAT12 filesystem signature */
+#define MSDOS_FAT16_SIGN "FAT16   "	/* FAT16 filesystem signature */
+#define MSDOS_FAT32_SIGN "FAT32   "	/* FAT32 filesystem signature */
+
+#define BOOT_SIGN 0xAA55	/* Boot sector magic number */
+
+#define MAX_CLUST_12	((1 << 12) - 16)
+#define MAX_CLUST_16	((1 << 16) - 16)
+#define MIN_CLUST_32    65529
+/* M$ says the high 4 bits of a FAT32 FAT entry are reserved and don't belong
+ * to the cluster number. So the max. cluster# is based on 2^28 */
+#define MAX_CLUST_32	((1 << 28) - 16)
+
+#define FAT12_THRESHOLD	4085
+
+#define OLDGEMDOS_MAX_SECTORS	32765
+#define GEMDOS_MAX_SECTORS	65531
+#define GEMDOS_MAX_SECTOR_SIZE	(16*1024)
+
+#define BOOTCODE_SIZE		448
+#define BOOTCODE_FAT32_SIZE	420
+
+/* __attribute__ ((packed)) is used on all structures to make gcc ignore any
+ * alignments */
+
+struct msdos_volume_info {
+  __u8		drive_number;	/* BIOS drive number */
+  __u8		RESERVED;	/* Unused */
+  __u8		ext_boot_sign;	/* 0x29 if fields below exist (DOS 3.3+) */
+  __u8		volume_id[4];	/* Volume ID number */
+  __u8		volume_label[11];/* Volume label */
+  __u8		fs_type[8];	/* Typically FAT12 or FAT16 */
+} __attribute__ ((packed));
+
+struct msdos_boot_sector
+{
+  __u8	        boot_jump[3];	/* Boot strap short or near jump */
+  __u8          system_id[8];	/* Name - can be used to special case
+				   partition manager volumes */
+  __u8          sector_size[2];	/* bytes per logical sector */
+  __u8          cluster_size;	/* sectors/cluster */
+  __u16         reserved;	/* reserved sectors */
+  __u8          fats;		/* number of FATs */
+  __u8          dir_entries[2];	/* root directory entries */
+  __u8          sectors[2];	/* number of sectors */
+  __u8          media;		/* media code (unused) */
+  __u16         fat_length;	/* sectors/FAT */
+  __u16         secs_track;	/* sectors per track */
+  __u16         heads;		/* number of heads */
+  __u32         hidden;		/* hidden sectors (unused) */
+  __u32         total_sect;	/* number of sectors (if sectors == 0) */
+  union {
+    struct {
+      struct msdos_volume_info vi;
+      __u8	boot_code[BOOTCODE_SIZE];
+    } __attribute__ ((packed)) _oldfat;
+    struct {
+      __u32	fat32_length;	/* sectors/FAT */
+      __u16	flags;		/* bit 8: fat mirroring, low 4: active fat */
+      __u8	version[2];	/* major, minor filesystem version */
+      __u32	root_cluster;	/* first cluster in root directory */
+      __u16	info_sector;	/* filesystem info sector */
+      __u16	backup_boot;	/* backup boot sector */
+      __u16	reserved2[6];	/* Unused */
+      struct msdos_volume_info vi;
+      __u8	boot_code[BOOTCODE_FAT32_SIZE];
+    } __attribute__ ((packed)) _fat32;
+  } __attribute__ ((packed)) fstype;
+  __u16		boot_sign;
+} __attribute__ ((packed));
+#define fat32	fstype._fat32
+#define oldfat	fstype._oldfat
+
+struct fat32_fsinfo {
+  __u32		reserved1;	/* Nothing as far as I can tell */
+  __u32		signature;	/* 0x61417272L */
+  __u32		free_clusters;	/* Free cluster count.  -1 if unknown */
+  __u32		next_cluster;	/* Most recently allocated cluster.
+				 * Unused under Linux. */
+  __u32		reserved2[4];
+};
+
+struct msdos_dir_entry
+  {
+    char	name[8], ext[3];	/* name and extension */
+    __u8        attr;			/* attribute bits */
+    __u8	lcase;			/* Case for base and extension */
+    __u8	ctime_ms;		/* Creation time, milliseconds */
+    __u16	ctime;			/* Creation time */
+    __u16	cdate;			/* Creation date */
+    __u16	adate;			/* Last access date */
+    __u16	starthi;		/* high 16 bits of first cl. (FAT32) */
+    __u16	time, date, start;	/* time, date and first cluster */
+    __u32	size;			/* file size (in bytes) */
+  } __attribute__ ((packed));
+
+/* The "boot code" we put into the filesystem... it writes a message and
+   tells the user to try again */
+
+char dummy_boot_jump[3] = { 0xeb, 0x3c, 0x90 };
+
+char dummy_boot_jump_m68k[2] = { 0x60, 0x1c };
+
+#define MSG_OFFSET_OFFSET 3
+char dummy_boot_code[BOOTCODE_SIZE] =
+  "\x0e"			/* push cs */
+  "\x1f"			/* pop ds */
+  "\xbe\x5b\x7c"		/* mov si, offset message_txt */
+				/* write_msg: */
+  "\xac"			/* lodsb */
+  "\x22\xc0"			/* and al, al */
+  "\x74\x0b"			/* jz key_press */
+  "\x56"			/* push si */
+  "\xb4\x0e"			/* mov ah, 0eh */
+  "\xbb\x07\x00"		/* mov bx, 0007h */
+  "\xcd\x10"			/* int 10h */
+  "\x5e"			/* pop si */
+  "\xeb\xf0"			/* jmp write_msg */
+				/* key_press: */
+  "\x32\xe4"			/* xor ah, ah */
+  "\xcd\x16"			/* int 16h */
+  "\xcd\x19"			/* int 19h */
+  "\xeb\xfe"			/* foo: jmp foo */
+				/* message_txt: */
+
+  "This is not a bootable disk.  Please insert a bootable floppy and\r\n"
+  "press any key to try again ... \r\n";
+
+#define MESSAGE_OFFSET 29	/* Offset of message in above code */
+
+/* Global variables - the root of all evil :-) - see these and weep! */
+
+static char *program_name = "mkdosfs";	/* Name of the program */
+static char *device_name = NULL;	/* Name of the device on which to create the filesystem */
+static int atari_format = 0;	/* Use Atari variation of MS-DOS FS format */
+static int check = FALSE;	/* Default to no readablity checking */
+static int verbose = 0;		/* Default to verbose mode off */
+static long volume_id;		/* Volume ID number */
+static time_t create_time;	/* Creation time */
+static char volume_name[] = "           "; /* Volume name */
+static unsigned long long blocks;	/* Number of blocks in filesystem */
+static int sector_size = 512;	/* Size of a logical sector */
+static int sector_size_set = 0; /* User selected sector size */
+static int backup_boot = 0;	/* Sector# of backup boot sector */
+static int reserved_sectors = 0;/* Number of reserved sectors */
+static int badblocks = 0;	/* Number of bad blocks in the filesystem */
+static int nr_fats = 2;		/* Default number of FATs to produce */
+static int size_fat = 0;	/* Size in bits of FAT entries */
+static int size_fat_by_user = 0; /* 1 if FAT size user selected */
+static int dev = -1;		/* FS block device file handle */
+static int  ignore_full_disk = 0; /* Ignore warning about 'full' disk devices */
+static off_t currently_testing = 0;	/* Block currently being tested (if autodetect bad blocks) */
+static struct msdos_boot_sector bs;	/* Boot sector data */
+static int start_data_sector;	/* Sector number for the start of the data area */
+static int start_data_block;	/* Block number for the start of the data area */
+static unsigned char *fat;	/* File allocation table */
+static unsigned char *info_sector;	/* FAT32 info sector */
+static struct msdos_dir_entry *root_dir;	/* Root directory */
+static int size_root_dir;	/* Size of the root directory in bytes */
+static int sectors_per_cluster = 0;	/* Number of sectors per disk cluster */
+static int root_dir_entries = 0;	/* Number of root directory entries */
+static char *blank_sector;		/* Blank sector - all zeros */
+static int hidden_sectors = 0;		/* Number of hidden sectors */
+
+
+/* Function prototype definitions */
+
+static void fatal_error (const char *fmt_string) __attribute__((noreturn));
+static void mark_FAT_cluster (int cluster, unsigned int value);
+static void mark_FAT_sector (int sector, unsigned int value);
+static long do_check (char *buffer, int try, off_t current_block);
+static void alarm_intr (int alnum);
+static void check_blocks (void);
+static void get_list_blocks (char *filename);
+static int valid_offset (int fd, loff_t offset);
+static unsigned long long count_blocks (char *filename);
+static void check_mount (char *dev_name);
+static void establish_params (int device_num, int size);
+static void setup_tables (void);
+static void write_tables (void);
+
+
+/* The function implementations */
+
+/* Handle the reporting of fatal errors.  Volatile to let gcc know that this doesn't return */
+
+static void
+fatal_error (const char *fmt_string)
+{
+  fprintf (stderr, fmt_string, program_name, device_name);
+  exit (1);			/* The error exit code is 1! */
+}
+
+
+/* Mark the specified cluster as having a particular value */
+
+static void
+mark_FAT_cluster (int cluster, unsigned int value)
+{
+  switch( size_fat ) {
+    case 12:
+      value &= 0x0fff;
+      if (((cluster * 3) & 0x1) == 0)
+	{
+	  fat[3 * cluster / 2] = (unsigned char) (value & 0x00ff);
+	  fat[(3 * cluster / 2) + 1] = (unsigned char) ((fat[(3 * cluster / 2) + 1] & 0x00f0)
+						 | ((value & 0x0f00) >> 8));
+	}
+      else
+	{
+	  fat[3 * cluster / 2] = (unsigned char) ((fat[3 * cluster / 2] & 0x000f) | ((value & 0x000f) << 4));
+	  fat[(3 * cluster / 2) + 1] = (unsigned char) ((value & 0x0ff0) >> 4);
+	}
+      break;
+
+    case 16:
+      value &= 0xffff;
+      fat[2 * cluster] = (unsigned char) (value & 0x00ff);
+      fat[(2 * cluster) + 1] = (unsigned char) (value >> 8);
+      break;
+
+    case 32:
+      value &= 0xfffffff;
+      fat[4 * cluster] =       (unsigned char)  (value & 0x000000ff);
+      fat[(4 * cluster) + 1] = (unsigned char) ((value & 0x0000ff00) >> 8);
+      fat[(4 * cluster) + 2] = (unsigned char) ((value & 0x00ff0000) >> 16);
+      fat[(4 * cluster) + 3] = (unsigned char) ((value & 0xff000000) >> 24);
+      break;
+
+    default:
+      die("Bad FAT size (not 12, 16, or 32)");
+  }
+}
+
+
+/* Mark a specified sector as having a particular value in it's FAT entry */
+
+static void
+mark_FAT_sector (int sector, unsigned int value)
+{
+  int cluster;
+
+  cluster = (sector - start_data_sector) / (int) (bs.cluster_size) /
+	    (sector_size/HARD_SECTOR_SIZE);
+  if (cluster < 0)
+    die ("Invalid cluster number in mark_FAT_sector: probably bug!");
+
+  mark_FAT_cluster (cluster, value);
+}
+
+
+/* Perform a test on a block.  Return the number of blocks that could be read successfully */
+
+static long
+do_check (char *buffer, int try, off_t current_block)
+{
+  long got;
+
+  if (llseek (dev, current_block * BLOCK_SIZE, SEEK_SET) /* Seek to the correct location */
+      != current_block * BLOCK_SIZE)
+    die ("seek failed during testing for blocks");
+
+  got = read (dev, buffer, try * BLOCK_SIZE);	/* Try reading! */
+  if (got < 0)
+    got = 0;
+
+  if (got & (BLOCK_SIZE - 1))
+    printf ("Unexpected values in do_check: probably bugs\n");
+  got /= BLOCK_SIZE;
+
+  return got;
+}
+
+
+/* Alarm clock handler - display the status of the quest for bad blocks!  Then retrigger the alarm for five senconds
+   later (so we can come here again) */
+
+static void
+alarm_intr (int alnum)
+{
+  if (currently_testing >= blocks)
+    return;
+
+  signal (SIGALRM, alarm_intr);
+  alarm (5);
+  if (!currently_testing)
+    return;
+
+  printf ("%lld... ", (unsigned long long)currently_testing);
+  fflush (stdout);
+}
+
+
+static void
+check_blocks (void)
+{
+  int try, got;
+  int i;
+  static char blkbuf[BLOCK_SIZE * TEST_BUFFER_BLOCKS];
+
+  if (verbose)
+    {
+      printf ("Searching for bad blocks ");
+      fflush (stdout);
+    }
+  currently_testing = 0;
+  if (verbose)
+    {
+      signal (SIGALRM, alarm_intr);
+      alarm (5);
+    }
+  try = TEST_BUFFER_BLOCKS;
+  while (currently_testing < blocks)
+    {
+      if (currently_testing + try > blocks)
+	try = blocks - currently_testing;
+      got = do_check (blkbuf, try, currently_testing);
+      currently_testing += got;
+      if (got == try)
+	{
+	  try = TEST_BUFFER_BLOCKS;
+	  continue;
+	}
+      else
+	try = 1;
+      if (currently_testing < start_data_block)
+	die ("bad blocks before data-area: cannot make fs");
+
+      for (i = 0; i < SECTORS_PER_BLOCK; i++)	/* Mark all of the sectors in the block as bad */
+	mark_sector_bad (currently_testing * SECTORS_PER_BLOCK + i);
+      badblocks++;
+      currently_testing++;
+    }
+
+  if (verbose)
+    printf ("\n");
+
+  if (badblocks)
+    printf ("%d bad block%s\n", badblocks,
+	    (badblocks > 1) ? "s" : "");
+}
+
+
+static void
+get_list_blocks (char *filename)
+{
+  int i;
+  FILE *listfile;
+  unsigned long blockno;
+
+  listfile = fopen (filename, "r");
+  if (listfile == (FILE *) NULL)
+    die ("Can't open file of bad blocks");
+
+  while (!feof (listfile))
+    {
+      fscanf (listfile, "%ld\n", &blockno);
+      for (i = 0; i < SECTORS_PER_BLOCK; i++)	/* Mark all of the sectors in the block as bad */
+	mark_sector_bad (blockno * SECTORS_PER_BLOCK + i);
+      badblocks++;
+    }
+  fclose (listfile);
+
+  if (badblocks)
+    printf ("%d bad block%s\n", badblocks,
+	    (badblocks > 1) ? "s" : "");
+}
+
+
+/* Given a file descriptor and an offset, check whether the offset is a valid offset for the file - return FALSE if it
+   isn't valid or TRUE if it is */
+
+static int
+valid_offset (int fd, loff_t offset)
+{
+  char ch;
+
+  if (llseek (fd, offset, SEEK_SET) < 0)
+    return FALSE;
+  if (read (fd, &ch, 1) < 1)
+    return FALSE;
+  return TRUE;
+}
+
+
+/* Given a filename, look to see how many blocks of BLOCK_SIZE are present, returning the answer */
+
+static unsigned long long
+count_blocks (char *filename)
+{
+  off_t high, low;
+  int fd;
+
+  if ((fd = open (filename, O_RDONLY)) < 0)
+    {
+      perror (filename);
+      exit (1);
+    }
+
+  /* first try SEEK_END, which should work on most devices nowadays */
+  if ((low = llseek(fd, 0, SEEK_END)) <= 0) {
+      low = 0;
+      for (high = 1; valid_offset (fd, high); high *= 2)
+	  low = high;
+      while (low < high - 1) {
+	  const loff_t mid = (low + high) / 2;
+	  if (valid_offset (fd, mid))
+	      low = mid;
+	  else
+	      high = mid;
+      }
+      ++low;
+  }
+
+  close (fd);
+  return low / BLOCK_SIZE;
+}
+
+
+/* Check to see if the specified device is currently mounted - abort if it is */
+
+static void
+check_mount (char *dev_name)
+{
+  FILE *f;
+  struct mntent *mnt;
+
+  if ((f = setmntent (MOUNTED, "r")) == NULL)
+    return;
+  while ((mnt = getmntent (f)) != NULL)
+    if (strcmp (dev_name, mnt->mnt_fsname) == 0)
+      die ("%s contains a mounted file system.");
+  endmntent (f);
+}
+
+
+/* Establish the geometry and media parameters for the device */
+
+static void
+establish_params (int device_num,int size)
+{
+  long loop_size;
+  struct hd_geometry geometry;
+  struct floppy_struct param;
+
+  if ((0 == device_num) || ((device_num & 0xff00) == 0x0200))
+    /* file image or floppy disk */
+    {
+      if (0 == device_num)
+	{
+	  param.size = size/512;
+	  switch(param.size)
+	    {
+	    case 720:
+	      param.sect = 9 ;
+	      param.head = 2;
+	      break; 
+	    case 1440:
+	      param.sect = 9;
+	      param.head = 2;
+	      break;
+	    case 2400:
+	      param.sect = 15;
+	      param.head = 2;
+	      break;
+	    case 2880:
+	      param.sect = 18;
+	      param.head = 2;
+	      break;
+	    case 5760:
+	      param.sect = 36;
+	      param.head = 2;
+	      break;
+	    default:
+	      /* fake values */
+	      param.sect = 32;
+	      param.head = 64;
+	      break;
+	    }
+	  
+	}
+      else 	/* is a floppy diskette */
+	{
+	  if (ioctl (dev, FDGETPRM, &param))	/*  Can we get the diskette geometry? */
+	    die ("unable to get diskette geometry for '%s'");
+	}
+      bs.secs_track = CT_LE_W(param.sect);	/*  Set up the geometry information */
+      bs.heads = CT_LE_W(param.head);
+      switch (param.size)	/*  Set up the media descriptor byte */
+	{
+	case 720:		/* 5.25", 2, 9, 40 - 360K */
+	  bs.media = (char) 0xfd;
+	  bs.cluster_size = (char) 2;
+	  bs.dir_entries[0] = (char) 112;
+	  bs.dir_entries[1] = (char) 0;
+	  break;
+
+	case 1440:		/* 3.5", 2, 9, 80 - 720K */
+	  bs.media = (char) 0xf9;
+	  bs.cluster_size = (char) 2;
+	  bs.dir_entries[0] = (char) 112;
+	  bs.dir_entries[1] = (char) 0;
+	  break;
+
+	case 2400:		/* 5.25", 2, 15, 80 - 1200K */
+	  bs.media = (char) 0xf9;
+	  bs.cluster_size = (char)(atari_format ? 2 : 1);
+	  bs.dir_entries[0] = (char) 224;
+	  bs.dir_entries[1] = (char) 0;
+	  break;
+	  
+	case 5760:		/* 3.5", 2, 36, 80 - 2880K */
+	  bs.media = (char) 0xf0;
+	  bs.cluster_size = (char) 2;
+	  bs.dir_entries[0] = (char) 224;
+	  bs.dir_entries[1] = (char) 0;
+	  break;
+
+	case 2880:		/* 3.5", 2, 18, 80 - 1440K */
+	floppy_default:
+	  bs.media = (char) 0xf0;
+	  bs.cluster_size = (char)(atari_format ? 2 : 1);
+	  bs.dir_entries[0] = (char) 224;
+	  bs.dir_entries[1] = (char) 0;
+	  break;
+
+	default:		/* Anything else */
+	  if (0 == device_num)
+	      goto def_hd_params;
+	  else
+	      goto floppy_default;
+	}
+    }
+  else if ((device_num & 0xff00) == 0x0700) /* This is a loop device */
+    {
+      if (ioctl (dev, BLKGETSIZE, &loop_size)) 
+	die ("unable to get loop device size");
+
+      switch (loop_size)  /* Assuming the loop device -> floppy later */
+	{
+	case 720:		/* 5.25", 2, 9, 40 - 360K */
+	  bs.secs_track = CF_LE_W(9);
+	  bs.heads = CF_LE_W(2);
+	  bs.media = (char) 0xfd;
+	  bs.cluster_size = (char) 2;
+	  bs.dir_entries[0] = (char) 112;
+	  bs.dir_entries[1] = (char) 0;
+	  break;
+
+	case 1440:		/* 3.5", 2, 9, 80 - 720K */
+	  bs.secs_track = CF_LE_W(9);
+	  bs.heads = CF_LE_W(2);
+	  bs.media = (char) 0xf9;
+	  bs.cluster_size = (char) 2;
+	  bs.dir_entries[0] = (char) 112;
+	  bs.dir_entries[1] = (char) 0;
+	  break;
+
+	case 2400:		/* 5.25", 2, 15, 80 - 1200K */
+	  bs.secs_track = CF_LE_W(15);
+	  bs.heads = CF_LE_W(2);
+	  bs.media = (char) 0xf9;
+	  bs.cluster_size = (char)(atari_format ? 2 : 1);
+	  bs.dir_entries[0] = (char) 224;
+	  bs.dir_entries[1] = (char) 0;
+	  break;
+	  
+	case 5760:		/* 3.5", 2, 36, 80 - 2880K */
+	  bs.secs_track = CF_LE_W(36);
+	  bs.heads = CF_LE_W(2);
+	  bs.media = (char) 0xf0;
+	  bs.cluster_size = (char) 2;
+	  bs.dir_entries[0] = (char) 224;
+	  bs.dir_entries[1] = (char) 0;
+	  break;
+
+	case 2880:		/* 3.5", 2, 18, 80 - 1440K */
+	  bs.secs_track = CF_LE_W(18);
+	  bs.heads = CF_LE_W(2);
+	  bs.media = (char) 0xf0;
+	  bs.cluster_size = (char)(atari_format ? 2 : 1);
+	  bs.dir_entries[0] = (char) 224;
+	  bs.dir_entries[1] = (char) 0;
+	  break;
+
+	default:		/* Anything else: default hd setup */
+	  printf("Loop device does not match a floppy size, using "
+		 "default hd params\n");
+	  bs.secs_track = CT_LE_W(32); /* these are fake values... */
+	  bs.heads = CT_LE_W(64);
+	  goto def_hd_params;
+	}
+    }
+  else
+    /* Must be a hard disk then! */
+    {
+      /* Can we get the drive geometry? (Note I'm not too sure about */
+      /* whether to use HDIO_GETGEO or HDIO_REQ) */
+      if (ioctl (dev, HDIO_GETGEO, &geometry)) {
+	printf ("unable to get drive geometry, using default 255/63");
+        bs.secs_track = CT_LE_W(63);
+        bs.heads = CT_LE_W(255);
+      }
+      else {
+        bs.secs_track = CT_LE_W(geometry.sectors);	/* Set up the geometry information */
+        bs.heads = CT_LE_W(geometry.heads);
+      }
+    def_hd_params:
+      bs.media = (char) 0xf8; /* Set up the media descriptor for a hard drive */
+      bs.dir_entries[0] = (char) 0;	/* Default to 512 entries */
+      bs.dir_entries[1] = (char) 2;
+      if (!size_fat && blocks*SECTORS_PER_BLOCK > 1064960) {
+	  if (verbose) printf("Auto-selecting FAT32 for large filesystem\n");
+	  size_fat = 32;
+      }
+      if (size_fat == 32) {
+	  /* For FAT32, try to do the same as M$'s format command:
+	   * fs size < 256M: 0.5k clusters
+	   * fs size <   8G: 4k clusters
+	   * fs size <  16G: 8k clusters
+	   * fs size >= 16G: 16k clusters
+	   */
+	  unsigned long sz_mb =
+	      (blocks+(1<<(20-BLOCK_SIZE_BITS))-1) >> (20-BLOCK_SIZE_BITS);
+	  bs.cluster_size = sz_mb >= 16*1024 ? 32 :
+			    sz_mb >=  8*1024 ? 16 :
+			    sz_mb >=     256 ?  8 :
+					        1;
+      }
+      else {
+	  /* FAT12 and FAT16: start at 4 sectors per cluster */
+	  bs.cluster_size = (char) 4;
+      }
+    }
+}
+
+
+/* Create the filesystem data tables */
+
+static void
+setup_tables (void)
+{
+  unsigned num_sectors;
+  unsigned cluster_count = 0, fat_length;
+  unsigned fatdata;			/* Sectors for FATs + data area */
+  struct tm *st_ctime;
+  struct msdos_volume_info *vi = (size_fat == 32 ? &bs.fat32.vi : &bs.oldfat.vi);
+  
+  if (atari_format)
+      /* On Atari, the first few bytes of the boot sector are assigned
+       * differently: The jump code is only 2 bytes (and m68k machine code
+       * :-), then 6 bytes filler (ignored), then 3 byte serial number. */
+    strncpy( bs.system_id-1, "mkdosf", 6 );
+  else
+    strcpy (bs.system_id, "mkdosfs");
+  if (sectors_per_cluster)
+    bs.cluster_size = (char) sectors_per_cluster;
+  if (size_fat == 32)
+    {
+      /* Under FAT32, the root dir is in a cluster chain, and this is
+       * signalled by bs.dir_entries being 0. */
+      bs.dir_entries[0] = bs.dir_entries[1] = (char) 0;
+      root_dir_entries = 0;
+    }
+  else if (root_dir_entries)
+    {
+      /* Override default from establish_params() */
+      bs.dir_entries[0] = (char) (root_dir_entries & 0x00ff);
+      bs.dir_entries[1] = (char) ((root_dir_entries & 0xff00) >> 8);
+    }
+  else
+    root_dir_entries = bs.dir_entries[0] + (bs.dir_entries[1] << 8);
+
+  if (atari_format) {
+    bs.system_id[5] = (unsigned char) (volume_id & 0x000000ff);
+    bs.system_id[6] = (unsigned char) ((volume_id & 0x0000ff00) >> 8);
+    bs.system_id[7] = (unsigned char) ((volume_id & 0x00ff0000) >> 16);
+  }
+  else {
+    vi->volume_id[0] = (unsigned char) (volume_id & 0x000000ff);
+    vi->volume_id[1] = (unsigned char) ((volume_id & 0x0000ff00) >> 8);
+    vi->volume_id[2] = (unsigned char) ((volume_id & 0x00ff0000) >> 16);
+    vi->volume_id[3] = (unsigned char) (volume_id >> 24);
+  }
+
+  if (!atari_format) {
+    memcpy(vi->volume_label, volume_name, 11);
+  
+    memcpy(bs.boot_jump, dummy_boot_jump, 3);
+    /* Patch in the correct offset to the boot code */
+    bs.boot_jump[1] = ((size_fat == 32 ?
+			(char *)&bs.fat32.boot_code :
+			(char *)&bs.oldfat.boot_code) -
+		       (char *)&bs) - 2;
+
+    if (size_fat == 32) {
+	int offset = (char *)&bs.fat32.boot_code -
+		     (char *)&bs + MESSAGE_OFFSET + 0x7c00;
+	if (dummy_boot_code[BOOTCODE_FAT32_SIZE-1])
+	  printf ("Warning: message too long; truncated\n");
+	dummy_boot_code[BOOTCODE_FAT32_SIZE-1] = 0;
+	memcpy(bs.fat32.boot_code, dummy_boot_code, BOOTCODE_FAT32_SIZE);
+	bs.fat32.boot_code[MSG_OFFSET_OFFSET] = offset & 0xff;
+	bs.fat32.boot_code[MSG_OFFSET_OFFSET+1] = offset >> 8;
+    }
+    else {
+	memcpy(bs.oldfat.boot_code, dummy_boot_code, BOOTCODE_SIZE);
+    }
+    bs.boot_sign = CT_LE_W(BOOT_SIGN);
+  }
+  else {
+    memcpy(bs.boot_jump, dummy_boot_jump_m68k, 2);
+  }
+  if (verbose >= 2)
+    printf( "Boot jump code is %02x %02x\n",
+	    bs.boot_jump[0], bs.boot_jump[1] );
+
+  if (!reserved_sectors)
+      reserved_sectors = (size_fat == 32) ? 32 : 1;
+  else {
+      if (size_fat == 32 && reserved_sectors < 2)
+	  die("On FAT32 at least 2 reserved sectors are needed.");
+  }
+  bs.reserved = CT_LE_W(reserved_sectors);
+  if (verbose >= 2)
+    printf( "Using %d reserved sectors\n", reserved_sectors );
+  bs.fats = (char) nr_fats;
+  if (!atari_format || size_fat == 32)
+    bs.hidden = CT_LE_L(hidden_sectors);
+  else {
+    /* In Atari format, hidden is a 16 bit field */
+    __u16 hidden = CT_LE_W(hidden_sectors);
+    if (hidden_sectors & ~0xffff)
+      die("#hidden doesn't fit in 16bit field of Atari format\n");
+    memcpy( &bs.hidden, &hidden, 2 );
+  }
+
+  num_sectors = (long long)blocks*BLOCK_SIZE/sector_size;
+  if (!atari_format) {
+    unsigned fatlength12, fatlength16, fatlength32;
+    unsigned maxclust12, maxclust16, maxclust32;
+    unsigned clust12, clust16, clust32;
+    int maxclustsize;
+    
+    fatdata = num_sectors - cdiv (root_dir_entries * 32, sector_size) -
+	      reserved_sectors;
+
+    if (sectors_per_cluster)
+      bs.cluster_size = maxclustsize = sectors_per_cluster;
+    else
+      /* An initial guess for bs.cluster_size should already be set */
+      maxclustsize = 128;
+
+    if (verbose >= 2)
+      printf( "%d sectors for FAT+data, starting with %d sectors/cluster\n",
+	      fatdata, bs.cluster_size );
+    do {
+      if (verbose >= 2)
+	printf( "Trying with %d sectors/cluster:\n", bs.cluster_size );
+
+      /* The factor 2 below avoids cut-off errors for nr_fats == 1.
+       * The "nr_fats*3" is for the reserved first two FAT entries */
+      clust12 = 2*((long long) fatdata *sector_size + nr_fats*3) /
+	(2*(int) bs.cluster_size * sector_size + nr_fats*3);
+      fatlength12 = cdiv (((clust12+2) * 3 + 1) >> 1, sector_size);
+      /* Need to recalculate number of clusters, since the unused parts of the
+       * FATS and data area together could make up space for an additional,
+       * not really present cluster. */
+      clust12 = (fatdata - nr_fats*fatlength12)/bs.cluster_size;
+      maxclust12 = (fatlength12 * 2 * sector_size) / 3;
+      if (maxclust12 > MAX_CLUST_12)
+	maxclust12 = MAX_CLUST_12;
+      if (verbose >= 2)
+	printf( "FAT12: #clu=%u, fatlen=%u, maxclu=%u, limit=%u\n",
+		clust12, fatlength12, maxclust12, MAX_CLUST_12 );
+      if (clust12 > maxclust12-2) {
+	clust12 = 0;
+	if (verbose >= 2)
+	  printf( "FAT12: too much clusters\n" );
+      }
+
+      clust16 = ((long long) fatdata *sector_size + nr_fats*4) /
+	((int) bs.cluster_size * sector_size + nr_fats*2);
+      fatlength16 = cdiv ((clust16+2) * 2, sector_size);
+      /* Need to recalculate number of clusters, since the unused parts of the
+       * FATS and data area together could make up space for an additional,
+       * not really present cluster. */
+      clust16 = (fatdata - nr_fats*fatlength16)/bs.cluster_size;
+      maxclust16 = (fatlength16 * sector_size) / 2;
+      if (maxclust16 > MAX_CLUST_16)
+	maxclust16 = MAX_CLUST_16;
+      if (verbose >= 2)
+	printf( "FAT16: #clu=%u, fatlen=%u, maxclu=%u, limit=%u\n",
+		clust16, fatlength16, maxclust16, MAX_CLUST_16 );
+      if (clust16 > maxclust16-2) {
+	if (verbose >= 2)
+	  printf( "FAT16: too much clusters\n" );
+	clust16 = 0;
+      }
+      /* The < 4078 avoids that the filesystem will be misdetected as having a
+       * 12 bit FAT. */
+      if (clust16 < FAT12_THRESHOLD && !(size_fat_by_user && size_fat == 16)) {
+	if (verbose >= 2)
+	  printf( clust16 < FAT12_THRESHOLD ?
+		  "FAT16: would be misdetected as FAT12\n" :
+		  "FAT16: too much clusters\n" );
+	clust16 = 0;
+      }
+
+      clust32 = ((long long) fatdata *sector_size + nr_fats*8) /
+	((int) bs.cluster_size * sector_size + nr_fats*4);
+      fatlength32 = cdiv ((clust32+2) * 4, sector_size);
+      /* Need to recalculate number of clusters, since the unused parts of the
+       * FATS and data area together could make up space for an additional,
+       * not really present cluster. */
+      clust32 = (fatdata - nr_fats*fatlength32)/bs.cluster_size;
+      maxclust32 = (fatlength32 * sector_size) / 4;
+      if (maxclust32 > MAX_CLUST_32)
+	maxclust32 = MAX_CLUST_32;
+      if (clust32 && clust32 < MIN_CLUST_32 && !(size_fat_by_user && size_fat == 32)) {
+       clust32 = 0;
+       if (verbose >= 2)
+         printf( "FAT32: not enough clusters (%d)\n", MIN_CLUST_32);
+      }
+      if (verbose >= 2)
+	printf( "FAT32: #clu=%u, fatlen=%u, maxclu=%u, limit=%u\n",
+		clust32, fatlength32, maxclust32, MAX_CLUST_32 );
+      if (clust32 > maxclust32) {
+	clust32 = 0;
+	if (verbose >= 2)
+	  printf( "FAT32: too much clusters\n" );
+      }
+
+      if ((clust12 && (size_fat == 0 || size_fat == 12)) ||
+	  (clust16 && (size_fat == 0 || size_fat == 16)) ||
+	  (clust32 && size_fat == 32))
+	break;
+
+      bs.cluster_size <<= 1;
+    } while (bs.cluster_size && bs.cluster_size <= maxclustsize);
+
+    /* Use the optimal FAT size if not specified;
+     * FAT32 is (not yet) choosen automatically */
+    if (!size_fat) {
+	size_fat = (clust16 > clust12) ? 16 : 12;
+	if (verbose >= 2)
+	  printf( "Choosing %d bits for FAT\n", size_fat );
+    }
+
+    switch (size_fat) {
+      case 12:
+	cluster_count = clust12;
+	fat_length = fatlength12;
+	bs.fat_length = CT_LE_W(fatlength12);
+	memcpy(vi->fs_type, MSDOS_FAT12_SIGN, 8);
+	break;
+
+      case 16:
+	if (clust16 < FAT12_THRESHOLD) {
+	    if (size_fat_by_user) {
+		fprintf( stderr, "WARNING: Not enough clusters for a "
+			 "16 bit FAT! The filesystem will be\n"
+			 "misinterpreted as having a 12 bit FAT without "
+			 "mount option \"fat=16\".\n" );
+	    }
+	    else {
+		fprintf( stderr, "This filesystem has an unfortunate size. "
+			 "A 12 bit FAT cannot provide\n"
+			 "enough clusters, but a 16 bit FAT takes up a little "
+			 "bit more space so that\n"
+			 "the total number of clusters becomes less than the "
+			 "threshold value for\n"
+			 "distinction between 12 and 16 bit FATs.\n" );
+		die( "Make the file system a bit smaller manually." );
+	    }
+	}
+	cluster_count = clust16;
+	fat_length = fatlength16;
+	bs.fat_length = CT_LE_W(fatlength16);
+	memcpy(vi->fs_type, MSDOS_FAT16_SIGN, 8);
+	break;
+
+      case 32:
+	cluster_count = clust32;
+	fat_length = fatlength32;
+	bs.fat_length = CT_LE_W(0);
+	bs.fat32.fat32_length = CT_LE_L(fatlength32);
+	memcpy(vi->fs_type, MSDOS_FAT32_SIGN, 8);
+	break;
+	
+      default:
+	die("FAT not 12, 16 or 32 bits");
+    }
+  }
+  else {
+    unsigned clusters, maxclust;
+      
+    /* GEMDOS always uses a 12 bit FAT on floppies, and always a 16 bit FAT on
+     * hard disks. So use 12 bit if the size of the file system suggests that
+     * this fs is for a floppy disk, if the user hasn't explicitly requested a
+     * size.
+     */
+    if (!size_fat)
+      size_fat = (num_sectors == 1440 || num_sectors == 2400 ||
+		  num_sectors == 2880 || num_sectors == 5760) ? 12 : 16;
+    if (verbose >= 2)
+      printf( "Choosing %d bits for FAT\n", size_fat );
+
+    /* Atari format: cluster size should be 2, except explicitly requested by
+     * the user, since GEMDOS doesn't like other cluster sizes very much.
+     * Instead, tune the sector size for the FS to fit.
+     */
+    bs.cluster_size = sectors_per_cluster ? sectors_per_cluster : 2;
+    if (!sector_size_set) {
+      while( num_sectors > GEMDOS_MAX_SECTORS ) {
+	num_sectors >>= 1;
+	sector_size <<= 1;
+      }
+    }
+    if (verbose >= 2)
+      printf( "Sector size must be %d to have less than %d log. sectors\n",
+	      sector_size, GEMDOS_MAX_SECTORS );
+
+    /* Check if there are enough FAT indices for how much clusters we have */
+    do {
+      fatdata = num_sectors - cdiv (root_dir_entries * 32, sector_size) -
+		reserved_sectors;
+      /* The factor 2 below avoids cut-off errors for nr_fats == 1 and
+       * size_fat == 12
+       * The "2*nr_fats*size_fat/8" is for the reserved first two FAT entries
+       */
+      clusters = (2*((long long)fatdata*sector_size - 2*nr_fats*size_fat/8)) /
+		 (2*((int)bs.cluster_size*sector_size + nr_fats*size_fat/8));
+      fat_length = cdiv( (clusters+2)*size_fat/8, sector_size );
+      /* Need to recalculate number of clusters, since the unused parts of the
+       * FATS and data area together could make up space for an additional,
+       * not really present cluster. */
+      clusters = (fatdata - nr_fats*fat_length)/bs.cluster_size;
+      maxclust = (fat_length*sector_size*8)/size_fat;
+      if (verbose >= 2)
+	printf( "ss=%d: #clu=%d, fat_len=%d, maxclu=%d\n",
+		sector_size, clusters, fat_length, maxclust );
+      
+      /* last 10 cluster numbers are special (except FAT32: 4 high bits rsvd);
+       * first two numbers are reserved */
+      if (maxclust <= (size_fat == 32 ? MAX_CLUST_32 : (1<<size_fat)-0x10) &&
+	  clusters <= maxclust-2)
+	break;
+      if (verbose >= 2)
+	printf( clusters > maxclust-2 ?
+		"Too many clusters\n" : "FAT too big\n" );
+
+      /* need to increment sector_size once more to  */
+      if (sector_size_set)
+	  die( "With this sector size, the maximum number of FAT entries "
+	       "would be exceeded." );
+      num_sectors >>= 1;
+      sector_size <<= 1;
+    } while( sector_size <= GEMDOS_MAX_SECTOR_SIZE );
+    
+    if (sector_size > GEMDOS_MAX_SECTOR_SIZE)
+      die( "Would need a sector size > 16k, which GEMDOS can't work with");
+
+    cluster_count = clusters;
+    if (size_fat != 32)
+	bs.fat_length = CT_LE_W(fat_length);
+    else {
+	bs.fat_length = 0;
+	bs.fat32.fat32_length = CT_LE_L(fat_length);
+    }
+  }
+
+  bs.sector_size[0] = (char) (sector_size & 0x00ff);
+  bs.sector_size[1] = (char) ((sector_size & 0xff00) >> 8);
+
+  if (size_fat == 32)
+    {
+      /* set up additional FAT32 fields */
+      bs.fat32.flags = CT_LE_W(0);
+      bs.fat32.version[0] = 0;
+      bs.fat32.version[1] = 0;
+      bs.fat32.root_cluster = CT_LE_L(2);
+      bs.fat32.info_sector = CT_LE_W(1);
+      if (!backup_boot)
+	backup_boot = (reserved_sectors >= 7) ? 6 :
+		      (reserved_sectors >= 2) ? reserved_sectors-1 : 0;
+      else
+	{
+	  if (backup_boot == 1)
+	    die("Backup boot sector must be after sector 1");
+	  else if (backup_boot >= reserved_sectors)
+	    die("Backup boot sector must be a reserved sector");
+	}
+      if (verbose >= 2)
+	printf( "Using sector %d as backup boot sector (0 = none)\n",
+		backup_boot );
+      bs.fat32.backup_boot = CT_LE_W(backup_boot);
+      memset( &bs.fat32.reserved2, 0, sizeof(bs.fat32.reserved2) );
+    }
+  
+  if (atari_format) {
+      /* Just some consistency checks */
+      if (num_sectors >= GEMDOS_MAX_SECTORS)
+	  die( "GEMDOS can't handle more than 65531 sectors" );
+      else if (num_sectors >= OLDGEMDOS_MAX_SECTORS)
+	  printf( "Warning: More than 32765 sector need TOS 1.04 "
+		  "or higher.\n" );
+  }
+  if (num_sectors >= 65536)
+    {
+      bs.sectors[0] = (char) 0;
+      bs.sectors[1] = (char) 0;
+      bs.total_sect = CT_LE_L(num_sectors);
+    }
+  else
+    {
+      bs.sectors[0] = (char) (num_sectors & 0x00ff);
+      bs.sectors[1] = (char) ((num_sectors & 0xff00) >> 8);
+      if (!atari_format)
+	  bs.total_sect = CT_LE_L(0);
+    }
+
+  if (!atari_format)
+    vi->ext_boot_sign = MSDOS_EXT_SIGN;
+
+  if (!cluster_count)
+    {
+      if (sectors_per_cluster)	/* If yes, die if we'd spec'd sectors per cluster */
+	die ("Too many clusters for file system - try more sectors per cluster");
+      else
+	die ("Attempting to create a too large file system");
+    }
+
+  
+  /* The two following vars are in hard sectors, i.e. 512 byte sectors! */
+  start_data_sector = (reserved_sectors + nr_fats * fat_length) *
+		      (sector_size/HARD_SECTOR_SIZE);
+  start_data_block = (start_data_sector + SECTORS_PER_BLOCK - 1) /
+		     SECTORS_PER_BLOCK;
+
+  if (blocks < start_data_block + 32)	/* Arbitrary undersize file system! */
+    die ("Too few blocks for viable file system");
+
+  if (verbose)
+    {
+      printf("%s has %d head%s and %d sector%s per track,\n",
+	     device_name, CF_LE_W(bs.heads), (CF_LE_W(bs.heads) != 1) ? "s" : "",
+	     CF_LE_W(bs.secs_track), (CF_LE_W(bs.secs_track) != 1) ? "s" : ""); 
+      printf("logical sector size is %d,\n",sector_size);
+      printf("using 0x%02x media descriptor, with %d sectors;\n",
+	     (int) (bs.media), num_sectors);
+      printf("file system has %d %d-bit FAT%s and %d sector%s per cluster.\n",
+	     (int) (bs.fats), size_fat, (bs.fats != 1) ? "s" : "",
+	     (int) (bs.cluster_size), (bs.cluster_size != 1) ? "s" : "");
+      printf ("FAT size is %d sector%s, and provides %d cluster%s.\n",
+	      fat_length, (fat_length != 1) ? "s" : "",
+	      cluster_count, (cluster_count != 1) ? "s" : "");
+      if (size_fat != 32)
+	printf ("Root directory contains %d slots.\n",
+		(int) (bs.dir_entries[0]) + (int) (bs.dir_entries[1]) * 256);
+      printf ("Volume ID is %08lx, ", volume_id &
+	      (atari_format ? 0x00ffffff : 0xffffffff));
+      if ( strcmp(volume_name, "           ") )
+	printf("volume label %s.\n", volume_name);
+      else
+	printf("no volume label.\n");
+    }
+
+  /* Make the file allocation tables! */
+
+  if ((fat = (unsigned char *) malloc (fat_length * sector_size)) == NULL)
+    die ("unable to allocate space for FAT image in memory");
+
+  memset( fat, 0, fat_length * sector_size );
+
+  mark_FAT_cluster (0, 0xffffffff);	/* Initial fat entries */
+  mark_FAT_cluster (1, 0xffffffff);
+  fat[0] = (unsigned char) bs.media;	/* Put media type in first byte! */
+  if (size_fat == 32) {
+    /* Mark cluster 2 as EOF (used for root dir) */
+    mark_FAT_cluster (2, FAT_EOF);
+  }
+
+  /* Make the root directory entries */
+
+  size_root_dir = (size_fat == 32) ?
+		  bs.cluster_size*sector_size :
+		  (((int)bs.dir_entries[1]*256+(int)bs.dir_entries[0]) *
+		   sizeof (struct msdos_dir_entry));
+  if ((root_dir = (struct msdos_dir_entry *) malloc (size_root_dir)) == NULL)
+    {
+      free (fat);		/* Tidy up before we die! */
+      die ("unable to allocate space for root directory in memory");
+    }
+
+  memset(root_dir, 0, size_root_dir);
+  if ( memcmp(volume_name, "           ", 11) )
+    {
+      struct msdos_dir_entry *de = &root_dir[0];
+      memcpy(de->name, volume_name, 11);
+      de->attr = ATTR_VOLUME;
+      st_ctime = localtime(&create_time);
+      de->time = CT_LE_W((unsigned short)((st_ctime->tm_sec >> 1) +
+			  (st_ctime->tm_min << 5) + (st_ctime->tm_hour << 11)));
+      de->date = CT_LE_W((unsigned short)(st_ctime->tm_mday +
+					  ((st_ctime->tm_mon+1) << 5) +
+					  ((st_ctime->tm_year-80) << 9)));
+      de->ctime_ms = 0;
+      de->ctime = de->time;
+      de->cdate = de->date;
+      de->adate = de->date;
+      de->starthi = CT_LE_W(0);
+      de->start = CT_LE_W(0);
+      de->size = CT_LE_L(0);
+    }
+
+  if (size_fat == 32) {
+    /* For FAT32, create an info sector */
+    struct fat32_fsinfo *info;
+    
+    if (!(info_sector = malloc( sector_size )))
+      die("Out of memory");
+    memset(info_sector, 0, sector_size);
+    /* fsinfo structure is at offset 0x1e0 in info sector by observation */
+    info = (struct fat32_fsinfo *)(info_sector + 0x1e0);
+
+    /* Info sector magic */
+    info_sector[0] = 'R';
+    info_sector[1] = 'R';
+    info_sector[2] = 'a';
+    info_sector[3] = 'A';
+
+    /* Magic for fsinfo structure */
+    info->signature = CT_LE_L(0x61417272);
+    /* We've allocated cluster 2 for the root dir. */
+    info->free_clusters = CT_LE_L(cluster_count - 1);
+    info->next_cluster = CT_LE_L(2);
+
+    /* Info sector also must have boot sign */
+    *(__u16 *)(info_sector + 0x1fe) = CT_LE_W(BOOT_SIGN);
+  }
+  
+  if (!(blank_sector = malloc( sector_size )))
+      die( "Out of memory" );
+  memset(blank_sector, 0, sector_size);
+}
+
+
+/* Write the new filesystem's data tables to wherever they're going to end up! */
+
+#define error(str)				\
+  do {						\
+    free (fat);					\
+    if (info_sector) free (info_sector);	\
+    free (root_dir);				\
+    die (str);					\
+  } while(0)
+
+#define seekto(pos,errstr)						\
+  do {									\
+    loff_t __pos = (pos);						\
+    if (llseek (dev, __pos, SEEK_SET) != __pos)				\
+	error ("seek to " errstr " failed whilst writing tables");	\
+  } while(0)
+
+#define writebuf(buf,size,errstr)			\
+  do {							\
+    int __size = (size);				\
+    if (write (dev, buf, __size) != __size)		\
+	error ("failed whilst writing " errstr);	\
+  } while(0)
+
+
+static void
+write_tables (void)
+{
+  int x;
+  int fat_length;
+
+  fat_length = (size_fat == 32) ?
+	       CF_LE_L(bs.fat32.fat32_length) : CF_LE_W(bs.fat_length);
+
+  seekto( 0, "start of device" );
+  /* clear all reserved sectors */
+  for( x = 0; x < reserved_sectors; ++x )
+    writebuf( blank_sector, sector_size, "reserved sector" );
+  /* seek back to sector 0 and write the boot sector */
+  seekto( 0, "boot sector" );
+  writebuf( (char *) &bs, sizeof (struct msdos_boot_sector), "boot sector" );
+  /* on FAT32, write the info sector and backup boot sector */
+  if (size_fat == 32)
+    {
+      seekto( CF_LE_W(bs.fat32.info_sector)*sector_size, "info sector" );
+      writebuf( info_sector, 512, "info sector" );
+      if (backup_boot != 0)
+	{
+	  seekto( backup_boot*sector_size, "backup boot sector" );
+	  writebuf( (char *) &bs, sizeof (struct msdos_boot_sector),
+		    "backup boot sector" );
+	}
+    }
+  /* seek to start of FATS and write them all */
+  seekto( reserved_sectors*sector_size, "first FAT" );
+  for (x = 1; x <= nr_fats; x++)
+    writebuf( fat, fat_length * sector_size, "FAT" );
+  /* Write the root directory directly after the last FAT. This is the root
+   * dir area on FAT12/16, and the first cluster on FAT32. */
+  writebuf( (char *) root_dir, size_root_dir, "root directory" );
+
+  if (blank_sector) free( blank_sector );
+  if (info_sector) free( info_sector );
+  free (root_dir);   /* Free up the root directory space from setup_tables */
+  free (fat);  /* Free up the fat table space reserved during setup_tables */
+}
+
+
+/* Report the command usage and return a failure error code */
+
+void
+usage (void)
+{
+  fatal_error("\
+Usage: mkdosfs [-A] [-c] [-C] [-v] [-I] [-l bad-block-file] [-b backup-boot-sector]\n\
+       [-m boot-msg-file] [-n volume-name] [-i volume-id]\n\
+       [-s sectors-per-cluster] [-S logical-sector-size] [-f number-of-FATs]\n\
+       [-h hidden-sectors] [-F fat-size] [-r root-dir-entries] [-R reserved-sectors]\n\
+       /dev/name [blocks]\n");
+}
+
+/*
+ * ++roman: On m68k, check if this is an Atari; if yes, turn on Atari variant
+ * of MS-DOS filesystem by default.
+ */
+static void check_atari( void )
+{
+#ifdef __mc68000__
+    FILE *f;
+    char line[128], *p;
+
+    if (!(f = fopen( "/proc/hardware", "r" ))) {
+	perror( "/proc/hardware" );
+	return;
+    }
+
+    while( fgets( line, sizeof(line), f ) ) {
+	if (strncmp( line, "Model:", 6 ) == 0) {
+	    p = line + 6;
+	    p += strspn( p, " \t" );
+	    if (strncmp( p, "Atari ", 6 ) == 0)
+		atari_format = 1;
+	    break;
+	}
+    }
+    fclose( f );
+#endif
+}
+
+/* The "main" entry point into the utility - we pick up the options and attempt to process them in some sort of sensible
+   way.  In the event that some/all of the options are invalid we need to tell the user so that something can be done! */
+
+int
+mkdosfs_main (int argc, char **argv)
+{
+  int c;
+  char *tmp;
+  char *listfile = NULL;
+  FILE *msgfile;
+  struct stat statbuf;
+  int i = 0, pos, ch;
+  int create = 0;
+  unsigned long long cblocks=0;
+  
+  if (argc && *argv) {		/* What's the program name? */
+    char *p;
+    program_name = *argv;
+    if ((p = strrchr( program_name, '/' )))
+	program_name = p+1;
+  }
+
+  time(&create_time);
+  volume_id = (long)create_time;	/* Default volume ID = creation time */
+  check_atari();
+  
+  printf ("%s " VERSION " (" VERSION_DATE ")\n",
+	   program_name);
+
+  while ((c = getopt (argc, argv, "AbcCf:F:Ii:l:m:n:r:R:s:S:h:v")) != EOF)
+    /* Scan the command line for options */
+    switch (c)
+      {
+      case 'A':		/* toggle Atari format */
+	atari_format = !atari_format;
+	break;
+
+      case 'b':		/* b : location of backup boot sector */
+	backup_boot = (int) strtol (optarg, &tmp, 0);
+	if (*tmp || backup_boot < 2 || backup_boot > 0xffff)
+	  {
+	    printf ("Bad location for backup boot sector : %s\n", optarg);
+	    usage ();
+	  }
+	break;
+	
+      case 'c':		/* c : Check FS as we build it */
+	check = TRUE;
+	break;
+
+      case 'C':		/* C : Create a new file */
+	create = TRUE;
+	break;
+
+      case 'f':		/* f : Choose number of FATs */
+	nr_fats = (int) strtol (optarg, &tmp, 0);
+	if (*tmp || nr_fats < 1 || nr_fats > 4)
+	  {
+	    printf ("Bad number of FATs : %s\n", optarg);
+	    usage ();
+	  }
+	break;
+
+      case 'F':		/* F : Choose FAT size */
+	size_fat = (int) strtol (optarg, &tmp, 0);
+	if (*tmp || (size_fat != 12 && size_fat != 16 && size_fat != 32))
+	  {
+	    printf ("Bad FAT type : %s\n", optarg);
+	    usage ();
+	  }
+	size_fat_by_user = 1;
+	break;
+
+      case 'h':        /* h : number of hidden sectors */
+	hidden_sectors = (int) strtol (optarg, &tmp, 0);
+	if ( *tmp || hidden_sectors < 0 )
+	  {
+	    printf("Bad number of hidden sectors : %s\n", optarg);
+	    usage ();
+	  }
+	break;
+
+      case 'I':
+	ignore_full_disk = 1;
+	break;
+
+      case 'i':		/* i : specify volume ID */
+	volume_id = strtoul(optarg, &tmp, 16);
+	if ( *tmp )
+	  {
+	    printf("Volume ID must be a hexadecimal number\n");
+	    usage();
+	  }
+	break;
+
+      case 'l':		/* l : Bad block filename */
+	listfile = optarg;
+	break;
+
+      case 'm':		/* m : Set boot message */
+	if ( strcmp(optarg, "-") )
+	  {
+	    msgfile = fopen(optarg, "r");
+	    if ( !msgfile )
+	      perror(optarg);
+	  }
+	else
+	  msgfile = stdin;
+
+	if ( msgfile )
+	  {
+	    /* The boot code ends at offset 448 and needs a null terminator */
+	    i = MESSAGE_OFFSET;
+	    pos = 0;		/* We are at beginning of line */
+	    do
+	      {
+		ch = getc(msgfile);
+		switch (ch)
+		  {
+		  case '\r':	/* Ignore CRs */
+		  case '\0':	/* and nulls */
+		    break;
+
+		  case '\n':	/* LF -> CR+LF if necessary */
+		    if ( pos )	/* If not at beginning of line */
+		      {
+			dummy_boot_code[i++] = '\r';
+			pos = 0;
+		      }
+		    dummy_boot_code[i++] = '\n';
+		    break;
+
+		  case '\t':	/* Expand tabs */
+		    do
+		      {
+			dummy_boot_code[i++] = ' ';
+			pos++;
+		      }
+		    while ( pos % 8 && i < BOOTCODE_SIZE-1 );
+		    break;
+
+		  case EOF:
+		    dummy_boot_code[i++] = '\0'; /* Null terminator */
+		    break;
+
+		  default:
+		    dummy_boot_code[i++] = ch; /* Store character */
+		    pos++;	/* Advance position */
+		    break;
+		  }
+	      }
+	    while ( ch != EOF && i < BOOTCODE_SIZE-1 );
+
+	    /* Fill up with zeros */
+	    while( i < BOOTCODE_SIZE-1 )
+		dummy_boot_code[i++] = '\0';
+	    dummy_boot_code[BOOTCODE_SIZE-1] = '\0'; /* Just in case */
+	    
+	    if ( ch != EOF )
+	      printf ("Warning: message too long; truncated\n");
+	    
+	    if ( msgfile != stdin )
+	      fclose(msgfile);
+	  }
+	break;
+
+      case 'n':		/* n : Volume name */
+	sprintf(volume_name, "%-11.11s", optarg);
+	break;
+
+      case 'r':		/* r : Root directory entries */
+	root_dir_entries = (int) strtol (optarg, &tmp, 0);
+	if (*tmp || root_dir_entries < 16 || root_dir_entries > 32768)
+	  {
+	    printf ("Bad number of root directory entries : %s\n", optarg);
+	    usage ();
+	  }
+	break;
+
+      case 'R':		/* R : number of reserved sectors */
+	reserved_sectors = (int) strtol (optarg, &tmp, 0);
+	if (*tmp || reserved_sectors < 1 || reserved_sectors > 0xffff)
+	  {
+	    printf ("Bad number of reserved sectors : %s\n", optarg);
+	    usage ();
+	  }
+	break;
+	
+      case 's':		/* s : Sectors per cluster */
+	sectors_per_cluster = (int) strtol (optarg, &tmp, 0);
+	if (*tmp || (sectors_per_cluster != 1 && sectors_per_cluster != 2
+		     && sectors_per_cluster != 4 && sectors_per_cluster != 8
+		   && sectors_per_cluster != 16 && sectors_per_cluster != 32
+		&& sectors_per_cluster != 64 && sectors_per_cluster != 128))
+	  {
+	    printf ("Bad number of sectors per cluster : %s\n", optarg);
+	    usage ();
+	  }
+	break;
+
+      case 'S':		/* S : Sector size */
+	sector_size = (int) strtol (optarg, &tmp, 0);
+	if (*tmp || (sector_size != 512 && sector_size != 1024 &&
+		     sector_size != 2048 && sector_size != 4096 &&
+		     sector_size != 8192 && sector_size != 16384 &&
+		     sector_size != 32768))
+	  {
+	    printf ("Bad logical sector size : %s\n", optarg);
+	    usage ();
+	  }
+	sector_size_set = 1;
+	break;
+
+      case 'v':		/* v : Verbose execution */
+	++verbose;
+	break;
+	
+      default:
+	printf( "Unknown option: %c\n", c );
+	usage ();
+      }
+  if (optind < argc)
+    {
+      device_name = argv[optind];  /* Determine the number of blocks in the FS */
+      if (!create)
+         cblocks = count_blocks (device_name); /*  Have a look and see! */
+    }
+  if (optind == argc - 2)	/*  Either check the user specified number */
+    {
+      blocks = strtoull (argv[optind + 1], &tmp, 0);
+      if (!create && blocks != cblocks)
+	{
+	  fprintf (stderr, "Warning: block count mismatch: ");
+	  fprintf (stderr, "found %llu but assuming %llu.\n",cblocks,blocks);
+	}
+    }
+  else if (optind == argc - 1)	/*  Or use value found */
+    {
+      if (create)
+	die( "Need intended size with -C." );
+      blocks = cblocks;
+      tmp = "";
+    }
+  else
+    {
+      fprintf (stderr, "No device specified!\n");
+      usage ();
+    }
+  if (*tmp)
+    {
+      printf ("Bad block count : %s\n", argv[optind + 1]);
+      usage ();
+    }
+
+  if (check && listfile)	/* Auto and specified bad block handling are mutually */
+    die ("-c and -l are incompatible");		/* exclusive of each other! */
+
+  if (!create) {
+    check_mount (device_name);	/* Is the device already mounted? */
+    dev = open (device_name, O_RDWR);	/* Is it a suitable device to build the FS on? */
+    if (dev < 0)
+      die ("unable to open %s");
+  }
+  else {
+      off_t offset = blocks*BLOCK_SIZE - 1;
+      char null = 0;
+      /* create the file */
+      dev = open( device_name, O_RDWR|O_CREAT|O_TRUNC, 0666 );
+      if (dev < 0)
+	die("unable to create %s");
+      /* seek to the intended end-1, and write one byte. this creates a
+       * sparse-as-possible file of appropriate size. */
+      if (llseek( dev, offset, SEEK_SET ) != offset)
+	die( "seek failed" );
+      if (write( dev, &null, 1 ) < 0)
+	die( "write failed" );
+      if (llseek( dev, 0, SEEK_SET ) != 0)
+	die( "seek failed" );
+  }
+  
+  if (fstat (dev, &statbuf) < 0)
+    die ("unable to stat %s");
+  if (!S_ISBLK (statbuf.st_mode)) {
+    statbuf.st_rdev = 0;
+    check = 0;
+  }
+  else
+    /*
+     * Ignore any 'full' fixed disk devices, if -I is not given.
+     * On a MO-disk one doesn't need partitions.  The filesytem can go
+     * directly to the whole disk.  Under other OSes this is known as
+     * the 'superfloppy' format.  As I don't know how to find out if
+     * this is a MO disk I introduce a -I (ignore) switch.  -Joey
+     */
+    if (!ignore_full_disk && (
+	(statbuf.st_rdev & 0xff3f) == 0x0300 || /* hda, hdb */
+	(statbuf.st_rdev & 0xff0f) == 0x0800 || /* sd */
+	(statbuf.st_rdev & 0xff3f) == 0x0d00 || /* xd */
+	(statbuf.st_rdev & 0xff3f) == 0x1600 )  /* hdc, hdd */
+	)
+      die ("Will not try to make filesystem on full-disk device '%s' (use -I if wanted)");
+
+  establish_params (statbuf.st_rdev,statbuf.st_size);	
+                                /* Establish the media parameters */
+
+  setup_tables ();		/* Establish the file system tables */
+
+  if (check)			/* Determine any bad block locations and mark them */
+    check_blocks ();
+  else if (listfile)
+    get_list_blocks (listfile);
+
+  write_tables ();		/* Write the file system tables away! */
+
+  exit (0);			/* Terminate with no errors! */
+}
+
+
+/* That's All Folks */
+/* Local Variables: */
+/* tab-width: 8     */
+/* End:             */
